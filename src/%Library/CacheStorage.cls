IncludeGenerator %systemInclude

/// The <b>%CacheStorage</b> class contains the storage interface methods 
/// for the Cach&eacute; default storage structure. The storage interface 
/// methods, which are implemented as method generators, work in conjunction 
/// with the persistent interface methods of the <b>%Persistent</b> class to 
/// provide persistent behavior for objects. 
/// 
/// <p>The methods of <b>%CacheStorage</b> are not meant to be called directly. 
/// Use the methods of the <b>%Persistent</b> class which, in turn, call the 
/// appropriate <b>%CacheStorage</b> method. 
Class %Library.CacheStorage Extends %Storage [ Abstract, Not ProcedureBlock, System = 2 ]
{

Parameter STORAGECOMPILERCLASS = "%Compiler.Storage.Cache";

/// STORAGEINTERFACE defines the type of serialization implemented by this class.
/// The value has to match the classtype of the class that is inheriting the serialization
/// interface.
Parameter STORAGEINTERFACE As STRING [ Constraint = ",persistent,serial", Flags = ENUM ] = "persistent";

ClassMethod %BMEBuilt(ByRef bmeName As %String) As %Boolean [ CodeMode = generator, ServerOnly = 1 ]
{
	If $Data($$$tEXTcode("BMEBuilt")) { m %code=$$$tEXTcode("BMEBuilt") }
	Else { $$$GENERATE("	Quit 1") }
	QUIT $$$OK
}

/// This method will build the indexes requested for the range of ID's requested. If it is prudent to do this work in the background 
/// using multiple processes then it will be done using $system.WorkQueue. 
/// If doing the work in the background then the extent will be partitioned using one of four different algorithms.
/// 1) Integer ID, no bitmap extent index present - compute the difference between the first ID and the last, divide by partition size;
/// 2) Integer ID, bitmap extent index present - chunk up using bitmap chunk size and the bitmap extent;
/// 3) Single non-integer property - 
/// 4) Composite ID on non-integer property -
ClassMethod %BuildIndices(pIndexList As %CacheString = "", pAutoPurge As %Integer = 1, pLockFlag As %Integer = 0, pJournalFlag As %Integer = 1, pStartID As %CacheString = "", pEndID As %CacheString = "", pIgnoreIndexList As %CacheString = "") As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	If $Data($$$tEXTcode("BuildIndices")) { m %code=$$$tEXTcode("BuildIndices") }
	Else { $$$GENERATE($Char(9)_"Quit 1") }
	QUIT $$$OK
}

/// This function generates the code to iterate over a range of ID values, invoking the index filer for each ID.
ClassMethod %BuildIndicesSegment(pStartID As %Integer, pEndID As %Integer, ByRef pIndexHandle As %Binary = 0, pLockFlag As %Integer = 1, pFirstRange As %Boolean = 0, pJob As %CacheString = "") As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	If $Data($$$tEXTcode("BuildIndicesSegment")) { m %code=$$$tEXTcode("BuildIndicesSegment") }
	Else { $$$GENERATE($Char(9)_"Quit 1") }
	QUIT $$$OK
}

ClassMethod %FileIndicesBuffered(id As %String(MAXLEN=""), ByRef pIndexHandle As %Binary = 0, ByRef pIndexBuffer As %CacheString = "") As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	If $Data($$$tEXTcode("FileIndicesBuffered")) { m %code=$$$tEXTcode("FileIndicesBuffered") }
	Else {
		set %codemode = $$$cMETHCODEMODEEXPRESSION
		set %code="..%FileIndices(.id,.pIndexHandle)"
	}
	QUIT $$$OK
}

/// %DeleteData()
/// 	Delete object from persistent storage
/// 	The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
ClassMethod %DeleteData(id As %String, concurrency As %Integer) As %Status [ CodeMode = generator, Final, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("DeleteData")
 QUIT $$$OK
}

/// %Exists()
/// 	Check to see if an OID exists in the extent of this class...
ClassMethod %Exists(oid As %ObjectIdentity = "") As %Boolean [ Final, ProcedureBlock = 1, ServerOnly = 0 ]
{
	Quit ..%ExistsId($$$oidPrimary(oid))
}

/// %ExistsId()
/// 	Check to see if an ID exists in the extent of this class...
ClassMethod %ExistsId(id As %String) As %Boolean [ CodeMode = generator, Final, ProcedureBlock = 1, ServerOnly = 0 ]
{
	If $Data($$$tEXTcode("ExistsId")) {
		Kill %code
		Merge %code = $$$tEXTcode("ExistsId")
		If $Data(%code) = 1 { Set %codemode=$$$cMETHCODEMODEEXPRESSION }
	}
	ElseIf $$$CLASSabstract($$$gMGINFO,%class) {
		Set %code = "$isobject(..%OpenId(id,0))", %codemode = $$$cMETHCODEMODEEXPRESSION
	}
	Else { Set %code = 0 }
	QUIT $$$OK
}

/// Files each index for the object identified by <var>id</var>. <var>pIndexHandle</var> is for internal use only.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
/// This method is normally generated by the storage class for persistent classes using
/// <class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>.
ClassMethod %FileIndices(id As %String(MAXLEN=""), ByRef pIndexHandle As %Binary = 0) As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	If $Data($$$tEXTcode("FileIndices")) { m %code=$$$tEXTcode("FileIndices") }
	Else { $$$GENERATE($Char(9)_"quit 1") }
	QUIT $$$OK
}

/// 	Kill the data, index, and idlocations for extent root classes. Return an error if the class
/// 	is not the extent root class.
ClassMethod %KillExtentData() As %Status [ CodeMode = generator, Final, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("KillExtent")
 QUIT $$$OK
}

/// 	Load object from persistent storage into memory. The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
Method %LoadData(id As %String) As %Status [ CodeMode = generator, Final, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("LoadData")
 QUIT $$$OK
}

/// 	Load object from persistent storage into memory. The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
/// 	state is the physical data where the structure of state mirrors the structure of the object on disk
/// 	obj is an array, subscripted by property name where each array element is equal to the property value named as the subscript.
ClassMethod %LoadFromMemory(id As %String, ByRef objstate As %String, ByRef obj As %String) As %Status [ Final, ProcedureBlock = 1, ServerOnly = 1 ]
{
	If $Get(id)="" Quit $$$ERROR($$$NullOid,$classname())
	Set oref=$$$CreateObject($classname()) If oref=$$$NULLOREF Set sc = $$$ERROR($$$AbstractClassNotInstantiable,$classname()) Quit oref
	Set sc=oref.%LoadInit(,$zu(115,10)) If $$$ISERR(sc) Quit $$$NULLOREF
	Set sc=oref.%LoadDataFromMemory(id,.objstate,.obj) If $$$ISERR(sc) Quit $$$NULLOREF
	#; set object as not modified
	Do $system.CLS.SetModified(oref,0)
	Quit oref
}

Method %LoadDataFromMemory(id As %String, ByRef objstate As %String, ByRef obj As %String) As %Status [ CodeMode = generator, Final, Internal, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("LoadDataFromMemory")
 QUIT $$$OK
}

/// 	Load object from persistent storage into memory. The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
ClassMethod %PhysicalAddress(id As %String, ByRef paddr As %String) As %Status [ CodeMode = generator, Final, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("PhysicalAddress")
 QUIT $$$OK
}

/// %OnDetermineClass - find the most-specific-type-class for the given OID.
ClassMethod %OnDetermineClass(oid As %ObjectIdentity, ByRef class As %String) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("OnDetermineClass")
 QUIT $$$OK
}

ClassMethod %PurgeIndices(idxlist As %List = "", lockExtent As %Boolean = 0, pIgnoreIndexList As %CacheString = "") As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("PurgeIndices")
 QUIT $$$OK
}

/// Acquire (s)hared or (e)xclusive locks based on locktype parameter
ClassMethod %LockExtent(shared As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("LockExtent")
 QUIT $$$OK
}

/// Release (s)hared or (e)xclusive locks based on locktype parameter
ClassMethod %UnlockExtent(shared As %Boolean = 0, immediate As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("UnlockExtent")
 QUIT $$$OK
}

/// %LockId()
/// 		Obtain an exclusive or shared lock on the object identified by <var>id</var>. The type
/// 		of lock obtained is determined by <var>shared</var>. This method overrides the implementation
/// 			from %Library.Persistent.
ClassMethod %LockId(id As %String, shared As %Boolean = 0, timeout As %Integer = {$$$LockTimeout}) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("LockId")
 QUIT $$$OK
}

/// %UnlockId()
/// 		Release an exclusive or shared lock on the object identified by <var>id</var>. The type
/// 		of lock released is determined by <var>shared</var>.This method overrides the implementation
/// 			from %Library.Persistent.
ClassMethod %UnlockId(id As %String, shared As %Boolean = 0, immediate As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("UnlockId")
 QUIT $$$OK
}

/// %SaveData()
/// Save the object to a persistent state (e.g. store it on disk)
/// return: oid or "" if save fails
Method %SaveData(id As %String) As %Status [ CodeMode = generator, Final, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	set %code=0
	merge %code=$$$tEXTcode("SaveData")
	QUIT $$$OK
}

ClassMethod %InsertBatch(objects As %List, concurrency As %Integer = 0, useTransactions As %Boolean = 0) As %List [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
	set %code = 0, tStatus = $$$OK
	if ($$$getClassType(%class)=$$$cCLASSCLASSTYPEPERSISTENT) && ('$$$comClassKeyGet(%class,$$$cCLASSnoextent)) {
		try {
			set mvEnabled = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"MVENABLED",$$$cPARAMdefault)
			set tGenerator = ##class(%Compiler.Storage.Generator.Cache).%New(0,%class,mvEnabled,,1)
			if $Find($Extract(tGenerator.triggers,1,4),$Char(1)) { $$$tMetadataUses("PrecompileTriggerCode^%occTrigger(%class)") }
			do tGenerator.generateInsertBatch(.%code)
		}
		catch tException {
			set tStatus = tException.AsStatus()
		}
	}
	quit tStatus
}

/// %SaveDirect() - saves an object to disk, checks uniqueness and referential
/// integrity constraints, and maintains index structures. This method is
/// implemented by the storage class.
ClassMethod %SaveDirect(ByRef id As %String = "", idList As %List = "", ByRef data As %Binary, concurrency As %Integer = -1) As %Status [ CodeMode = generator, Final, ProcedureBlock = 1, ServerOnly = 1 ]
{
	set %code = 0, tStatus = $$$OK
	if ($$$getClassType(%class)=$$$cCLASSCLASSTYPEPERSISTENT) && ('$$$comClassKeyGet(%class,$$$cCLASSnoextent)) {
		try {
			set mvEnabled = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"MVENABLED",$$$cPARAMdefault)
			set tGenerator = ##class(%Compiler.Storage.Generator.Cache).%New(0,%class,mvEnabled)
			if $Find($Extract(tGenerator.triggers,1,4),$Char(1)) { $$$tMetadataUses("PrecompileTriggerCode^%occTrigger(%class)") }
			do tGenerator.generateSaveDirect(.%code)
		}
		catch tException {
			set tStatus = tException.AsStatus()
		}
	}
	quit tStatus
}

/// Files the indices for all objects whose ID is in the range defined by <var>pStartId</var> and <var>pEndId</var>.
/// If <var>pEndID</var> is null then it defaults to <var>pStartId</var>. If <var>pStartId</var> is null then the
/// range is empty and no filing will occur.
/// 
/// If <var>lockExtent</var> is true then an extent lock will be acquired before the indices
/// are built. If the lock cannot be acquired then an error is returned. The lock is released
/// after the index filing is completed.
/// 
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
ClassMethod %SaveIndices(pStartId As %String(MAXLEN="") = "", pEndId As %String(MAXLEN="") = "", lockExtent As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 0 ]
{
	set %code=0
	merge %code=$$$tEXTcode("SaveIndices")
	QUIT $$$OK
}

/// %SortBegin()
/// This method will start a system merge sort for all indices (idxlist is null) or for specified indices
ClassMethod %SortBegin(idxlist As %List = "", excludeunique As %Integer = 0) As %Status [ CodeMode = generator, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("SortBegin")
 QUIT $$$OK
}

/// %SortEnd()
/// This method will end a system merge sort for all indices (idxlist is null) or for specified indices
ClassMethod %SortEnd(idxlist As %List = "", commit As %Integer = 1) As %Status [ CodeMode = generator, ServerOnly = 1 ]
{
 s %code=0
 m %code=$$$tEXTcode("SortEnd")
 QUIT $$$OK
}

}
