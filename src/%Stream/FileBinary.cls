Include (%sySystem, %occStream)

/// Stream class that stores binary data in files.
/// For example the following code opens a file binary stream, points it at a particular file
/// on the filesystem and then reads it in chunks of 32,000 bytes:
/// <example>
/// Set stream=##class(%Stream.FileBinary).%New()
/// Set sc=stream.LinkToFile("c:\myfile.txt")
/// While 'stream.AtEnd {
/// Set line=stream.Read()
/// ; Process the chunk here
/// }
/// </example>
Class %Stream.FileBinary Extends %Stream.Object [ ClientDataType = BINARYSTREAM, OdbcType = LONGVARBINARY, System = 2 ]
{

Parameter STORAGE = "OTHER";

Parameter FILEEXT = "stream";

Parameter OPENREAD = "RUK\RAW\";

Parameter OPENWRITE = "WUNK\RAW\";

Parameter OPENAPPEND = "AWUK\RAW\";

Parameter OPENREADTERM = "RSK\RAW\";

Parameter GZIP = 0;

Method %IsNull() As %Boolean [ CodeMode = expression ]
{
i%Mode=$$$modeREADNODATA
}

/// Hold the filename part of the permanent storage location
Property StoreFile As %String [ Internal, Private, Transient ];

Method IdSet(id As %String) As %Status
{
	If $select($$$isVMS:id["[",1:id["/"||(id["\")) {
		Set i%StoreFile=##class(%File).GetFilename(id)
	} Else {
		Set i%StoreFile=id
	}
	Set i%Id=id
	Set i%"%%OID"=..%Oid()
	Quit $$$OK
}

/// If true then when saving this file we need to move it to the default permanent location
Property MakePermLoc As %Boolean [ InitialExpression = 0, Private, Transient ];

/// Note that setting the <property>%Location</property> will cause a few things to happen.
/// It will delete any temporary file that may have been created. It will not touch any
/// permanent file that this object was associated with, if you wish to delete this pre-existing
/// permanent file then call <method>Clear</method> passing '1' as the argument before setting
/// the %Location. It then marks this object as pointing to a null stream in the new directory
/// you specified.
Method %LocationSet(dir As %String) As %Status
{
	Do ..Clear(0)
	Set i%NormalizedDirectory=$S(dir="":"",1:##class(%File).NormalizeDirectory(dir)),i%%Location=dir,i%MakePermLoc=0
	#; Reset file to the null stream ready for new data in this new directory
	Set i%TempFile="",..Id=""
	Set i%Mode=$$$modeREADNODATA,i%AtEnd=1
	Quit $$$OK
}

/// The filename that this stream is currently using
Property Filename As %String(MAXLEN = 5000) [ Calculated ];

Method FilenameSet(file As %String) As %Status [ CodeMode = call ]
{
..LinkToFile(file)
}

Method FilenameGet() As %String [ CodeMode = expression ]
{
$select((i%Mode=$$$modeREADNOTCHANGED)||(i%Mode=$$$modeWRITEJUSTSAVED):i%NormalizedDirectory_i%StoreFile,(i%Mode=$$$modeREADCHANGED)||(i%Mode=$$$modeWRITE)||(i%TempFile'=""):i%NormalizedDirectory_i%TempFile,1:"")
}

/// Read only property that returns the canonical filename if the file is open and "" if the file is not open.
/// On VMS this will include the file version number
Property CanonicalFilename As %String(MAXLEN = 5000) [ Calculated ];

Method CanonicalFilenameGet() As %String [ CodeMode = expression ]
{
##class(%File).CanonicalFilename(..Filename)
}

/// If true then on VMS only do not delete the persistent file before replacing it with the new version. This will
/// cause the new version to be written with a new version number and so will keep the old file version present.
Property UseVMSVersion As %Boolean [ InitialExpression = 0, Transient ];

Property Mode As %Integer [ InitialExpression = 0, Private ];

/// Normalized form of the directory. This is used for access to the file (as it adds the
/// extra '/' if needed), but it stores the <Property>%Location</Property> in the Id as
/// this may be a relative path.
Property NormalizedDirectory As %String(MAXLEN = 5000) [ Private ];

/// Name of file (without directory) containing temporary stream.
Property TempFile As %String(MAXLEN = 5000) [ Private, Transient ];

/// Full path name of currently opened file. Equal to "" if no file is open.
Property CurrFile As %String(MAXLEN = 5000) [ Private, Transient ];

/// If true then remove the permanent file as well as any temp file when this object is closed.
/// If you call %Save on a stream where RemoveOnClose is true it will set this to false as if you
/// explicitly save the stream you no longer want it to be removed when the object is closed. In order
/// to make sure %Save always runs the logic to reset the flag setting this to true 
/// causes %IsModified/%ObjectModified to return true.
Property RemoveOnClose As %Boolean [ InitialExpression = 0, Transient ];

/// Set to true if this is a variable record format file on VMS
Property VariableRecord As %Boolean [ InitialExpression = 0, Internal, Private, Transient ];

/// Holds the buffer data when reading variable record format files on VMS
Property Buffer As %String [ Internal, MultiDimensional, Private, Transient ];

/// Mode the device is opened in, either with terminators as delimitors or not.
Property ReadMode As %Integer [ InitialExpression = {$$$modeREADNORMAL}, Private, Transient ];

/// While reading this holds the file size
Property ReadSize As %Integer [ Transient ];

/// For file streams the line will terminate on any of the characters set in the LineTerminator, it does not support
/// multi-character line terminators because it uses the Cache file behavior which terminates on any of the characters.
/// Updating this in the middle of a file on VMS will rewind the file to the beginning because of the way files work
/// on VMS.
Property LineTerminator As %String(MAXLEN = 10) [ InitialExpression = {$get(^%SYS("Stream","LineTerminator"),$select($$$isUNIX:$char(10),1:$char(13,10)))}, Transient ];

Method LineTerminatorSet(terminator As %String) As %Status
{
	Set i%LineTerminator=terminator,i%ReadMode=$$$modeREADNORMAL
	Quit $$$OK
}

Method %OnConstructClone(object As %RegisteredObject, deep As %Boolean = 0, ByRef cloned As %String) As %Status [ Private, ProcedureBlock = 1 ]
{
	Set i%Mode=$$$modeREADNODATA,i%AtEnd=0,i%TempFile="",i%CurrFile="",i%ReadMode=$$$modeREADNORMAL,i%ReadSize=0,i%StoreFile=""
	Do:'object.%IsNull() ..CopyFrom(object)
	Quit $$$OK
}

Method %OnNew(initval As %String = "") As %Status [ Private ]
{
	Do ..LineTerminatorSetModified(0)
	If initval=$char(0) {
		Set initval=$get(^%SYS("StreamLocation",$namespace)),i%%Location=""
	} Else {
		Set i%%Location=initval
	}
	If initval="" {
		Set initval=$get(^%SYS("TempDir",$namespace))
		If initval="" Set initval=$get($$$SYSTempDir)
		Set i%MakePermLoc=1
	} Else {
		Set i%MakePermLoc=0
	}
	Set i%NormalizedDirectory=$S(initval="":"",1:##class(%File).NormalizeDirectory(initval))
	Quit $$$OK
}

Method %LoadData(id As %String) As %Status [ Private ]
{
	#; intialize member variables
	Set i%AtEnd=0,filename=id
	#; If the id contains the full path use this
	If $select($$$isVMS:id["[",1:id["/"||(id["\")) {
		Set dir=##class(%File).GetDirectory(id),filename=##class(%File).GetFilename(id)
	} ElseIf i%%Location="" {
		Set i%Mode=$$$modeREADNODATA
		Set dir=$get(^%SYS("StreamLocation",$namespace))
		If dir="" Set dir=$get(^%SYS("TempDir",$namespace))
		If dir="" Set dir=$get($$$SYSTempDir)
		If dir'="" Set i%MakePermLoc=0
	} Else {
		Set dir=i%%Location
	}
	Set i%NormalizedDirectory=$S(dir="":"",1:##class(%File).NormalizeDirectory(dir))
	
	If id=""||($$$FileExists(i%NormalizedDirectory_filename)=0) {
		#; No file stored so it is a null stream
		Set i%Mode=$$$modeREADNODATA,i%AtEnd=1,i%TempFile=filename
	} Else {
		#; Else the file really exists so link to it
		Set i%Mode=$$$modeREADNOTCHANGED,i%AtEnd=($$$FileSize(i%NormalizedDirectory_filename)=0),i%TempFile=""
	}
	Set ..Id=id
	Quit $$$OK
}

Method %OnClose() As %Status [ Private ]
{
	If i%CurrFile'="" Close i%CurrFile
	If (i%Mode=$$$modeREADCHANGED)||(i%Mode=$$$modeWRITE) If '$$$FileDelete(i%NormalizedDirectory_i%TempFile) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%TempFile)
	If i%RemoveOnClose,i%StoreFile'="" If '$$$FileDelete(i%NormalizedDirectory_i%StoreFile) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%StoreFile)
	Quit $$$OK
}

Method Rewind() As %Status
{
	If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	Set i%AtEnd=$select(i%Mode=$$$modeREADNODATA:1,1:0)
	Set i%Mode=$case(i%Mode,$$$modeWRITEJUSTSAVED:$$$modeREADNOTCHANGED,$$$modeWRITE:$$$modeREADCHANGED,:i%Mode)
	Quit $$$OK
}

Method Flush() As %Status
{
	#; Empty and internal buffer to disk and reopen at end
	If i%Mode'=$$$modeWRITE Quit $$$OK
	Do ..Rewind(),..MoveToEnd()
	Quit $$$OK
}

/// Return the current size of the data stream. 
Method SizeGet() As %Integer [ CodeMode = expression ]
{
..FileBinarySize()
}

/// Return the current size of the file in bytes.
Method FileBinarySize() As %Integer
{
	If (i%Mode=$$$modeWRITE) && (i%CurrFile'="") {
		Try {
			Set io=$io
			Use i%CurrFile
			Write *-1
			Set size=$select($$$isVMS:$zpos,1:$$$FileSize(i%CurrFile))
		} Catch {
			#; If we get an error someone else closed the file, so report the file size and reset our state
			Set size=$$$FileSize(i%CurrFile)
			Set i%CurrFile="",i%Mode=$$$modeREADCHANGED
		}
		Use io
		Quit size
	}
	Quit $select(i%Mode=$$$modeREADCHANGED||(i%Mode=$$$modeWRITE):$$$FileSize(i%NormalizedDirectory_i%TempFile),i%Mode=$$$modeREADNOTCHANGED||(i%Mode=$$$modeWRITEJUSTSAVED):$$$FileSize(i%NormalizedDirectory_i%StoreFile),1:0)
}

/// This method lets you connect a file stream to a file called <var>filename</var> without
/// making a copy of it. If the file does not already exist it will still allow you to link
/// to this file, and %IsNull() will return true until you write to this file.
/// <EXAMPLE>
/// Do object.Image.LinkToFile("\temp\image.jpg")
/// Do object.%Save()
/// </EXAMPLE>
/// The method as its name suggests creates a LINK to an EXISTING 
/// file. So this is a 'shared public' file, as it can be shared by 
/// several instances of a class, or even several classes. 
/// Using the <method>CopyFrom</method> method, on the contrary, creates a 
/// 'private' image, not sharable by other instances/classes, so 
/// these two methods are really different.<p>
/// The problems with shared public images are that several instances 
/// are all allowed to update and even delete the image, causing 
/// problems for other instances.<p>
/// For example, if dog #2 has image 'test.gif', I can also 
/// assign that image to dog #5 or even person #24 
/// If I change the image for dog #5, then the image is changed in 
/// place to another image, thus upsetting dog#2 and person#24. 
/// If I delete dog#5, the image is also deleted and thus dog#2 
/// and person#24 are changed.<p>
/// Also note that if there is currently some temporary data in the old stream when the
/// <method>LinkToFile</method> is called this temporary data will be removed before the
/// stream is linked to this filename.
Method LinkToFile(filename As %String) As %Status
{
	If filename="" Quit $$$ERROR($$$FileNameInvalid,filename)
	#; Do not allow two objects to open the same file
	Set filename=$$$FileNormalizeFilename(filename)
	If ","_$translate($piece($View(-1,$job),"^",3),"*")_","[(","_$zutil(12,filename)_",") Quit $$$ERROR($$$FileAlreadyOpen,filename)
	If $$$isVMS,filename["::" {
		Set directory=""
	} Else {
		Set directory=##class(%File).GetDirectory(filename,1)
	}
	Set fileexists=$$$FileExists(filename)
	If fileexists Set atend=($$$FileSize(filename)=0)
	If 'fileexists,'##class(%File).DirectoryExists(directory) {
		Quit $$$ERROR($$$DirectoryNameInvalid,directory)
	}
	If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	
	#; Mode = $$$modeREADCHANGED or $$$modeWRITE: Delete new data
	If (i%Mode=$$$modeREADCHANGED)||(i%Mode=$$$modeWRITE) {
		If '$$$FileDelete(i%NormalizedDirectory_i%TempFile) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%TempFile)
	}
	
	Set i%MakePermLoc=0,i%NormalizedDirectory=directory
	#; If linking to a file in expected location just store filename part in %Id, else store full path in id
	If directory=##class(%File).NormalizeDirectory(i%%Location) {
		Set filename=##class(%File).GetFilename(filename)
	}
	#; If the file does not exist then this is the name of the new file we will create
	If fileexists=0 {
		Set i%Mode=$$$modeREADNODATA,i%AtEnd=1,..Id=filename,i%TempFile=i%StoreFile
	} Else {
		#; Else the stored file is of this name
		Set i%Mode=$$$modeREADNOTCHANGED,..Id=filename,i%TempFile="",i%AtEnd=atend
	}
	Quit $$$OK
}

Method %SaveData(ByRef sid As %String) As %Status [ Private ]
{
	#; If they save it then we should cancel any remove on close they have defined.
	Set i%RemoveOnClose=0
	If i%Mode=$$$modeREADNODATA||(i%Mode=$$$modeREADNOTCHANGED)||(i%Mode=$$$modeWRITEJUSTSAVED) Quit $$$OK
	
	#; close file (if open), go to read mode
	If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	If i%MakePermLoc,i%Id="" {
		Set dir=$get(^%SYS("StreamLocation",$namespace),i%NormalizedDirectory)
		#; Rename so that stored filename remains constant
		If dir'=i%NormalizedDirectory {
			If '$$$FileRename(i%NormalizedDirectory_i%TempFile,dir_i%TempFile) {
				If '$$$FileCopy(i%NormalizedDirectory_i%TempFile,dir_i%TempFile) Quit $$$ERROR($$$FileCanNotRename,i%NormalizedDirectory_i%TempFile)
				If '$$$FileDelete(i%NormalizedDirectory_i%TempFile) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%TempFile)
			}
			Set i%NormalizedDirectory=dir,i%MakePermLoc=0
		}
		Set ..Id=i%TempFile,i%TempFile=""
	} ElseIf i%Id'="" {
		If i%StoreFile'=i%TempFile {
			If ('$$$isVMS)||('i%UseVMSVersion) {
				If $$$FileReadOnly(i%NormalizedDirectory_i%StoreFile)||('$$$FileDelete(i%NormalizedDirectory_i%StoreFile)),$$$FileExists(i%NormalizedDirectory_i%StoreFile) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%StoreFile)
			}
			#; Rename so that stored filename remains constant
			If '$$$FileRename(i%NormalizedDirectory_i%TempFile,i%NormalizedDirectory_i%StoreFile) {
				If '$$$FileCopy(i%NormalizedDirectory_i%TempFile,i%NormalizedDirectory_i%StoreFile) Quit $$$ERROR($$$FileCanNotRename,i%NormalizedDirectory_i%TempFile)
				If '$$$FileDelete(i%NormalizedDirectory_i%TempFile) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%TempFile)
			}
		}
	} Else {
		Set ..Id=i%TempFile,i%TempFile=""
	}
	If i%Mode=$$$modeWRITE { Set i%Mode=$$$modeWRITEJUSTSAVED } Else { Set i%Mode=$$$modeREADNOTCHANGED }
	Set sid = i%Id
	Quit $$$OK
}

ClassMethod %DeleteData(streamvalue As %String, concurrency As %Integer) As %Status [ Private ]
{
	Set node = $$$oidPrimary(streamvalue) Quit:(node="") $$$OK
	If '$select($$$isVMS:node["[",1:node["/"||(node["\")) {
		Set root=$$$oidSysAd1(streamvalue)
		If $ascii(root)=0 Set root=$extract(root,2,*),root=$list(root)
		If root="" Set root=$get(^%SYS("StreamLocation",$namespace))
		If root="" Set root=$get(^%SYS("TempDir",$namespace),$get($$$SYSTempDir))
		Set root=$S(root="":"",1:##class(%File).NormalizeDirectory(root))
		Set node=root_node
	}
	If '$$$FileExists(node) Quit $$$OK
	If $$$FileReadOnly(node)||($$$FileDelete(node)=0) Quit $$$ERROR($$$FileCanNotDelete,node)
	Quit $$$OK
}

ClassMethod NewFileName(ext As %String = "", directory As %String = "") As %String
{
	Set ext=$piece($translate(ext,"[]\","///"),"/",*)
	If ext="" Set ext=..#FILEEXT
	Quit $translate($zstrip($SYSTEM.Encryption.Base64Encode($system.Encryption.GenCryptRand(10)),">","="), "+/", "ab")_"."_ext
}

Method Read(ByRef len As %Integer = 32000, ByRef sc As %Status) As %CacheString
{
	Set sc=$$$OK,ze=$zerror
	If i%Mode=$$$modeWRITEJUSTSAVED Set i%Mode=$$$modeREADNOTCHANGED
	#; test if we've already read to the end, or there is no data
	If i%AtEnd=1||(i%Mode=$$$modeREADNODATA),i%Mode'=$$$modeWRITE Set len=-1,i%AtEnd=1 Quit ""
	
	Set:len>$$$MaxLocalLength len=$$$MaxLocalLength
	
	Set io=$io,out=""
	#; test for end of file
	Set $ZTRAP="ReadError"
	
	#; This will switch to this device and set it up for us
	If i%Mode=$$$modeWRITE Do ..Rewind()
	If (i%ReadMode'=$$$modeREADNORMAL)||(i%CurrFile="") {
		Set sc=..SetupRead($$$modeREADNORMAL) If $$$ISERR(sc) Use io Set $zerror=ze Quit ""
	}
	Use i%CurrFile
	If i%VariableRecord {
		Set need=len,node=""
		While need'=0 {
			Set node=$order(i%Buffer(node),1,buffer)
			If node="" {
				Read buffer If $ZEOF Set $ZE="<ENDOFFILE>" Goto ReadError
				If $length(buffer)<32700 {
					Set buffer=buffer_$char(13,10),i%Buffer(1)=buffer
				} Else {
					Set i%Buffer(1)=buffer,i%Buffer(2)=$char(13,10)
				}
				Set node=1
			}
			Set out=out_$extract(buffer,1,need)
			If need'<$length(buffer) {
				Kill i%Buffer(node)
				Set need=need-$length(buffer)
			} Else {
				Set i%Buffer(node)=$extract(buffer,need+1,*),need=0
			}
		}
	} Else {
		Read:len out#len If $zeof Set $ZE="<ENDOFFILE>" Goto ReadError
	}

	#; If we read less than requested either we are at the end, or we have a surrogate pair
	#; On VMS try to read the surrogate as no other way to see if we are at the end
	If $$$isVMS {
		If $length(out)<len {
			Read tmp#2
			If $ZEOF Set $ZE="<ENDOFFILE>" Goto ReadError
			#; The surrogate pair is kind of one character so just append it to the data read so far
			Set out=out_tmp
		}
	} Else {
		If $zseek()=i%ReadSize Close i%CurrFile Set i%CurrFile="",i%AtEnd=1
	}
	Use io
	Set len=$length(out),$zerror=ze
	Quit out
	
ReadError Set $ZTRAP=""
	Use io
	#; if error (not EOF) close file
	If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	If $E($ze,1,11)'="<ENDOFFILE>" Set sc=$$$ERROR($$$CacheError,$zerror)
	Set i%AtEnd=1,$zerror=ze
	Set len=$S($L(out)=0:-1,1:$L(out))
	Quit out
}

Method SetupRead(newMode As %Integer) As %Status [ Private ]
{
	#; Mode $$$modeWRITE: in middle of Write with no rewind; rewind
	If i%Mode=$$$modeWRITE Do ..Rewind()
	
	#; read data from file; return 0 if no more data
	Set pos=0,fileexists=1,io=$io
	Set $ZTRAP="SetupReadError"
	
	#; If we are changing read mode, then make a note of the position and force
	#; it to reopen the file by setting i%CurrFile=""
	If i%ReadMode'=newMode,i%CurrFile'="" {
		If $zversion(1)'=1 Use i%CurrFile Set pos=$ZSEEK() Use io
		Close i%CurrFile Set i%CurrFile=""
	}
	
	#; is the first time we are reading?
	#; if not changed, read from old file; else read from temp file
	If i%CurrFile="" {
		Set filename=i%NormalizedDirectory_$select(i%Mode=$$$modeREADNOTCHANGED:i%StoreFile,1:i%TempFile)
		#; Do not allow two objects to open the same file
		If ","_$translate($piece($View(-1,$job),"^",3),"*")_","[(","_$ZU(12,filename)_",") Set len=-1,i%AtEnd=1 Quit $$$ERROR($$$FileAlreadyOpen,filename)
		Set parm=..GetReadOpenParameter(filename,newMode,.pos)
		Open filename:(parm::i%LineTerminator:/NOXY=1:/GZIP=..#GZIP):0 Else  Set i%ReadSize=-1,i%AtEnd=1 Quit $$$ERROR($$$FileDoesNotExist,filename)
		Use io
		#; firsttime, force position to start or where we left off if doing ReadLine()
		If pos Use filename:pos
		Set i%ReadMode=newMode,i%ReadSize=$zutil(140,1,filename),i%CurrFile=filename
	}
	
	Quit $$$OK

SetupReadError	Set $ZTRAP="" Use io
	Set len=-1,i%AtEnd=1 
	Quit $$$ERROR($$$CacheError,$zerror)
}

Method Write(data As %CacheString = "") As %Status
{
	#; Mode '= $$$modeWRITE; clear TempFile; prepare for write
	If i%Mode=$$$modeWRITEJUSTSAVED {
		Set sc=..MoveToEnd() If $$$ISERR(sc) Quit sc
	} ElseIf i%Mode'=$$$modeWRITE {
		#; Mode = READNODATA or $$$modeREADNOTCHANGED: set up for write: create new file
		If (i%Mode=$$$modeREADNODATA)||(i%Mode=$$$modeREADNOTCHANGED) Set:i%TempFile="" i%TempFile=..NewFileName($select(i%StoreFile[".":$piece(i%StoreFile,".",*),1:""),i%NormalizedDirectory)
		If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
		Set i%Mode=$$$modeWRITE
	}
	
	#; write is never at the end
	Set i%AtEnd=0,sc=$$$OK
	
	#; Open the file if this is the first time;
	If i%CurrFile="" {
		#; Do not allow two objects to open the same file
		If ","_$translate($piece($View(-1,$job),"^",3),"*")_","[(","_$ZU(12,i%NormalizedDirectory_i%TempFile)_",") Quit $$$ERROR($$$FileAlreadyOpen,i%NormalizedDirectory_i%TempFile)
		Set parm=..GetWriteOpenParameter(i%NormalizedDirectory_i%TempFile,$$$modeWRITENORMAL)
		Set i%CurrFile=i%NormalizedDirectory_i%TempFile
		Open i%CurrFile:(parm:::/OBUFSIZE=32768:/NOXY=1:/GZIP=..#GZIP):0 Else  Set i%CurrFile="" Quit $$$ERROR($$$FileCanNotOpen,i%NormalizedDirectory_i%TempFile)
	}
	
	#; write data to file
	Try {
		Set io=$io
		Use i%CurrFile
		#; On VMS it does not like writes of over 35216 and silently truncates the write at this size 
		If $$$isVMS {
			For i=1:32000:$length(data) {
				Write $extract(data,i,i+32000-1)
			}
		} Else {
			Write data
		}
		Use io
	} Catch {
		Use io
		Close:i%CurrFile'="" i%CurrFile
		Set sc=$$$ERROR($$$CacheError,$zerror),i%CurrFile=""
	}
	Quit sc
}

/// Appends the string <var>data</var> along with a line terminator to the stream and advances the 
/// current stream position by the number of characters in <var>data</var> plus the line terminator.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method WriteLine(data As %CacheString = "") As %Status
{
	If $length(data)+$length(i%LineTerminator)>$$$MaxLocalLength {
		Set sc=..Write(data)
		If $$$ISOK(sc) Set sc=..Write(i%LineTerminator)
	} Else {
		Set sc=..Write(data_i%LineTerminator)
	}
	Quit sc
}

Method MoveToEnd() As %Status
{
	#; If no data or in write mode already nothing to do
	If (i%Mode=$$$modeREADNODATA)||(i%Mode=$$$modeWRITE) Quit $$$OK
	
	If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	#; Need to copy file
	If i%Mode=$$$modeREADNOTCHANGED||(i%Mode=$$$modeWRITEJUSTSAVED) {
		Set:i%TempFile="" i%TempFile=..NewFileName($select(i%StoreFile[".":$piece(i%StoreFile,".",*),1:""),i%NormalizedDirectory)
		If '$$$FileCopy(i%NormalizedDirectory_i%StoreFile,i%NormalizedDirectory_i%TempFile) Quit $$$ERROR($$$FileCanNotCopy,i%NormalizedDirectory_i%StoreFile,i%NormalizedDirectory_i%TempFile)
	}
	
	#; reopen file in append mode
	If i%TempFile'="" {
		Set filename=i%NormalizedDirectory_i%TempFile
		Set parm=..GetWriteOpenParameter(filename,$$$modeWRITEAPPEND)
		Open filename:(parm:::/OBUFSIZE=32768:/NOXY=1:/GZIP=..#GZIP):0 Else  Quit $$$ERROR($$$FileCanNotOpen,filename)
		Set i%CurrFile=filename
	}
	
	#; a write is never at the end
	Set i%Mode=$$$modeWRITE,i%AtEnd=0
	Quit $$$OK
}

Method CopyFrom(source As %AbstractStream) As %Status
{
	Quit:source=$$$NULLOREF $$$ERROR($$$OrefInvalid,"")
	If $classname(source)'=$classname() Quit ##super(source)
	If ..%Extends("%Stream.FileCharacter"),$this.TranslateTable'=source.TranslateTable Quit ##super(source)
	
	Set sc=$$$OK
	
	#; Optimise for copy from one file to another
	If i%Mode=$$$modeWRITEJUSTSAVED Do ..MoveToEnd()
	#; Make sure all the data is accessible, also comes out of WRITE mode into READCHANGED
	Do source.Rewind()
	Set sourceFile=$S(source.Mode=$$$modeREADNODATA:"",source.Mode=$$$modeREADCHANGED:source.NormalizedDirectory_source.TempFile,source.Mode=$$$modeREADNOTCHANGED||(source.Mode=$$$modeWRITEJUSTSAVED):source.NormalizedDirectory_source.StoreFile)
	
	#; If this is replacing the old data we can use a copy
	If i%Mode'=$$$modeWRITE Do
	. If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	. If i%TempFile="" Do
	. . Set i%TempFile=..NewFileName($select(sourceFile[".":$piece(sourceFile,".",*),1:""),i%NormalizedDirectory)
	. Else  Do
	    #; delete old stream location, not really needed but is a good idea
	. . If $$$FileExists(i%NormalizedDirectory_i%TempFile),'$$$FileDelete(i%NormalizedDirectory_i%TempFile) Set sc=$$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%TempFile)
	. If $$$ISERR(sc) Quit
	
	  #; Copy the data and setup the properties and make sure we are at the end in case we need to append more data
	. If sourceFile'="" Do
	. . If '$$$FileCopy(sourceFile,i%NormalizedDirectory_i%TempFile) Set sc=$$$ERROR($$$FileCanNotCopy,sourceFile,i%NormalizedDirectory_i%TempFile) Quit
	. . Set i%Mode=$$$modeREADCHANGED,i%CurrFile=i%NormalizedDirectory_i%TempFile
	    #; On Windows if the new file has the read only bit set then unset it
	. . If $$$isWINDOWS,$zu(140,7,i%CurrFile)#2 Do ##class(%File).SetWriteable(i%CurrFile,0)
	. . Do ..MoveToEnd()

	#; Else we can copy the data as fast as we can
	Else  If sourceFile'="" Do
	. Set io=$IO
	. Use i%CurrFile Set table=$$$GETIO
	. Open sourceFile:(..#OPENREAD_"K\"_table_"\":/NOXY=1:/OBUFSIZE=32768:/GZIP=..#GZIP):0 Else  Use io Quit
	. Set $ZTrap="EndCopyRead",eofmode=$ZU(68,40) Do $ZU(68,40,0)
	. For  Use sourceFile Read data#32000 Use i%CurrFile Write data
EndCopyRead	. Set $ZTrap="" Do $ZU(68,40,eofmode)
	. Close sourceFile Use io
	. If $E($ze,1,11)'="<ENDOFFILE>" Set sc=$$$ERROR($$$CacheError,$ze)
	
	Quit sc
}

Method OutputToDevice(ByRef len As %Integer = -1) As %Status
{
	Set $ZTrap="OutputError"
	If i%Mode=$$$modeREADNODATA Set len=-1,i%AtEnd=1 Quit $$$OK
	If len=0 Quit $$$OK
	Set io=$io,sc=$$$OK,eofmode=$ZU(68,40),sc=$$$OK
	Do $ZU(68,40,0)
	
	If len=-1 Do
	#; Note that Rewind turns off WRITE mode so we do not need to test for this, and it closes the file
	#; and sets i%CurrFile=""
	. Do ..Rewind()
	
	. Set pos=0
	. Set filename=i%NormalizedDirectory_$S(i%Mode=$$$modeREADNOTCHANGED||(i%Mode=$$$modeWRITEJUSTSAVED):i%StoreFile,1:i%TempFile)
	. Set parm=..GetReadOpenParameter(filename,..#OPENREAD,.pos)
	. Open filename:(parm:/NOXY=1:/GZIP=..#GZIP):0 Else  Set sc=$$$ERROR($$$FileCanNotOpen,filename) Quit
	. Set i%CurrFile=filename
	  #; Force position to start of file to be safe
	. Use filename:pos
	
	. Set $ZTrap="EndOutputRead"
	. Set len=0
	. For  Use i%CurrFile Read data#32000 Use io Write data Set len=len+$length(data)
EndOutputRead	. Set $ZTrap=""
	. If $E($ze,1,11)'="<ENDOFFILE>" Set sc=$$$ERROR($$$CacheError,$ze) Quit
	. Do ..Rewind()
	
	#; Else we continue outputting from where we left off
	Else  Do
	. If i%AtEnd=1 Set len=-1 Quit
	
	. Set $ZTRAP="EndOutput2Read"
	
	  #; This will switch to this device and set it up for us
	. If i%Mode=$$$modeWRITE||(i%Mode=$$$modeWRITEJUSTSAVED) Do ..Rewind()
	. If (i%ReadMode'=$$$modeREADNORMAL)||(i%CurrFile="") Set sc=..SetupRead($$$modeREADNORMAL) If $$$ISERR(sc) Quit
	
	. Set written=0
	. For  Quit:written=len  Use i%CurrFile Read data#$S(len-written<32000:len-written,1:32000) Use io Write data Set written=written+$L(data)
	. If $zversion(1)'=1 Use i%CurrFile Set:$zseek()=i%ReadSize i%AtEnd=1 Use io 
	. Set len=written
	. Quit

EndOutput2Read	. Set $ZTRAP=""
	#; if error (not EOF) close file
	. If $E($ze,1,11)'="<ENDOFFILE>" Close i%CurrFile Set i%CurrFile="",i%AtEnd=1,len=-1,sc=$$$ERROR($$$CacheError,$ze) Quit
	. Set i%AtEnd=1
	. Set len=written
	
	Use io
	Do $ZU(68,40,eofmode)
	Quit sc
OutputError	Do:$G(eofmode)'="" $ZU(68,40,eofmode) Quit $$$ERROR($$$CacheError,$ZE)
}

Method Clear(permanent As %Boolean = 1) As %Status
{
	If i%Mode=$$$modeREADNODATA Quit $$$OK
	
	#; close file if open
	If i%CurrFile'="" Close i%CurrFile Set i%CurrFile=""
	
	#; Mode = $$$modeREADCHANGED or $$$modeWRITE: Delete new data
	If (i%Mode=$$$modeREADCHANGED)||(i%Mode=$$$modeWRITE) {
		If i%TempFile'="" If $$$FileReadOnly(i%NormalizedDirectory_i%TempFile)||($$$FileDelete(i%NormalizedDirectory_i%TempFile)=0) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%TempFile)
	}
	If permanent {
		#; File not deleted, assume read only
		If i%StoreFile'="" {
			If $$$FileReadOnly(i%NormalizedDirectory_i%StoreFile)||($$$FileDelete(i%NormalizedDirectory_i%StoreFile)=0) Quit $$$ERROR($$$FileCanNotDelete,i%NormalizedDirectory_i%StoreFile)
			#; If we can reuse the old name do so
			Set i%TempFile=i%StoreFile
		}
		Set i%Mode=$$$modeREADNODATA,i%AtEnd=1
	} Else {
		Set i%Mode=$$$modeREADNOTCHANGED,i%AtEnd=1
	}
	Quit $$$OK
}

Method LastModifiedGet() As %TimeStamp
{
	Set timestamp=$$$FileDateModified(i%NormalizedDirectory_$S(i%Mode=$$$modeREADCHANGED||(i%Mode=$$$modeWRITE):i%TempFile,1:i%StoreFile))
	Quit $select(timestamp<1:"",1:$zdt(timestamp,3))
}

Method GetReadOpenParameter(filename As %String, mode As %Integer, ByRef pos As %Integer) As %String [ Private ]
{
	Set i%VariableRecord=0 Kill i%Buffer
	If $$$isVMS,$zutil(140,7,filename,1)="VAR" Set i%VariableRecord=1 Quit "RK\RAW\"
	Quit $select(mode=$$$modeREADLINE:..#OPENREADTERM,1:..#OPENREAD)
}

Method GetWriteOpenParameter(filename As %String, mode As %Integer) As %String [ CodeMode = expression, Private ]
{
$select(mode=$$$modeWRITEAPPEND:..#OPENAPPEND,1:..#OPENWRITE)
}

/// Read a line from the line. Note that besides the normal ReadLine arguments this can also be passed a <var>term</var> which
/// will return the termintor that completed the line if we read in a whole line.
Method ReadLine(ByRef len As %Integer = 32000, ByRef sc As %Status, ByRef eol As %Boolean, ByRef term As %String) As %CacheString
{
	Set sc=$$$OK,eol=0,term=""
	#; test if we've already read to the end, or there is no data
	If i%AtEnd=1||(i%Mode=$$$modeREADNODATA) Set len=-1 Quit ""
	
	Set:len>$$$MaxLocalLength len=$$$MaxLocalLength
	
	Set out="",io=$io
	
	#; test for end of file
	Set $ZTRAP="ReadLineError"
	
	#; This will switch to this device and set it up for us
	If i%Mode=$$$modeWRITE||(i%Mode=$$$modeWRITEJUSTSAVED) Do ..Rewind()
	If (i%ReadMode'=$$$modeREADLINE)||(i%CurrFile="") {
		Set sc=..SetupRead($$$modeREADLINE)  If $$$ISERR(sc) Quit ""
	}
	Use i%CurrFile
	If i%VariableRecord {
		Set need=len,node=""
		If '$data(i%Buffer,buffer) {
			Read buffer If $ZEOF Set $ZE="<ENDOFFILE>" Goto ReadLineError
			Set i%Buffer=buffer
		}
		Set out=out_$extract(buffer,1,need)
		If need'<$length(buffer) {
			Kill i%Buffer
			Set eol=1
		} Else {
			Set i%Buffer=$extract(buffer,need+1,*)
		}
	} Else {
		Read out#len If $zb'="",i%LineTerminator[$extract($zb) Set eol=1,term=$zb
		If $ZEOF||('$$$isVMS&&($zseek()=i%ReadSize)) Set $ZE="<ENDOFFILE>" Goto ReadLineError
	}
	Use io
	Set len=$length(out)
	Quit out

ReadLineError	Set $ZTRAP=""
	Use io
	
	#; if error (not EOF) close file
	If $extract($zerror,1,11)'="<ENDOFFILE>" Close i%CurrFile Set i%CurrFile="",i%AtEnd=1,len=-1,sc=$$$ERROR($$$CacheError,$zerror) Quit ""
	
	#; if at end set AtEnd=1
	Set i%AtEnd=1
	
	#;if we are at the end with no data return -1
	Set len=$select($length(out)=0:-1,1:$length(out))
	Quit out
}

Method ReadLineIntoStream(ByRef sc As %Status) As %AbstractStream
{
	Set sc=$$$OK
	Set stream=..%New()
	#; test if we've already read to the end, or there is no data
	If i%AtEnd=1||(i%Mode=$$$modeREADNODATA) Quit stream
	
	Set out=""
	Set io=$io
	
	#; test for end of file
	Set $ZTRAP="ReadLineError"
	
	#; This will switch to this device and set it up for us
	If i%Mode=$$$modeWRITE||(i%Mode=$$$modeWRITEJUSTSAVED) Do ..Rewind()
	If (i%ReadMode'=$$$modeREADLINE)||(i%CurrFile="") {
		Set sc=..SetupRead($$$modeREADLINE) If $$$ISERR(sc) Use io Quit ""
	}
	Use i%CurrFile
	For  { 
		Read out:0 If $zb=i%LineTerminator Quit
		If $ZEOF||(($zversion(1)'=1)&&($zseek()=i%ReadSize)) Set $ZE="<ENDOFFILE>" Goto ReadLineError
		Do stream.Write(out)
	}
	Use io
	Do:out'="" stream.Write(out)
	
	Quit stream

ReadLineError	Set $ZTRAP=""
	Use io
	
	#; if error (not EOF) close file
	If $E($ze,1,11)'="<ENDOFFILE>" Close i%CurrFile Set i%CurrFile="",i%AtEnd=1,len=-1,sc=$$$ERROR($$$CacheError,$zerror) Quit ""
	
	#; if at end set AtEnd=1
	Set i%AtEnd=1
	Do:out'="" stream.Write(out)
	Quit stream
}

Method %NormalizeObject() As %Status [ CodeMode = expression ]
{
$$$OK
}

Method %ValidateObject(force As %Integer = 0) As %Status [ CodeMode = expression ]
{
$$$OK
}

ClassMethod %Exists(soid As %ObjectIdentity) As %Boolean
{
	Set root=$$$oidSysAd1(soid)
	If $ascii(root)=0 Set root=$extract(root,2,*),root=$list(root)
	Set root=$S(root="":$get(^%SYS("StreamLocation",$namespace)),1:##class(%File).NormalizeDirectory(root))
	Set node = $$$oidPrimary(soid) Quit:(node="") $$$OK
	Quit $$$FileExists(root_node)
}

Method %ObjectModified() As %Integer [ ServerOnly = 1 ]
{
	Quit $select(i%RemoveOnClose:1,1:$case(i%Mode,$$$modeREADNOTCHANGED:0,$$$modeREADNODATA:0,$$$modeWRITEJUSTSAVED:0,:1))
}

Method %IsModified() As %Integer
{
	Quit $select(i%RemoveOnClose:1,1:$case(i%Mode,$$$modeREADNOTCHANGED:0,$$$modeREADNODATA:0,$$$modeWRITEJUSTSAVED:0,:1))
}

ClassMethod %ObjectIsNull(soid As %ObjectIdentity) As %Boolean
{
	If soid=$$$NULLOID Quit 1
	If $isobject(soid)=1 Quit soid.%IsNull()
	Set class=$$$oidClassName(soid)
	If class'="" {
		Set class=$$$NormalizeClassname(class) If $classname()'=class Quit $classmethod(class,"%ObjectIsNull",soid)
	}
	Quit '..%Exists(soid)
}

}
