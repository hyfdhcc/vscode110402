/// The <CLASS>%Stream.Object</CLASS> class provides the basic mechanism by 
/// which stream objects are stored to and retrieved from a database. 
/// 
/// <p>A stream represents an arbitrary array of characters (or bytes) and 
/// a current position. The basic stream interface provides the ability to 
/// read data from a stream, write data to the stream, and rewind the 
/// current position to the beginning of the stream.
/// 
/// <p>Within <i>Cach&eacute;</i> streams are used to create large (greater than 32K)
/// object attributes.
Class %Stream.Object Extends %Library.RegisteredObject [ Abstract, ClassType = stream, MemberSuper = %Library.CacheStream, System = 2 ]
{

Parameter DEFAULTCONCURRENCY = "$zu(115,10)";

Property %Concurrency As %CacheString [ InitialExpression = {$zu(115,10)}, Private, Transient ];

/// The <var>AtEnd</var> property is set to true (1) when, during a read, 
/// a stream has reached the end of its data source.
Property AtEnd As %Boolean [ InitialExpression = 1 ];

/// <var>Id</var> is the unique identifier for a stream within the <var>%Location</var>.
Property Id As %String;

/// <var>LastModified</var> is a read-only property containing the <class>%TimeStamp</class> of
/// the last modification to this stream. If the stream is null then it will report "".
Property LastModified As %TimeStamp [ Calculated ];

/// <var>%Location</var> is place where stream data is stored. For global streams this will
/// be a global reference. For file streams it may be a directory. This is not the location
/// of this specific stream, but the root location of what may be multiple streams.
Property %Location As %String(MAXLEN = 1024);

Method %LocationSet(val As %String) As %Status
{
	Do ..Clear()
	Set i%%Location=val,i%Id=""
	Quit $$$OK
}

/// %Locked is an integer that indicates whether or not the object is currently locked.
Property %Locked As %Integer [ InitialExpression = 0, Internal, Private, Transient ];

/// %LockRef is the global reference used for locking this stream object. This value is generated by calling
/// %GetLockRef(<var>Location</var>,<var>Id</var>) where <var>Location</var> is the value of the
/// %Location property and <var>Id</var> is the value of the Id property.
/// If this value is null then no locks are taken out. All retained locks are
/// shared locks. Exclusive locks are acquired and released in %Save and in %Delete.
/// %LockRef must be set in order for any locking to occur. This property is not
/// set typically until the stream is locked.
Property %LockRef As %CacheString [ Internal, Private, Transient ];

/// <var>Size</var> is a read-only property containing the current size of the stream (in bytes 
/// for a binary stream and characters for a character stream).
/// 
/// <p>If a specific stream implementation cannot determine the size of the stream then 
/// <var>Size</var> will be equal to -1.<br>
/// VMS does not support moving to a position in a file or providing the current position in a file.
/// On VMS if a BOM is included at the start of the file it may be included in the size calculated.
Property Size As %Integer [ Calculated ];

/// Return true if this is a character stream and false if it is a binary stream.
ClassMethod IsCharacter() As %String [ CodeMode = generator ]
{
	Set %codemode=$$$cMETHCODEMODEEXPRESSION
	$$$comClassKeyGetLvar(odbctype,%class,$$$cCLASSodbctype)
	Set %code=(odbctype="LONGVARCHAR")
	If odbctype'="LONGVARCHAR",odbctype'="LONGVARBINARY" Quit $$$OK
	#; Set the correct returntype/argument type for Read/Write methods based on ODBCtype
	$$$comMemberKeySet(%class,$$$cCLASSmethod,"Read",$$$cMETHreturntype,$select(%code:"%Library.String",1:"%Library.Binary"))
	$$$comMemberKeySet(%class,$$$cCLASSmethod,"ReadLine",$$$cMETHreturntype,$select(%code:"%Library.String",1:"%Library.Binary"))
	Set sc=$$$OK
	For method="Write","WriteLine" {
		$$$comMemberKeyGetLvar(spec,%class,$$$cCLASSmethod,method,$$$cMETHformalspec)
		Set tmp=$find(spec,","),tmp2=$find(spec,"=")
		If tmp=0 { Set tmp=tmp2 }
		If tmp2<tmp { Set tmp=tmp2 }
		If tmp=0 Set tmp=32769
		Set val=$extract(spec,1,tmp-2)
		Set $piece(val,":",2)=$select(%code:"%Library.String",1:"%Library.Binary")
		Set $extract(spec,1,tmp-2)=val
		$$$comMemberKeySet(%class,$$$cCLASSmethod,method,$$$cMETHformalspec,spec)
		Set sc=$$serializeFormal^%occName($get($$$comMemberKeyRaw(%class,$$$cCLASSmethod,method,$$$cPROPorigin),%class),method,%class_"."_method,spec,.ppformalspec) Quit:$$$ISERR(sc)
		$$$comMemberKeySet(%class,$$$cCLASSmethod,method,$$$cMETHformalspecparsed,ppformalspec)
		$$$comMemberKeySet(%class,$$$cCLASSmethod,method,$$$cMETHuseractualtype,$$$normalize($$MethodUserActualtype^%occName(ppformalspec,%class)))
	}
	Quit sc
}

/// Returns the persistent object Id, if there is one, of this object. 
/// <p>Returns a null string if there is no object Id.
Method %Id() As %String
{
	Quit i%Id
}

/// Deletes the stored version of the object with OID <var>oid</var> from the database. 
/// It does not remove any in-memory versions of the object that may be present.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the optional <var>concurrency</var> argument.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
/// 
/// <p>Internally, <METHOD>%Delete</METHOD> initiates a transaction and then invokes the storage 
/// interface method <METHOD>%DeleteData</METHOD>. If <METHOD>%DeleteData</METHOD> succeeds, the 
/// transaction is committed, otherwise it is rolled back. 
ClassMethod %Delete(oid As %ObjectIdentity = "", concurrency As %Integer) As %Status [ Final ]
{
	Set $ztrap="%DeleteERR"
	Quit:oid="" $$$ERROR($$$NullOid,$classname()) Set id=$$$oidPrimary(oid) Quit:id="" $$$ERROR($$$NullId,$classname())
	If '$data(concurrency) Set concurrency=$select(..#DEFAULTCONCURRENCY="$zu(115,10)":$zu(115,10),1:$xecute("Quit "_..#DEFAULTCONCURRENCY))
	#; get class name
	Set class=$$$oidClassName(oid)
	If class="" {
		Set class=$classname(),oid=$$$oidInsertClassName(oid,class)
	} Else {
		Set class=$$$NormalizeClassname(class)
		If $classname()'=class Quit $classmethod(class,"%Delete",oid,concurrency)
	}
	#; If TP is turned on start a transaction...
	Set traninit=0 If $zu(115,9) Set traninit=1 TStart
	Set sc=..%OnDelete(oid) If $$$ISERR(sc) Goto %DeleteEnd
	Set sc=..%DeleteData(oid,concurrency)
	If $$$ISOK(sc) $$$ActiveOidModified(oid,oref)
%DeleteEnd	If $get(traninit) { If $$$ISOK(sc) { TCommit } Else { TRollback } }
	Quit sc
%DeleteERR	Set $ZTrap="",sc=$$$ERROR($$$CacheError,$zerror) Goto %DeleteEnd
}

/// Deletes the stored version of the object with ID <var>id</var> from the database. 
/// 
/// <p><METHOD>%DeleteId</METHOD> is identical in operation to the <METHOD>%Delete</METHOD> method except 
/// that it uses and Id value instead of an OID value to find an object.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the optional <var>concurrency</var> argument.
ClassMethod %DeleteId(id As %String, concurrency As %Integer) As %Status [ CodeMode = expression, Final ]
{
..%Delete($$$oidForm(id),.concurrency)
}

/// Loads an object from the database into memory and returns an OREF referring to the object. 
/// <var>oid</var> is the OID value of the object to load. If <var>oid</var> is a partially-formed OID, 
/// that is it does not include a class name, then <METHOD>%Open</METHOD> does the following: 
/// it assumes the class name is 
/// the same as the object class on which <METHOD>%Open</METHOD> was called.
/// <p>If a version of the specified object is already in memory, then <METHOD>%Open</METHOD> increments 
/// the object's reference count and returns the OREF value referring to this version.
/// <METHOD>%Open</METHOD> also an optional concurrency argument which specifies the concurrency setting 
/// for this object (and sets the value of the <var>%Concurrency</var> attribute). If the 
/// <var>concurrency</var> argument is omitted then the system default value (1: <i>Atomic</i>) is used.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the optional <var>concurrency</var> argument.
/// 
/// <p><METHOD>%Open</METHOD> returns an OREF value that refers to the in-memory object instance or 
/// a null reference ($$$NULLOREF) if it cannot find or otherwise load the object.
ClassMethod %Open(soid As %ObjectIdentity, concurrency As %Integer, ByRef sc As %Status = {$$$OK}) As %ObjectHandle [ Final ]
{
	If '$data(soid) Quit $$$NULLOREF
	#; If we pass in an oref just return it as it is obviously already open
	If $isobject(soid) Quit soid
	Set class=$$$oidClassName(soid)
	#; if class name is not present in soid, we must use this; class for the class name
	If class="" { Set class=$classname(),soid=$$$oidInsertClassName(soid,class) } Else { Set class=$$$NormalizeClassname(class) If $classname()'=class { Quit $classmethod(class,"%Open",soid,.concurrency,.sc) } }
	Set oref=$$$CreateObject(class) If oref=$$$NULLOREF Set sc = $$$ERROR($$$AbstractClassNotInstantiable,class) Quit oref
	Set sc=oref.%LoadInit(.concurrency,soid) If $$$ISERR(sc) Quit $$$NULLOREF
	#; load the object from disk
	Set sc=oref.%LoadData($$$oidPrimary(soid)) If $$$ISERR(sc) Quit $$$NULLOREF
	Do $system.CLS.SetModified(oref,0)
	#; find out if there is a %OnOpen method. If there is a %OnOpen, call it
	Set sc=oref.%OnOpen() If $$$ISERR(sc) Quit $$$NULLOREF
	Quit oref
}

Method %LoadInit(concurrency As %Integer, soid As %ObjectIdentity) As %Status [ CodeMode = generator, Final, Internal, Private ]
{
	$$$GENERATE("	Set i%%Concurrency=$get(concurrency,"_%parameter("DEFAULTCONCURRENCY")_")")
		#; initialize reference variables
	s ivar="",list=""
	s i=0 f  s ivar=$$$comMemberNext(%class,$$$cCLASSinstancevar,ivar) q:ivar=""  d
	. i $$$comMemberKeyGet(%class,$$$cCLASSproperty,ivar,$$$cPROPmultidimensional) q
	. $$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,ivar,$$$cPROPruntimetype)
	. i $$$classIsDataType(runtimetype) q
	. s list=list_",r%"_ivar_"=$$$NULLOREF",i=i+1
	. i i#5=0 $$$GENERATE("	Set "_$e(list,2,*)) s list=""
	i list'="" $$$GENERATE("	Set "_$e(list,2,*))
	$$$GENERATE("	Set loctmp=$$$oidSysAd1(soid)")
	$$$GENERATE("	If $ascii(loctmp)=0 { Set loctmp=$extract(loctmp,2,*),i%%Location=$list(loctmp),loctmp=$list(loctmp,2,9999) } Else { Set i%%Location=loctmp,loctmp="""" }")
	#; This code initializes all transient properties if the load was
	#; successful. Multidimensional properties are not initialized
	#; for embedded objects, create new ones
	s prop="" f  s prop=$$$comMemberNext(%class,$$$cCLASSproperty,prop) q:prop=""  d:prop'="%Concurrency"&&(prop'="%%OID")
	. i '$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPtransient) q
	. i $$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPmultidimensional) q
	. i $$$comMemberDefined(%class,$$$cCLASSinstancevar,prop) $$$GENERATE("	Set i%"_prop_"="_$$$comMemberKeyGet(%class,$$$cCLASSinstancevar,prop,$$$cIVARinitialexpression))
	$$$GENERATE("	For i=1:1:$listlength(loctmp) Set tmp=$list(loctmp,i) Set $property($this,$list(tmp))=$list(tmp,2)")
	$$$GENERATE("	Set i%""%%OID""=soid")
	$$$GENERATE("	Quit $$$OK")
	QUIT $$$OK
}

/// Loads an object from the database into memory and returns an OREF referring to the object. 
/// <var>id</var> is the Id (not a full OID) value of the object to load.
/// 
/// <p><METHOD>%OpenId</METHOD> is identical in operation to the <METHOD>%Open</METHOD> method except 
/// that it uses and Id value instead of an OID value to find an object instance.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the optional <var>concurrency</var> argument.
/// 
/// <p><METHOD>%OpenId</METHOD> returns an OREF value that refers to the in-memory object instance or 
/// a null reference ($$$NULLOREF) if it cannot find or otherwise load the object.
ClassMethod %OpenId(id As %String, concurrency As %Integer, ByRef sc As %Status = {$$$OK}) As %ObjectHandle [ CodeMode = expression, Final ]
{
$select($isobject(id):id,1:..%Open($$$oidForm(id),.concurrency,.sc))
}

/// Delete all instances of this class from its extent. On exit <var>instancecount</var> 
/// contains the original number of instances while <var>deletecount</var> contains 
/// the number of instances actually deleted.
/// 
/// <p>Internally, <METHOD>%DeleteExtent</METHOD> iterates over the set of instances in the 
/// collection and invokes the <METHOD>%Delete</METHOD> method.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the optional <var>concurrency</var> argument.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
ClassMethod %DeleteExtent(concurrency As %Integer, ByRef deletecount, ByRef instancecount) As %Status [ CodeMode = generator ]
{
	Set %code=0
	QUIT:'($$$getClassType(%class)=$$$cCLASSCLASSTYPESTREAM) $$$OK
	#; If the ExtentExecute method doesn't exist then don't generate anything
	QUIT:'$$$comSubMemberDefined(%class,$$$cCLASSquery,"Extent",$$$cQUERYmethod,"Execute") $$$OK
	#; Generate the method...
	$$$GENERATE("	Set concurrency=$g(concurrency,"_%parameter("DEFAULTCONCURRENCY")_")")
	$$$GENERATE("	Set deletecount=0,instancecount=0")
	$$$GENERATE("	Set sc=..ExtentExecute(.qh) Quit:$$$ISERR(sc) sc")
	$$$GENERATE("	For  Set sc=..ExtentFetch(.qh,.row,.atend) Quit:$select(row="""":1,$$$ISERR(sc):1,1:0)  Set id=$listget(row) If id'="""" Set sc=..%Delete($listbuild(id),concurrency) Set instancecount=instancecount+1 Set:$$$ISOK(sc) deletecount=deletecount+1 Quit:atend")
	$$$GENERATE("	Do ..ExtentClose(qh)")
	$$$GENERATE("	Quit $$$OK")
	QUIT $$$OK
}

/*
 %DowngradeConcurrency()
 lowers the concurrency level of an object
*/
/// Changes the concurrency level of an instance in memory to a lower level 
/// by changing the lock type specified in the <METHOD>%Open</METHOD> method for the object's 
/// instance. Fails if it cannot lower the concurrency level.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the <var>concurrency</var> argument.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %DowngradeConcurrency(concurrency) As %Status [ Final, Internal ]
{
	Set current=..%Concurrency
	#; If the requested setting is greater than the current setting, then do nothing
	If concurrency'<current Quit $$$OK
	#; Locks are not retained for any setting less than 3 and if the old and new
	#; setting are the same, nothing is to done except update the concurrency setting
	If current<3 Set modstate=$system.CLS.GetModifiedBits(),..%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate) Quit $$$OK
	#; Get the new lock if needed
	If concurrency>2 Set sc=..%AcquireLock($select(concurrency=3:"s",1:"e")) Quit:$$$ISERR(sc) sc
	#; the following line releases the old lock which we know must be there
	#; because we process and quit above for current<3
	Do ..%ReleaseLock($select(current=3:"s",1:"e"))
	#; Update the concurrency setting:
	Set modstate=$system.CLS.GetModifiedBits(),..%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate)
	Quit $$$OK
}

/// <METHOD>%GetSwizzleObject</METHOD> is used to obtain a state of the object that can 
/// later be used to restore the object. In the case of a persistent object, it returns the OID.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %GetSwizzleObject(force As %Integer = 0, ByRef oid As %ObjectIdentity) As %Status [ Final ]
{
	Set oid="" If force=0 Set oid=(..%Oid()) Quit $$$OK
	If force=2 Set sc=..%Save(1) Set:$$$ISOK(sc) oid=(..%Oid()) Quit sc
	Set oid=(..%Oid()) Quit:oid'="" $$$OK
	Set sc=..%Save(0) Set:$$$ISOK(sc) oid=..%Oid()
	Quit sc
}

/// %LockStream()
/// 	Obtain a shared lock on the current stream object. %Locked is set to 1 if the stream was successfully locked. If the stream
/// 	cannot be locked then %Locked is set to 0. No lock is attempted unless %GetLockReference returns a non-null value. If a lock
/// 		is attempted but cannot be acquired (lock timeout expires) then this method will throw an exception. The caller is expected
/// 		to catch the exception and process it appropriately.
/// 
/// Throws %Exception.AbstractException, most often a StatusException.
Method %LockStream() [ ProcedureBlock = 1, ServerOnly = 1 ]
{
	if ('..%Locked) {
		try {
			set tLockRef = ..%GetLockReference(..%Location,..Id)
			if tLockRef '= "" {
				lock +@(tLockRef)#"S":$$$LockTimeout if $test { set ..%Locked = 1, ..%LockRef = tLockRef } else { throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$LockFailedToAcquireRead)) }
			}
		}
		catch tException {
			do ..%UnlockStream()
			throw tException
		}
	}
	quit
}

/// %UnlockStream()
/// 	Release the shared lock on the current stream object. If the immediate argument is 1 then
/// 	the lock is released using the "I" flag.
Method %UnlockStream(immediate As %Boolean = 0) [ ProcedureBlock = 1, ServerOnly = 1 ]
{
	if (..%Locked) && ( ..%LockRef '= "" ) {
		if 'immediate { lock -@(..%LockRef)#"S" }
		else { lock -@(..%LockRef)#"SI" }
		set ..%Locked = 0, ..%LockRef = ""
	}
}

/// Returns the global reference used to lock the current stream object
/// Throws %Exception.AbstractException
ClassMethod %GetLockReference(pLocation As %String(MAXLEN="") = "", pId As %String(MAXLEN="") = "") As %String(MAXLEN="") [ Private ]
{
	quit ""
}

/// Returns the OID of this object.
Method %Oid() As %ObjectIdentity
{
	Set id=..%Id()
	Quit $$$oidComposeAd1(id,$classname(),i%%Location)
}

/// Returns an full id value (including class name) with which the Stream implementation has stored 
/// the stream.
Method GetStreamId() As %String [ CodeMode = call ]
{
..%Oid()
}

/// %Reload is an instance method that re-reads an object from disk into the 
/// current instance. Calling %Reload is similar to calling <METHOD>%Close</METHOD> and then 
/// <METHOD>%Open</METHOD>, but it uses the same OREF.
/// 
/// <p>After %Reload is called, there are no swizzled references for the object, 
/// and <METHOD>%IsModified</METHOD> returns 0.
/// 
/// <p>%Reload performs the following steps. First, all swizzled objects for the 
/// instance are unswizzled. Then the object is reloaded from disk, using the 
/// <METHOD>%Id</METHOD> of the current object. Finally, the modified bit for each property is 
/// cleared.
Method %Reload() As %Status [ CodeMode = generator ]
{
	#; NOTE: A lot of this code is copied from %Open, if you change %Open you should change this also
	set %code=0
	$$$GENERATE("	If ..%Id()="""" Quit $$$ERROR($$$NullOid,$classname())")
	$$$GENERATE("	Do ..%OnClose()")
	$$$GENERATE("	Set cur=..%Concurrency,id=..%Id(),..%Concurrency=0")
	#; initialize reference variables
	s ivar="",list=""
	s i=0 f  s ivar=$$$comMemberNext(%class,$$$cCLASSinstancevar,ivar) q:ivar=""  d
	. i $$$comMemberKeyGet(%class,$$$cCLASSproperty,ivar,$$$cPROPmultidimensional) $$$GENERATE("	Kill i%"_$$$QN(ivar)) q
	. $$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,ivar,$$$cPROPruntimetype)
	. i $$$classIsDataType(runtimetype) q
	. s list=list_",r%"_$$$QN(ivar)_"=$$$NULLOREF",i=i+1
	. i i#5=0 $$$GENERATE("	Set "_$e(list,2,*)) s list=""
	i list'="" $$$GENERATE("	Set "_$e(list,2,*))
	$$$GENERATE("	Set ..%Concurrency=cur")
	$$$GENERATE("	Set sc=..%LoadData(id) If $$$ISERR(sc) Quit $$$NULLOREF")
	#; This code initializes all transient properties if the load was
	#; successful. Multidimensional properties are not initialized
	#; for embedded objects, create new ones
	s prop="" f  s prop=$$$comMemberNext(%class,$$$cCLASSproperty,prop) q:prop=""  d:prop'="%Concurrency"&&(prop'="%Location")&&(prop'="TranslateTable")
	. i '$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPtransient) q
	. i $$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPmultidimensional) q
	. i $$$comMemberDefined(%class,$$$cCLASSinstancevar,prop) $$$GENERATE("	Set i%"_$$$QN(prop)_"="_$$$comMemberKeyGet(%class,$$$cCLASSinstancevar,prop,$$$cIVARinitialexpression))
	. i $$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPcalculated) q
	. i '$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPcollection) $$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,prop,$$$cPROPruntimetype) i '$$$classIsSerial(runtimetype) q
	. $$$GENERATE("	If .."_$$$QN(prop_"NewObject")_"()=$$$NULLOREF Quit $$$ERROR($$$FailedToNewClass,"_$zu(144,1,%class_":"_prop)_")")
	$$$GENERATE($Char(9)_"if $system.CLS.IsMthd($this,""%OnReload"") Set sc=..%OnReload() If $$$ISERR(sc) quit sc")
	#; set object as not modified
	$$$GENERATE("	Do $system.CLS.SetModified(0)")
	$$$GENERATE(" Quit $$$OK")
	Quit $$$OK
}

/// This method is called by <METHOD>%Save</METHOD> when a transaction is rolled back. 
/// It will invoke a user-supplied <METHOD>%OnRollBack</METHOD> method if it exists.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %RollBack() As %Status
{
	If $data($$$txMODIFIED($this)) Do $system.CLS.SetModifiedBits($$$txMODIFIED($this))
	Quit ..%OnRollBack()
}

/// Stores an in-memory version of an object to disk. If the object was stored 
/// previously (and thus, already has an OID), <METHOD>%Save</METHOD> updates the on-disk version. 
/// Otherwise, <METHOD>%Save</METHOD> saves the object and generates a new OID for it.
/// 
/// <p>The <var>related</var> argument specifies how <METHOD>%Save</METHOD> handles references to other objects. 
/// It can take the following values:
/// <table cols=2>
/// <tr>
/// <td width="33%" valign="top">0: <i>Shallow Save</i></td>
/// <td valign="top">
/// If this object has been modified then save it. Only save related objects if they have never been saved (do not have an OID value) and must be 
/// saved in order to allocate the OID needed by this object.
/// </td>
/// </tr>
/// 
/// <tr>
/// <td width="33%" valign="top">1: <i>Deep Save</i></td>
/// <td valign="top">
/// Save this object and all "related" objects that have been edited. In this case, 
/// "related" means any in-memory objects it refers to, and any in-memory objects 
/// they in turn refer to, and so on. However, only objects that have been changed 
/// (<METHOD>%IsModified</METHOD> returns true) will actually be saved to the database, including 
/// the object upon which <METHOD>%Save</METHOD> was initially called.
/// </table>
/// </td>
/// </tr>
/// 
/// <p><METHOD>%Save</METHOD> automatically detects and handles circular references between objects. 
/// For example, <METHOD>%Save</METHOD> will detect if object A refers to object B and object B likewise refers to object A.
/// In this case it will avoid falling into an infinite, recursive loop.
/// 
/// <p>Note that either reference attribute, A to B or B to A, can be specified as being 
/// a required attribute but not both of them. If both reference attributes are required 
/// then <METHOD>%Save</METHOD> will fail.
/// 
/// <p>By default <METHOD>%Save</METHOD> automatically manages transactions. You can enable and disable 
/// automatic transaction support using the <code>$$SetTransactionMode^%apiOBJ()</code> routine.
/// 
/// <p>When <METHOD>%Save</METHOD> saves an object to the database, it initiates one transaction 
/// (by calling TSTART) for the entire set of saves, including the original object 
/// and any related objects. If the save operation is successful, <METHOD>%Save</METHOD> will issue a 
/// TCOMMIT command to commit the transaction and write the data to the database.
/// If <METHOD>%Save</METHOD> encounters a problem when saving the original object or any of its 
/// related objects, it rolls back the entire transaction and performs the following actions:
/// <ul>
/// <li>It issues a TROLLBACK command to rollback any changes to the database that may 
/// have occurred. (In the case of the <CLASS>%CacheStorage</CLASS> class, changes to the on-disk 
/// counter value, used to determine the next available object id number, are not rolled back.)
/// <li>It restores the in-memory state of all the objects involved in the transaction to 
/// their pre-transaction state. This includes restoring any modified flags, and 
/// restoring to null ("") any OID values that have been assigned during the course of 
/// the transaction. Additional property values changed during the course of the 
/// transaction are not restored, however.
/// <li>It calls the <METHOD>%RollBack</METHOD> method on each object involved with the transaction. 
/// The order in which the <METHOD>%RollBack</METHOD> methods are called is undefined. <METHOD>%RollBack</METHOD> will 
/// call a user-written <METHOD>%OnRollback</METHOD> method if it is present.
/// </ul>
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %Save(related As %Integer = 1) As %Status [ Final, GenerateAfter = (%OnBeforeSave, %OnAfterSave) ]
{
	Set $ZTrap="%SaveERR"
	#; Initialize the transaction state
	#; This method is a transaction itself and isn't called recursively. Therefore, the
	#; transaction state variable - %objTX - is new'ed here.
	New %objTX Set sc=$$$OK,traninit=0 If '$data(%objTX2) New %objTX2 Set %objTX2=1
	#; If already in %Save, just build a shallow graph and serialize the object
	If $get(%objTX2(+$this)) Set sc=..%BuildObjectGraph(1) Quit:$$$ISERR(sc) sc Set intRef=+$this,objValue=$get(%objTX(1,intRef,1)),sc=..%SerializeObject(.objValue,1) Set:$$$ISOK(sc) %objTX(1,intRef,1)=objValue Quit sc
	#; %TStart - Start a transaction if one doesn't exist and $zu(115,9) is on
	#; %TInclude - include this oref in the current transaction...
	If $$$txNOTINTRAN { Set traninit=1 Kill $$$txSTATUS,$$$txLISTroot,$$$txOIDASSIGNEDroot,$$$txMODIFIEDroot If '$zu(115,9) { Set $$$txSTATUS=1 } Else { Set $$$txSTATUS=2,$$$txLIST($this)="" TStart } }
	Set sc=..%BuildObjectGraph(related+2) If $$$ISERR(sc) ZTrap "SG"
	#; At this point, %objTX(2) contains a list of all objects that need to be saved
	If '$data(%objTX(2)) s sc=$$$OK GoTo %SaveCOMMIT
	Set %objTX2(+$this)=1
	#; First, examine the objects designated to be saved to see if any have zero predecessors
	Set %objTX(3)=0,intRef="" For  Set intRef=$order(%objTX(2,intRef)) Quit:intRef=""  If '$data(%objTX(1,intRef,2)) Set %objTX(3,$increment(%objTX(3)))=%objTX(1,intRef) Kill %objTX(2,intRef)
	#; Process the AOV. Calls to %SerializeObject here are complete serializations. If one fails, the TX needs to fail
	For  Quit:%objTX(3)<1  Set ptr=%objTX(3),objRef=%objTX(3,ptr),%objTX(3)=%objTX(3)-1 Kill %objTX(3,ptr) Set intRef=+objRef,objValue=$get(%objTX(1,intRef,1)),sc=objRef.%SerializeObject(.objValue) Do  Set %objTX(1,intRef,1)=objValue Kill %objTX(1,intRef,3) Do $system.CLS.SetModified(objRef,0)
	. If $$$ISERR(sc) Kill:$$$txON $$$txLIST(objRef),$$$txMODIFIED(objRef) ZTrap "SG"
		#; Process the mod bits for potential tx rollback
	. If $$$txON,objRef.%IsModified() Set $$$txMODIFIED(objRef)=$system.CLS.GetModifiedBits(objRef)
	#; visit the successors
	. Set intSucc="" For  Set intSucc=$order(%objTX(1,intRef,3,intSucc)) Quit:intSucc=""  Kill %objTX(1,intRef,3,intSucc),%objTX(1,intSucc,2,intRef) If '$data(%objTX(1,intSucc,2)) Set %objTX(3,$increment(%objTX(3)))=%objTX(1,intSucc) Kill %objTX(2,intSucc)
	#; If any objects are remaining in the graph then do a 'partial serialization' of the persistent objects that are
	#; designated as 'predecessors'.
	For  Set pserial=0 Do  Quit:'pserial
	. Set intRef="" For  Set intRef=$order(%objTX(2,intRef)) Quit:intRef=""  Set intPred="" For  Set intPred=$order(%objTX(1,intRef,2,intPred)) Quit:intPred=""  If %objTX(1,intPred,6)=1 Set objValue=$get(%objTX(1,intPred,1)),sc=(%objTX(1,intPred)).%SerializeObject(.objValue,1) If $$$ISOK(sc) Set pserial=1,%objTX(1,intPred,1)=objValue Do
	#; Visit the successors of this 'forced' ID assignment. If all predecessors are visited then add to the stack
	. . Set intSucc="" For  Set intSucc=$order(%objTX(1,intPred,3,intSucc)) Quit:intSucc=""  Kill %objTX(1,intPred,3,intSucc),%objTX(1,intSucc,2,intPred) If '$data(%objTX(1,intSucc,2)) Set %objTX(3,$i(%objTX(3)))=%objTX(1,intSucc) Kill %objTX(2,intSucc)
	#; Again, process the AOV. Calls to %SerializeObject here are complete serializations. If one fails, the TX needs to fail
	. . For  Quit:%objTX(3)<1  Set ptr=%objTX(3),objSerialize=%objTX(3,ptr),%objTX(3)=%objTX(3)-1 Kill %objTX(3,ptr) Set intSerialize=+objSerialize,objValue=$get(%objTX(1,intSerialize,1)),sc=objSerialize.%SerializeObject(.objValue) Do  Set %objTX(1,intSerialize,1)=objValue Kill %objTX(1,intSerialize,3) Do $system.CLS.SetModified(objSerialize,0)
	. . . If $$$ISERR(sc) Kill:$$$txON $$$txLIST(objSerialize),$$$txMODIFIED(objSerialize) ZTrap "SG"
		#; Process the mod bits for potential tx rollback
	. . . If $$$txON,objSerialize.%IsModified() Set $$$txMODIFIED(objSerialize)=$system.CLS.GetModifiedBits(objSerialize)
	#; visit the successors
	. . . Set intSucc="" For  Set intSucc=$order(%objTX(1,intSerialize,3,intSucc)) Quit:intSucc=""  Kill %objTX(1,intSerialize,3,intSucc),%objTX(1,intSucc,2,intSerialize) If '$data(%objTX(1,intSucc,2)) Set %objTX(3,$i(%objTX(3)))=%objTX(1,intSucc) Kill %objTX(2,intSucc)
	If $data(%objTX(2))>2 Set sc=$$$ERROR($$$SaveCyclicDependancy,$classname()) ZTrap "SG"
	#; Commit the transaction and cleanup
	Set cmd="" For  Set cmd=$order(%objTX(9,cmd)) Quit:cmd=""  Xecute cmd
%SaveCOMMIT	If traninit { If $$$txOFF { Kill $$$txSTATUS } Else { TCommit  Kill $$$txSTATUS,$$$txLISTroot,$$$txOIDASSIGNEDroot,$$$txMODIFIEDroot Set sc=$$$OK } }
	Set %objTX2(+$this)=0 Quit sc
%SaveERR	Set $ZTrap="" If $extract($zerror,1,5)'="<ZSG>" Set sc=$$$ERROR($$$CacheError,$ZE)
	Set:traninit sc=$$$ADDSC(sc,$$%TRollBack^%occTransaction())
	Set %objTX2(+$this)=0
	Quit sc
}

/// Elevates the concurrency level of an instance in memory to a higher level 
/// by changing the lock type specified in the <METHOD>%Open</METHOD> method for the object's 
/// instance. Fails if it cannot elevate the concurrency level.
/// 
/// Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
/// on the <var>concurrency</var> argument.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %UpgradeConcurrency(concurrency) As %Status [ Final, Internal ]
{
	#; Locks are not retained for any setting
	#; less than 3 and if the old and new
	#; setting are the same, nothing is to done!
	Set current=..%Concurrency
	Quit:concurrency'>current $$$OK
	If concurrency<3 Set modstate=$system.CLS.GetModifiedBits(),..%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate) Quit $$$OK
	#; Get the new lock
	Set sc=..%AcquireLock($select(concurrency=3:"s",1:"e")) Quit:$$$ISERR(sc) sc
	#; the following line releases the old lock
	#; which must be a shared lock as that is the
	#; only possible condition.
	If current=3 Do ..%ReleaseLock("s")
	#; Update the concurrency setting:
	Set modstate=$system.CLS.GetModifiedBits(),..%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate)
	Quit $$$OK
}

/// Acquires a lock for the current instance.
/// 
/// <p>The <var>locktype</var> argument specifies the type of lock to acquire.
/// It can take the following values:
/// <table cols=2>
/// <tr>
/// <td width="33%" valign="top">"e": <i>Exclusive</i></td>
/// <td valign="top">
/// An exclusive lock will prevent any other process from acquiring any type of lock
/// on this object.
/// </td>
/// </tr>
/// 
/// <tr>
/// <td width="33%" valign="top">"s": <i>Shared</i></td>
/// <td valign="top">
/// A shared lock will allow other processes to acquire shared locks but will
/// prevent other processes from acquiring an exclusive lock.
/// </table>
/// </td>
/// </tr>
/// 
/// Fails if the locktype parameter is not one of the values described above.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %AcquireLock(locktype) As %Status [ Private ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Stream.Object::%AcquireLock")
}

ClassMethod %CheckUnique(idxlist As %List = "") As %Status
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Stream.Object::%CheckUnique")
}

Method %LoadData(soid As %String) As %Status [ Private ]
{
	QUIT $$$OK
}

Method %SaveData(ByRef id As %String) As %Status [ Private ]
{
	QUIT $$$OK
}

ClassMethod %DeleteData(soid As %String, concurrency As %Integer) As %Status [ Private ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Stream.Object::%DeleteData")
}

Method %OnConstructClone(object As %RegisteredObject, deep As %Boolean = 0, ByRef cloned As %String) As %Status [ CodeMode = expression, Private ]
{
$$$ERROR($$$MethodNotImplemented,"%Stream.Object::%OnConstructClone")
}

/// Checks to see if the object identified by the OID <var>oid</var> exists in the extent.
/// 
/// <p>Returns <CLASS>%Boolean</CLASS> TRUE is it exists, FALSE if it does not.
ClassMethod %Exists(soid As %ObjectIdentity) As %Boolean
{
	If soid = $$$NULLOID Quit 0
	If $isobject(soid)=1 Quit 1
	Set class = $$$oidClassName(soid)
	If class '= "" {
		If $classname()'=$$$NormalizeClassname(class) Quit $classmethod(class,"%Exists",soid)
	}
	Set stream=..%Open(soid)
	Quit $select($isobject(stream)=1:'stream.%IsNull(),1:0)
}

/// Checks to see if the object identified by the ID <var>id</var> exists in the extent.
/// 
/// <p>Returns <CLASS>%Boolean</CLASS> TRUE is it exists, FALSE if it does not.
ClassMethod %ExistsId(id As %String) As %Boolean [ CodeMode = expression ]
{
..%Exists($$$oidForm(id))
}

ClassMethod %KillExtent() As %Status
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Stream.Object::%KillExtent")
}

/// Releases a lock for the current instance.
/// 
/// <p>The <var>locktype</var> argument specifies the type of lock to release.
/// It can take the following values:
/// <table cols=2>
/// <tr>
/// <td width="33%" valign="top">"e": <i>Exclusive</i></td>
/// <td valign="top">
/// An exclusive lock will prevent any other process from acquiring any type of lock
/// on this object.
/// </td>
/// </tr>
/// 
/// <tr>
/// <td width="33%" valign="top">"s": <i>Shared</i></td>
/// <td valign="top">
/// A shared lock will allow other processes to acquire shared locks but will
/// prevent other processes from acquiring an exclusive lock.
/// </table>
/// </td>
/// </tr>
/// 
/// Fails if the locktype parameter is not one of the values described above.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %ReleaseLock(locktype) As %Status
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Stream.Object::%ReleaseLock")
}

/// This callback method is invoked by the <METHOD>%Delete</METHOD> method to 
/// provide notification that the object specified by <VAR>oid</VAR> is being deleted.
/// 
/// <P>If this method returns an error then the object will not be deleted.
ClassMethod %OnDelete(oid As %ObjectIdentity) As %Status [ Private, ServerOnly = 1 ]
{
	Quit $$$OK
}

/// This callback method is invoked by the <METHOD>%Save</METHOD> method to 
/// provide notification that the object is being saved. It is called before 
/// any data is written to disk.
/// 
/// <P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.
/// 
/// <P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.
Method %OnBeforeSave(insert As %Boolean) As %Status [ Abstract, Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Save</METHOD> method to 
/// provide notification that the object is being saved. It is called after 
/// the object's data has been successfully written to disk.
/// 
/// <P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.
/// 
/// <P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.
Method %OnAfterSave(insert As %Boolean) As %Status [ Abstract, Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Open</METHOD> method to 
/// provide notification that the object specified by <VAR>oid</VAR> is being opened.
/// 
/// <P>If this method returns an error then the object will not be opened.
Method %OnOpen() As %Status [ Private, ServerOnly = 1 ]
{
	Quit $$$OK
}

/// This callback method is invoked by the <METHOD>%Reload</METHOD> method to 
/// provide notification that the object specified by <VAR>oid</VAR> was reloaded.
/// <method>%Reload</method> is invoked by %Open when the object identified by the OID 
/// is already in memory. 
/// <br>
/// <P>If this method returns an error then the object will not be opened.
Method %OnReload() As %Status [ Abstract, Private, ServerOnly = 1 ]
{
	Quit $$$OK
}

/// This callback method is invoked by the <METHOD>%Close</METHOD> method to 
/// provide notification that the current object is being closed.
/// 
/// <P>The return value of this method is ignored.
Method %OnClose() As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	if ..%Locked { do ..%UnlockStream(1) }
	Quit $$$OK
}

/// This callback method is invoked by the <METHOD>%Save</METHOD> method to 
/// provide notification that a save transaction is being rolled back.
/// 
/// <P>If this method returns an error then the rollback operation will be aborted.
Method %OnRollBack() As %Status [ Private, ServerOnly = 1 ]
{
	Quit $$$OK
}

/// Reads up to <var>len</var> characters from the current position 
/// in the stream. The current position is advanced by the number of 
/// characters read. Upon exit, <var>len</var> is set to the actual 
/// number of characters read. If a read occurs when the stream position 
/// is at the end of the stream, <var>len</var> will be set to -1 and 
/// <METHOD>Read</METHOD> will return a null string ("").
/// 
/// <p>You must call <METHOD>Rewind</METHOD> if you want to read a stream from the beginning 
/// again. Calling <METHOD>Read</METHOD> after <METHOD>Write</METHOD> implicitly ends the <METHOD>Write</METHOD> 
/// operation and rewinds to the start of the stream.
/// 
/// <p>Returns a string up to <var>len</var> characters long. The byref argument <var>sc</var> will
/// return a %Status if any error occurred during the read.
Method Read(ByRef len As %Integer = 32656, ByRef sc As %Status) As %CacheString
{
	Set len=0,i%AtEnd=1,sc=$$$OK
	Quit ""
}

/// Read a line from the stream. This will look for the line terminator in the stream and
/// once it finds the terminator it will return the string minus the terminator character/s. If it reaches the
/// end of the stream before it finds a terminator it will return the data it has so far, and if you specify a
/// maximum size in <var>len</var> it will only read up to this number of characters. On exit <var>len</var>
/// will contain the actual number of characters read. The byref argument <var>sc</var> will
/// return a %Status if any error occured during the read and the byref argument <var>eol</var>
/// is true if it found the line terminator and false otherwise. So for example you can read in a stream
/// a line at a time and output the results to the current device with:
/// <EXAMPLE>While 'stream.AtEnd { Write stream.ReadLine(,.sc,.eol) If $$$ISERR(sc) { Write "ERROR" Quit } If eol { Write ! } }</EXAMPLE>
Method ReadLine(ByRef len As %Integer = 32000, ByRef sc As %Status, ByRef eol As %Boolean) As %CacheString
{
	Set len=-1,sc=$$$OK,eol=0
	Quit ""
}

Method ReadLineIntoStream(ByRef sc As %Status) As %Stream.Object
{
	Set sc=$$$OK
	Quit ""
}

/// Appends the string <var>data</var> to the stream and advances the 
/// current stream position by the number of characters in <var>data</var>.
/// 
/// <p>Note that a write operation immediately following a read or rewind 
/// will clear out the existing data in the stream.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method Write(data As %CacheString) As %Status
{
	QUIT $$$ERROR($$$NotImplemented)
}

/// Appends the string <var>data</var> along with a line terminator to the stream and advances the 
/// current stream position by the number of characters in <var>data</var> plus the line terminator.
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method WriteLine(data As %CacheString = "") As %Status [ CodeMode = expression ]
{
$$$ERROR($$$NotImplemented)
}

/// Copies the contents of <i>source</i> into this Stream.
/// <p>For example, you can copy <var>oldstream</var> into a new stream:
/// <EXAMPLE>
/// Set newstream=##class(%GlobalCharacterStream).%New()
/// Do newstream.CopyFrom(oldstream)
/// </EXAMPLE>
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method CopyFrom(source As %Stream.Object) As %Status
{
	Quit:source=$$$NULLOREF $$$ERROR($$$OrefInvalid,"")
	
	Do source.Rewind()
	Set sc1=$$$OK,sc2=$$$OK
	If source.%Extends("%IO.I.Stream") {
		For  Quit:(source.AtEnd)||($$$ISERR(sc1)||($$$ISERR(sc2)))  Set sc1=..Write(source.Read(32656,,.sc2))
	} Else {
		For  Quit:(source.AtEnd)||($$$ISERR(sc1)||($$$ISERR(sc2)))  Set sc1=..Write(source.Read(,.sc2))
	}
	If $$$ISERR(sc1) Quit sc1
	If $$$ISERR(sc2) Quit sc2
	Quit $$$OK
}

/// Clear the contents of this Stream from permanent storage. This will remove the permanent stream storage and
/// any temporary stream and initialise the stream to its initial state that it starts in, including removing all
/// the stream attributes.
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method Clear() As %Status
{
	QUIT $$$ERROR($$$NotImplemented)
}

/// Move to the end of the stream so the next <METHDO>Write</METHOD> will be appended to the end.
/// This allows you to read from a stream, then MoveToEnd() and append new data, where just calling
/// <METHOD>Write</METHOD> after a read will clear the stream before writing new data.
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method MoveToEnd() As %Status
{
	QUIT $$$ERROR($$$NotImplemented)
}

/// Write out <var>len</var> characters of the stream to the current device starting from the current position. This
/// method is optimised for performance by the various sub classes. If <var>len</var> is omitted or set to -1 then
/// it will write out the entire stream starting at the beginning.
Method OutputToDevice(ByRef len As %Integer = -1) As %Status
{
	Set $ZTrap="OutputError"
	If len=0 Quit $$$OK
	If len=-1 {
		Do ..Rewind()
		For  Quit:..AtEnd  Write ..Read()
		Do ..Rewind()
	} Else {
		Set total=0
		For {
			Quit:..AtEnd
			If len-total>32656 {
				Set chunk=32656
			} Else {
				Set chunk=len-total
			}
			Write ..Read(.chunk)
			Set total=total+chunk
			Quit:total=len
		}
	}
	Quit $$$OK
OutputError	Quit $$$ERROR($$$CacheError,$ZE)
}

/// Input <var>len</var> characters from the current device into the stream. This is equivalent to doing a series of
/// reads and calling <METHOD>Write</METHOD> for each of them but it may be optimised by the subclasses. On return
/// <var>len</var> will be the number of characters still to read in (if no timeout has occured this should be 0).
Method InputFromDevice(ByRef len As %Integer = 0, timeout As %Integer = 20) As %Status
{
	Set $Ztrap="InputError"
	If len=0 Do ..Write("") Quit $$$OK
	For  Read data#$S(len>32656:32656,1:len):timeout Quit:'$test  Do ..Write(data) Set len=len-$length(data) Quit:len=0
	If len=0 Quit $$$OK
	Quit $$$ERROR($$$FileDoesNotExist)
InputError	Quit $$$ERROR($$$CacheError,$ZE)
}

Method LastModifiedGet() As %TimeStamp [ CodeMode = expression ]
{
""
}

/// Output the stream to the current device starting at <var>position</var> of length
/// <var>length</var>. The length if passed is the number of characters to output, if
/// not passed it will output from <var>position</var> to the end of the stream.
Method OutputToDeviceAt(position As %Integer, ByRef length As %Integer) As %Status
{
	If '(..MoveTo(position)) Set length=0 Quit $$$ERROR($$$StreamMoveToError,position)
	If $get(length)="" Set length=4294967296
	Quit ..OutputToDevice(.length)
}

/// Find the first occurrence of <var>target</var> in the stream starting the
/// search at <var>position</var>. It returns the position at this match starting
/// at the beginning of the stream. If it does not find the target string then
/// return -1. If <var>position</var>=-1 then start searching from the current
/// location and just return the offset from the last search, useful for searching
/// through the entire file. If you are doing this you should pass in <var>tmpstr</var>
/// by reference in every call which is used as a temporary location to store information
/// being read so the next call will start where the last one left off. If you pass
/// <var>caseinsensitive</var>=1 then the search will be case insensitive rather than the
/// default case sensitive search.
Method FindAt(position As %Integer, target As %CacheString, ByRef tmpstr As %CacheString = "", caseinsensitive As %Boolean = 0) As %Integer
{
	If caseinsensitive Set target=$zconvert(target,"l")
	Set find=0,targetlen=$length(target)
	If position=-1 {
		Set position=1
		If $get(tmpstr)'="" {
			Set find=$find(tmpstr,target)
			If find {
				Set tmpstr=$extract(tmpstr,find,*)
				Quit position+find-targetlen-1
			} Else {
				Set position=position+$length(tmpstr)-targetlen+1
			}
		}
	} Else {
		If '..MoveTo(position) Quit -1
		Set tmpstr=""
	}
	
	While '..AtEnd {
		Set tmp=..Read(20000)
		If caseinsensitive Set tmp=$zconvert(tmp,"l")
		Set tmpstr=$extract(tmpstr,*-targetlen+2,*)_tmp
		Set find=$find(tmpstr,target)
		If find Set tmpstr=$extract(tmpstr,find,*) Quit
		Set position=position+$length(tmpstr)-targetlen+1
	}
	If find Quit position+find-targetlen-1
	Quit -1
}

/// Move to this <var>position</var> in the stream. If this suceeds then return
/// true, else return false. Note this implementation is not efficient because it
/// searches from the start of the stream, it can be improved upon in specific subclasses.
/// Note that moving to position 1 will be at the start of the stream, position 2 will be
/// at the second character of the stream, etc.
Method MoveTo(position As %Integer) As %Boolean
{
	Set position=position-1
	Do ..Rewind()
	While position>0 {
		Set tmp=..Read($select(position>32656:32656,1:position)),position=position-$length(tmp)
		If tmp="" Quit
	}
	Quit position=0
}

/// Go back to the start of the stream.
Method Rewind() As %Status
{
	QUIT $$$ERROR($$$NotImplemented)
}

/// Flush any output in the stream not already saved.
Method Flush() As %Status
{
	QUIT $$$ERROR($$$NotImplemented)
}

/// Returns true if this is a "NULL" stream; that is, a stream which has never 
/// been written to and saved and has no stream attributes. This is used by the Cach&eacute; ODBC server.
Method IsNull() As %Boolean [ CodeMode = call ]
{
..%IsNull()
}

/// Returns true if this is a "NULL" stream; that is, a stream which has never 
/// been written to and saved and has no stream attributes. This is used by the Cach&eacute; ODBC server.
Method %IsNull() As %Boolean [ CodeMode = expression ]
{
1
}

/// Return true if this stream oid is a null stream and false if the stream is not null
ClassMethod %ObjectIsNull(soid As %ObjectIdentity) As %Boolean
{
	If soid=$$$NULLOID Quit 1
	If $isobject(soid)=1 Quit soid.%IsNull()
	Set class=$$$oidClassName(soid)
	If class'="" {
		If $classname()'=$$$NormalizeClassname(class) Quit $classmethod(class,"%ObjectIsNull",soid)
	}
	Set oref=..%Open(soid) If oref=$$$NULLOREF Quit 1
	Quit oref.%IsNull()
}

/// Copy the stream from <var>source</var> into the current stream ignoring anything already in the current stream
/// and save the result to the permanent location. This is used to optimise the copying of say a
/// <CLASS>%GlobalCharacterStream</CLASS> to another <CLASS>%GlobalCharacterStream</CLASS> to avoid copying into
/// temporary storage first and then moving this to the permanent storage when <METHOD>SaveStream</METHOD> is called.<p>
/// Note that any locking or transaction handling must be done by the caller.
Method CopyFromAndSave(source As %Stream.Object) As %Status
{
	Set sc=..Rewind() Quit:$$$ISERR(sc) sc
	Set sc=..CopyFrom(source) Quit:$$$ISERR(sc) sc
	Quit ..%Save()
}

/// SerializeToSyncSet copies the stream value from the current object to the sync set global. When the sync set is imported into another system
/// the stream value will be copied from the global back to a stream of the container property's current type.
Method SerializeToSyncSet(ss As %SYNC.SyncSet, iPtr As %Integer, property As %String) As %Status [ CodeMode = generator ]
{
	If $$$comClassKeyGet(%class,$$$cCLASSclientdatatype) = $$$cCLASSCLIENTDATATYPEBINARYSTREAM { $$$GENERATE("	Set syncstream = ##class(%Stream.GlobalBinary).%New()") }
	Else { $$$GENERATE("	Set syncstream = ##class(%Stream.GlobalCharacter).%New()") }
	$$$GENERATE("	Set %objsync = ss.GlobalName()")
	$$$GENERATE("	Set @%objsync@(iPtr,property) = $classname()")
	$$$GENERATE("	Set syncstream.%Location = $Name(@%objsync@(iPtr,property,1))")
	$$$GENERATE("	Set sc = syncstream.CopyFromAndSave($this)")
	$$$GENERATE("	If $$$ISOK(sc) { Set @%objsync@(iPtr,property)=syncstream.%Oid() } Quit sc")
	Quit $$$OK
}

/// SyncStreamIn copies the stream value from the sync set global into the current object.
Method SyncStreamIn(ss As %SYNC.SyncSet, iPtr As %Integer, property As %String) As %Status
{
	Set %objsync = ss.GlobalName()
	Set oidStream = $$$oidInsertAd1($Get(@%objsync@(iPtr,property)),$Name(@%objsync@(iPtr,property,1)))
	Set syncstream = ##class(%Stream.Object).%Open(oidStream,,.sc)
	If $isobject(syncstream) { Quit ..CopyFromAndSave(syncstream) } Else { Quit sc }
}

Method SizeGet() As %Integer
{
	Quit -1
}

/// SQL specific method for reading stream data
Method ReadSQL(start As %Integer = 1, end As %Integer = -1) As %String
{
	If ..%IsNull() Quit ""
	If end=-1 Set end=start+$$$MaxLocalLength
	If (end<start)||(..Size=0) Quit $char(0)
	Do ..Rewind()
	Set start=start-1
	While start>0 {
		Set tmp=..Read(start),start=start-$length(tmp),end=end-$length(tmp)
		If tmp="" Quit
	}
	If start'=0 Quit $char(0)
	Set tmp=..Read(end)
	Quit $select(tmp="":$char(0),1:tmp)
}

/// Return true if this stream oid is a null stream and false if the stream is not null
ClassMethod StreamOIDIsNull(soid As %ObjectIdentity) As %Boolean [ CodeMode = call ]
{
..%ObjectIsNull(.soid)
}

/// Returns the size of the stream pointed to by soid in the most efficient way possible.
ClassMethod %ObjectSize(soid As %ObjectIdentity) As %Integer
{
	If $isobject(soid)=1 Quit soid.Size
	If soid = $$$NULLOID Quit 0
	set class = $$$oidClassName(soid)
	if class '= "" {
		set class=$$$NormalizeClassname(class) If $classname()'=class Quit $classmethod(class,"%ObjectSizeInternal",soid)
	}
	Quit ..%ObjectSizeInternal(soid)
}

ClassMethod %ObjectSizeInternal(soid As %ObjectIdentity) As %Integer [ Private ]
{
	Set size=0
	Try {
		Set stream=..%Open(soid)
		If $isobject(stream) Set size=stream.Size
	} Catch {
	}
	Quit size
}

/// Given a <var>soid</var> if the length is <= <var>prefetchsize</var> then return the data
/// in <var>data</var>. 
/// The return value is 0 meaning the stream is over this size, 
///                     1 for character stream
///                     2 for binary stream.
///                     3 for non-NULL empty Stream (Size=0)
ClassMethod %LOBPrefetch(soid As %ObjectIdentity, prefetchsize As %Integer, ByRef data As %String) As %Integer
{
	Set data=""
	If $isobject(soid)=1 {
		Quit:soid.Size>prefetchsize 0
		Set data=soid.Read(prefetchsize)
		Quit $select(soid.Size=0:3,soid.IsCharacter():1,1:2)
	}
	Quit:soid=$$$NULLOID 1
	set class = $$$oidClassName(soid)
	if class '= "" {
		set class=$$$NormalizeClassname(class) 
		If $classname()'=class { Quit $classmethod(class,"%LOBPrefetchInternal",soid,prefetchsize,.data) }
	}
	Quit ..%LOBPrefetchInternal(soid,prefetchsize,.data)
}

ClassMethod %LOBPrefetchInternal(soid As %ObjectIdentity, prefetchsize As %Integer, ByRef data As %String) As %Integer [ Private ]
{
	Set stream=..%Open(soid)
	If $isobject(stream) {
		Quit:stream.Size>prefetchsize 0
		Set data=stream.Read(prefetchsize)
		Quit $select(stream.Size=0:3,stream.IsCharacter():1,1:2)
	}
	Quit 0
}

}
