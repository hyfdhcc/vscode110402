Include (%syConfig, %sySystem, SHDW)

Class Config.CPF Extends Config.CommonMethods [ Abstract, System = 4 ]
{

Parameter DOMAIN = "%Utility";

/// Read and activate the current CPF file.<br>
/// This method will read the currently active CPF file if it has been updated on disk
/// but not yet read in. After the current settings have been read in, they are activated.
ClassMethod Activate() As %Status
{
}

/// If the system is in a state where none of the namespaces work (e.g. <NOROUTINE> when trying
/// to execute a routine which should be there in %SYS), this call will reset the system with
/// the values currently in the CPF file. This is primarily used for debugging EMS when you
/// have downloaded a bad namespace map.
ClassMethod Recover() As %Status [ Internal ]
{
}

/// Returns 0/1 if the CPF file has been modified but not activated.<br>
/// If it has been modified by an editor, an activation must occur before
/// any of the Config methods can be called to activate any additional changes.
ClassMethod CPFFileNeedsActivation(ByRef Msg As %String) As %Boolean
{
}

/// Determines if a restart of the system is required in order to 
/// activate modified CPF parameters.<br>
/// Return Values:<br>
/// 0 - Restart is not required<br>
/// 1 - Restart is required<br>
/// Reasons - If a restart is required, an array of reasons why in the following format.<br>
/// Reasons=1<br>
/// Reasons(1,"New")=New value<br>
/// Reasons(1,"Old")=Old Value<br>
/// Reasons(1,"Property")=Property name<br>
/// Reasons(1,"Section")=Section name<br>
/// Reasons(1)="Restart required because section [xxx], property yyy modified, new value:zzz, old value:zzz"<br>
/// Note that if the CPF file has been modified, but not yet activated, this
/// method will return 1, and the following array:<br>
/// Reasons=1<br>
/// Reasons(1)="Restart or reactivation required because the CPF file xxxx has been modified, but not activated"<br>
/// Reasons(1,"New")=""<br>
/// Reasons(1,"Old")=""<br>
/// Reasons(1,"Property")=""<br>
/// Reasons(1,"Section")=""<br>
ClassMethod PendingRestart(ByRef Reasons As %String) As %Boolean
{
}

/// Load the various sections of the CPF file which can be reactivated.<br>
ClassMethod Load() As %Status [ Internal ]
{
}

/// Create a default cache.cpf file.<br>
ClassMethod CreateDefault(Directory As %String = "", Overview As %String) As %Status [ Internal ]
{
}

/// Convert a CPF file to the current version.<br>
/// This method will take a CPF file and convert it to the current version. Note that it will
/// not do any validation on the file, it will simply convert it.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
/// <b>Flags</b> - Internal use only, do not pass.<br>
ClassMethod Convert(ByRef CPFFile As %String = "", Flags As %Integer = 0) As %Status
{
}

ClassMethod RemoveDuplicates(CPFFile As %String, Flags As %Integer) As %Status [ Internal ]
{
}

/// Update lines in the CPF file.<br>
/// This method will take an array of error messages generated by the Validate method(),
/// and determine if there any of these messages are related to overlapping range mappings.
/// If there are, it will take the range overlaps and generate non-overlapping ranges. For
/// example if you had the following mappings:<br><br>
/// A:C -> DB1<br>
/// B:D -> DB2<br><br>
/// it would generate the following mappings instead:<br><br>
/// A:C -> DB1<br>
/// C:D -> DB2<br><BR>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
/// <b>Lines (by ref)</b> - Array of line numbers to update in the CPF file. Each line
/// contains the error message about how that line overlaps with some previous line.
/// For example:<br><br>
/// Lines(186)="Overlapped mapping "_$c(0)_"(Note):(Notf)"_$c(0)_" mapping overlaps with a prior mapping "_$c(0)_"(Notes)"_$c(0)_" , LINE:'Global_Note*=DOCBOOK,5' at line 186 "<br>
/// Lines(187)="Overlapped mapping "_$c(0)_"(Not):(Nou)"_$c(0)_" mapping overlaps with a prior mapping "_$c(0)_"(Notes)"_$c(0)_" , LINE:'Global_Not*=DOCBOOK,5' at line 187 "<br>
ClassMethod UpdateLines(CPFFile As %String = "", ByRef Lines As %String, Flags As %Integer) As %Status [ Internal ]
{
}

/// Update lines in the CPF file.<br>
/// This method is used by the CPF file converter to help convert overlaping mappings
/// from 2008.2 or previous version CPF files to 2009.1 non-overlapped mappings.<br>
/// This is part of the handling when we have a mapping of the form:<br><br>
/// Line 1) A:C -> DB1<br>
/// Line 2) A   -> DB2<br>
/// Line 3) A("r"):A("S") -> DB3<br><br>
/// converts to<br><br>
/// Line 1) A.:C -> DB1<br>
/// Line 2) A   -> DB1    ; Note that the rest of this mapping is "hidden" by A.:C<br>
/// Line 3) A("r"):A("S") -> DB3<br><br>
/// This method handles resolving and fixing up of line 1 and 2 (line 3 was resolved 
/// by UpdateLines() )<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
/// <b>UpdateLinesAgain(by ref)</b> - Array of information to update mappings, generated by 
/// the UpdateLines() method.<br>
ClassMethod UpdateLinesAgain(CPFFile As %String = "", ByRef UpdateLinesAgain As %String, Flags As %Integer) As %Status [ Internal ]
{
}

/// Merge map ranges back into wildcards.<br>
ClassMethod MergeMaps(CPFFile As %String = "", Flags As %Integer) As %Status [ Internal ]
{
}

/// Convert the CPFFile to version 2008.2.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20082(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2009.0.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20090(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2009.1.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20091(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2009.15.<br>
/// This is the start of the conversion to 2010.1 format.
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo200915(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.1.<br>
/// This continues the conversion to 2010.1 format, started by ConvertTo200915.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20101(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.11.<br>
/// This finishes the conversion to Cache' 2010.1 format, started by ConvertTo200915.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201011(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.15.<br>
/// This starts the conversion to 2010.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201015(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.16.<br>
/// This continues the conversion to 2010.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201016(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.17.<br>
/// This continues the conversion to 2010.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201017(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.18.<br>
/// This continues the conversion to 2010.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201018(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2010.2.<br>
/// This finishes the conversion to 2010.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20102(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

ClassMethod ConvertTo201021(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

ClassMethod ConvertTo20105(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2011.01.<br>
/// This continues the conversion to 2011.1 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201101(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2011.02.<br>
/// This continues the conversion to 2011.1 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201102(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2011.03.<br>
/// This continues the conversion to 2011.1 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201103(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2011.04.<br>
/// This finishes the conversion to Cache 2011.1.x.
/// Note: 2011.1.x and 2012.1.x CPF file formats are the same.
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201104(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

ClassMethod ConvertTo201105(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2011.06.<br>
/// This continues the conversion to 2012.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo201106(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2012.2.<br>
/// This finishes the conversion to 2012.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20122(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2013.1.<br>
/// This finishes the conversion to 2013.1 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20131(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2014.1.<br>
/// This starts the conversion to 2014.1 format.<br>
/// Note that there was no version 2013.2. 2013.2 is the same version as 2013.1
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20141(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2015.1.<br>
/// This starts the conversion to 2015.1 format.<br>
/// Note that there was no version 2014.2. 2014.2 is the same version as 2014.1.
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20151(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2015.2.<br>
/// This starts the conversion to 2015.2 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20152(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Convert the CPFFile to version 2015.3.<br>
/// This starts the conversion to 2015.3 format.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert.<br>
ClassMethod ConvertTo20153(ByRef CPFFile As %String = "", Flags As %Integer = 0) [ Internal ]
{
}

/// Log the conversion details in the CPF file, and also to the cconsole.log
/// file if not running the validator. Note that the Temp file must be open and 
/// the current device if called in order to log to the CPF file.<br>
/// Flags - Bit string of options.<br>
/// Bit 0 - Log to cconsole.log<br>
/// Bit 1 - Log to CPF file<br>
ClassMethod LogCPFChange(Message As %String, Flags As %Integer = 3) [ Internal ]
{
}

/// Convert a CPF file name to an internal name.<br>
/// Basically, this strips off the directory specification and the .CPF file extension, and
/// uses the resulting name as part of the index. On windows and VMS, the name is uppercased,
/// on unix it is not. For example:<br><br>
/// c:\abc\cache.cpf ---> CACHE<br>
/// /abc/cache.cpf ---> cache<br>
/// dka100:[abc]cache.cpf---> CACHE<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to convert its name.<br>
/// Return Values:<br>
/// <b>CPFFile</b> by ref - Normalized CPF file name<br>
/// <b>CPFName</b> by ref - Converted name to use in the index<br>
/// <b>CPFMapFile</b> by ref - Used as temporary storage when creating global/routine/package mappings<b>
/// <b>CPFName</b> by ref - Used as temporary storage name<br>
ClassMethod FileToName(ByRef CPFFile As %String = "", ByRef CPFName As %String = "", ByRef CPFMapFile As %String = "", ByRef CPFMapName As %String = "") As %Status [ Internal ]
{
}

/// Convert a CPF file name to an internal name.<br>
ClassMethod GetName(CPFFile As %String = "") As %String [ Internal ]
{
}

/// Convert a multiple entry %Status variable to text and output it.<br>
/// This method should be used on a %Status variable returned from the Read() method.
/// <b>Flags</b> - Options for error text<br>
/// <var>Bit $$$ErrorTextToScreen</var> - Write error text to terminal<br>
/// <var>Bit $$$ErrorTextToConsole</var> - Write error text to cconsole.log<br>
/// <var>Bit $$$ErrorTextToArray</var> - Return error text in ErrorText array<br>
ClassMethod GetErrorText(Status As %Status, Flags As %Integer = {$$$ErrorTextToScreen}, ByRef ErrorText As %String) As %Status [ Internal ]
{
}

/// Move the entire config object to the ^CONFIG global.<br>
ClassMethod MoveToActive(Obj As %ObjectHandle = "", Flags As %Integer = 1) As %Status [ Internal ]
{
}

/// Read a CPF file into a config object.<br>
/// The CPF file is only read in if it has been modified with an editor since the last time
/// it was read.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to read.<br>
/// <b>Flags</b><br>
/// <var>Bit $$$CPFReadValidateOnly</var> - Validate CPFFile but don't import.<br>
/// <var>Bit $$$CPFReadForceRead</var> - Force read of file even if last modified date is the same<br>
/// Return values: <br>
/// <b>CPFFile</b> by ref - Normalized CPF file name.<br>
/// <b>CPFName</b> by ref - Converted name.<br>
/// <b>WasRead</b> by ref - 0/1 if file was actually read into the object.<br>
/// <b>Updates</b> by ref - Internal use only. Array used to pass in the Super server and Web server ports during installation.<br>
/// Note that if we pass the Validate flag, the file will be modified to change
/// the format of it to the current version.
ClassMethod Read(ByRef CPFFile As %String = "", Flags As %Integer = 0, ByRef CPFName As %String = "", ByRef WasRead As %Boolean, ByRef Updates As %String) [ Internal ]
{
}

/// This method forces a reset of the CPF file such that the next time the system restarts,
/// it will be read in, and the new config objects and ^CONFIG global is populated and
/// activated.
ClassMethod Reset() [ Internal ]
{
}

/// Validate that the section name read in from the CPF file is a valid section, and
/// in the right order in the file.<br>
/// Parameters:<br>
/// <b>Section</b> - Name of the section we just read.<br>
/// <b>Sections</b> by ref - Comma separated list of valid sections.
/// Return Values:<br>
/// <b>Section</b> - Normalized name of the section we just read. If a [Map.XXXX] section return "Map" piece.<br>
/// <b>Namespace</b> by ref - If a [Map.XXXX] section, returns the XXX (namespace) piece.
/// <b>Sections</b> by ref - Comma separated list of valid sections, with the section just read removed from the list.<br>
ClassMethod ValidateSection(ByRef Section As %String, ByRef ID As %String, ByRef Sections As %String) As %Status [ Internal ]
{
}

/// Validate a CPFFile.<br>
/// <b>CPFFile</b> - CPF file to validate.<br>
/// <b>Flags</b> - Options for error text. Macros defined in %syConfig.inc.<br>
/// <var>Bit $$$ErrorTextToScreen</var> - Write error text to terminal<br>
/// <var>Bit $$$ErrorTextToConsole</var> - Write error text to cconsole.log<br>
/// <var>Bit $$$ErrorTextToArray</var> - Return error text in ErrorText array<br>
ClassMethod Validate(ByRef CPFFile As %String = "", Flags As %Integer = {$$$ErrorTextToScreen}, ByRef ErrorText As %String) As %Status
{
}

/// Write to the CPF file from the config object.<br>
/// Parameters:<br>
/// <b>CPFFile</b> - CPF file to write, default is currently active one.<br>
ClassMethod Write(ByRef CPFFile As %String = "")
{
}

/// Write the active CPF file to the _lastgood_.cpf file
ClassMethod WriteLastGood() [ Internal ]
{
}

}
