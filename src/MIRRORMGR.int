ROUTINE MIRRORMGR [Type=INT]
MIRRORMGR ;Mirror manager process for this system ;$Change: 4521965 $
 ; Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/rtn/sysconfig/mirrormgr.mac#1 $
 /*
 +--------------------------------------------------------+
 | Copyright 1986-2015 by InterSystems Corporation,       |
 | Cambridge, Massachusetts, U.S.A.                       |
 | All rights reserved.                                   |
 |                                                        |
 | Confidential, unpublished property of InterSystems.    |
 |                                                        |
 | This media contains an authorized copy or copies       |
 | of material copyrighted by InterSystems and is the     |
 | confidential, unpublished property of InterSystems.    |
 | This copyright notice and any other copyright notices  |
 | included in machine readable copies must be reproduced |
 | on all authorized copies.                              |
 +--------------------------------------------------------+
 */
 ;
 ; Entry points in this module are for internal use only and are
 ; subject to change in future versions.
 ; ---------------------------------------------------------------
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/_syJrninc.inc#1 $ ($Change: 4521965 $) */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/_syMirror.inc#1 $ ($Change: 4521965 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/FILEINC.inc#1 $ ($Change: 4521965 $) */
 	q
Start(mirname) PUBLIC {
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			d $zu(9,"","Mirroring not started, no mirror members defined",1 /* broadcast and log message*/,2  /* Severe error */)
			quit
		}
	}
	; As long as this job is running it holds the MgrJobID lock and its pid and
	; jobid are listed in ^MIRROR("MgrJobID")
	l ^MIRROR(mirname,"MgrJobID"):5
	if '$T {
		d $zu(9,"",$ZN_" already running in process: "_$G(^MIRROR("MgrJobID")),1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s origtype=$ZU(61,10,$ZU(61),44)  ;Set our jobtype
	s status=$system.License.KeyServer()
	if (status '= "Multi") && ('##class(%SYSTEM.License).GetFeature(2)) {		/* JO2443 */
	  d $zu(9,"","Mirroring not started, multi-server license required. License Type = "_status,1 /* broadcast and log message*/,2  /* Severe error */)
	  do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
	  quit
	}
    do $ZU(68,40,1) ; Use $ZEOF, not <ENDOFFILE> for reading files
	s $zt="err"
	s logerr=1  ; record errors in ^%ET
	if ($zu(78,3)="") {
		d $zu(9,"","Mirroring not started, journal directory path is not initialized in the system.",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
		quit
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","Mirroring not started, failed to read mirror member configuration",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
		quit
	}
	s reportingNode=cls.isAsyncMember()
	s systemid=cls.SystemName
	s validmember=cls.ValidatedMember
	if 'reportingNode {
	   s asyncmembertype=-1  ;not an async member 
	   s info=0
	   s status=cls.CheckSecurity(.info)
	   if ('status) {
	      d $zu(9,"","Mirroring not started, error during security check. Status= "_$SYSTEM.Status.GetErrorText(status),1 /* broadcast and log message*/,2  /* Severe error */)
	      do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
	      quit
	   }
	   if '+info {
	      ; STU^MIRROR checks this but we want to check this here as well in case
	      ; this is kicked off manually at some point.
	      d $zu(9,"","Mirror service is not enabled. Mirroring not started.",1 /* broadcast and log message*/,2  /* Severe error */)
	      do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
	      quit
	   }
	} else {
	   ; 0 = DR, non-zero = reporting (see class doc for details)
	   s asyncmembertype=cls.AsyncMemberType
	}
	s cls=""
	s encryptedJournal=##class(%SYS.Journal.System).IsJournalEncryptionEnabled(3)
	if 'reportingNode {
	   s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	   if ('rc) {
		  d $zu(9,"","Mirroring not started, failed to open Config.Mirrors("_mirname_")",1 /* broadcast and log message*/,2  /* Severe error */)
		  do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
		  quit
	   }
	   if encryptedJournal,'cls.UseSSL {
		  d $zu(9,"","Mirroring not started - encrypted journal file requires use of SSL",1 /* broadcast and log message*/,2  /* Severe error */)
		  do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
		  quit
	   }
	   do $SYSTEM.Mirror.FailoverRule(2)
	   Set mytime=$G(^SYS("MIRRORTIME",mirname))
	   Set PrimaryTime=$p(mytime,"^",2)
	   Set id=$o(^SYS("MIRRORSET",mirname,"Member",101-1),1,info)
	   while (id'="") {
		   s name=$LG(info,1)
		   if $LG(info,8)'=0 {
			   s rc=$$GetFailoverTimestamp^MIRRORCTL(mirname,id)
			   if ($LG(rc)="OK") {
				   s time=$LG(rc,2)
				   if '(time=""||'(time-mytime>0||((time-mytime)=0&&($p(time,",",2)>$p(mytime,",",2)))))||$LG(rc,4) {
					   s PromotedDR(id)=$LB(info,rc),PromotedDR=$i(PromotedDR)
				   }
			   }
		   }
		   Set id=$o(^SYS("MIRRORSET",mirname,"Member",id),1,info)
	   }
	   if $G(PromotedDR)>2 {
		   d $zu(9,"","Mirroring not started, more than two promoted async members exist.",1 /* broadcast and log message*/,2  /* Severe error */)
		   do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
		   Quit
	   }
	   if $G(PromotedDR)=2 {
		   s id=$o(PromotedDR(""))
		   if $d(^SYS("MIRRORSET",mirname,"Member",1),info) {
			   s mobj=##class(Config.MapMirrors).Open(mirname,$lg(info),,,.rc)
			   if '('rc) {
				   s mobj.MemberType=$LG($LG(PromotedDR(id)),8)
				    s rc=mobj.%Save()
				    if ('rc) {
					    d $zu(9,"",$ZN_" failed to demote "_$lg(info)_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					}
					s mobj=""
			   }
		   }
		   s info=$lg(PromotedDR(id))
		   s mobj=##class(Config.MapMirrors).Open(mirname,$lg(info),,,.rc)
		   if '('rc) {
			   s mobj.MemberType=0
			   s rc=mobj.%Save()
			   if ('rc) {
				   d $zu(9,"",$ZN_" failed to promote first "_$lg(info)_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   }
			   s mobj=""
		   }
		   s id=$o(PromotedDR(id))
		   s info=$lg(PromotedDR(id))
		   s NewAsyncType=$LG(info,8)
		   s $list(info,8)=0
		   s rc=##class(SYS.MirrorConfiguration).DemoteToAsyncMember(mirname,info,NewAsyncType,0,1)
		   if ('rc) {
			   d $zu(9,"","Failed to demote to async member "_$lg(info)_". Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   d $zu(9,"","Mirroring not started, demote to async failed. There may be a mirror configuration problem.",1 /* broadcast and log message*/,2  /* Severe error */)
			   do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
			   Quit
		   } else {
			   Halt
		   }
	   }
	   if $G(PromotedDR) {
		   s id=$o(PromotedDR(""),1,info)
		   s rc=$LG(info,2)
		   s info=$LG(info)
		   s name=$LG(info)
		   s IamDefinedPrimary=cls.DefinedPrimary'=""&&(cls.DefinedPrimary=$LG($G(^SYS("MIRRORSET",mirname,"Member",0))))
		   if IamDefinedPrimary&&(cls.DefinedPrimary=$LG(rc,3)) {
			   if (+$G(^SYS("MIRRORSET",mirname,"Member"),0) > 0) {
				   s bname=$LG(^SYS("MIRRORSET",mirname,"Member",1))
				   s mobj=##class(Config.MapMirrors).Open(mirname,bname,,,.rc)
				   if '('rc) {
					   s mobj.MemberType=$LG(info,8)
					   s rc=mobj.%Save()
					   if ('rc) {
						   d $zu(9,"",$ZN_" failed to demote "_bname_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					   }
					   s mobj=""
				   }
			   }
			   s mobj=##class(Config.MapMirrors).Open(mirname,name,,,.rc)
			   if '('rc) {
				   s mobj.MemberType=0
				   s rc=mobj.%Save()
				   if ('rc) {
					   d $zu(9,"",$ZN_" failed to promote "_name_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				   }
				   s mobj=""
			   }
			   if 'validmember {
				   s clsx=##class(Config.MirrorMember).Open(,,.rc)
				   s clsx.ValidatedMember=1
				   s validmember=1
				   s rc=clsx.%Save()
				   s clsx=""
			   }
		   } elseif validmember {
			   d $zu(9,"","Mirroring not started, because async member '"_name_"' has been promoted to a failover member or it is supposed to be demoted to an async member but remains as a failover member. You must manually edit the cache.cpf configuration file, and in the [MirrorMember] section set ValidatedMember=0.",1 /* broadcast and log message*/,2  /* Severe error */)
			   do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
			   quit
		   }
	   }
	   if validmember Set $p(^SYS("MIRRORTIME",mirname),"^")=$ZTS,TimestampSet=1
	} else {
		Kill ^SYS("MIRRORTIME",mirname)
	}
	s cls=""
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	if ('$L(mirguid)&&('reportingNode))||'$L(systemid) {
		d $zu(9,"","Mirror manager failed to start: Missing mirror configuration information",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
		quit
	}
	k ^MIRROR(mirname,"PendingNewMember"),^MIRROR(mirname,"PendingDNUpdates")
	k ^MIRROR(mirname,"PrimaryDeltaTime")
	k ^MIRROR(mirname,"DejournalWorker")
	k ^MIRROR(mirname,"PrimaryMember")
	k ^MIRROR(mirname,"DejournalReader")
	;
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1
	d $SYSTEM.Mirror.GetInfo(6,miridx-1)
	if (reportingNode) ! (+$G(^SYS("MIRRORSET",mirname,"Member"),0) < 1) {
		s NeedProgagateData=0
	} else {
		s NeedProgagateData=1
	}
	k ConnectHistory  ;tracks 10 most recent connections to the primary
	;
	if '$$CheckVersion(mirname) {
		do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
	   l
	   quit
	}
	s localinfo=^SYS("MIRRORSET",mirname,"Member",0)
	if 'reportingNode {
		s x=##class(Config.Startup).Open()
		s locssp=x.DefaultPort
		s x=""
		if ($p($LG(localinfo,3),"|",2)'=locssp) || ($p($LG(localinfo,4),"|",2)'=locssp) {
			d $zu(9,"","Mirror manager failed to start: Mismatching Super Server port ("_locssp_" vs "_$p($LG(localinfo,3),"|",2)_")",1 /* broadcast and log message*/,2  /* Severe error */)
			do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
			L
			Quit
		}
		if $G(^SYS("MIRRORSET",mirname,"Member"),0)'=0 {
			s cls=##class(Config.Mirrors).Open(mirname,,,.rc) 
			if ('rc) {
				d $zu(9,"","Mirroring not started, failed to read mirror configuration for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
				do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
				quit
			}
			if cls.VirtualAddress'="" {
			    s otherinfo=$G(^SYS("MIRRORSET",mirname,"Member",1))
				if ($p($LG(otherinfo,3),"|",2)'=locssp) || ($p($LG(otherinfo,4),"|",2)'=locssp) {
					s msg = "There is a virtual address defined and the super server port of this member is different than the other member. "
					s msg = msg_"Client applications may not be able to connect to both mirror members using the virtual address."
					d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
			s cls=""
		}
	}	
    if 'reportingNode || (asyncmembertype=0) {
		s sec=##Class(Security.System).%OpenId("SYSTEM",,.rc)
		if ('rc) {
			d $zu(9,"","Failed to open "_"SYSTEM"_" security class to reset InactiveLogin limit: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			if sec.InactiveLimit {
				d $zu(9,"",$s('reportingNode:"Failover",1:"DR")_" mirror member changed the InactiveLimit system security property from "_sec.InactiveLimit_" to 0.",0,0  /* Informational message */)
				s sec.InactiveLimit=0
				s rc=sec.%Save()
				if ('rc) {
					d $zu(9,"","Failed to save zeroed InactiveLimit: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
			s sec=""
		}
    }
    d $zu(9,"","Mirror manager for "_mirname_" starting",0,0  /* Informational message */)
	s ^MIRROR(mirname,"MgrJobID")=+$J_","_$ZU(61)_","_$ZU(61,30,$ZU(61)) ;pid,job#,jobid
	;
	do $SYSTEM.Mirror.ModifyControlJob(miridx,1)  ;1 = set us as ctrl job
	;
    ; ("State") is just for informational purposes. 
    ; ("Status") tracks the status of other members
    ; ("MSG") is the message queue used by the communication channel
    ;
	s ^MIRROR(mirname,"State")="Starting"
	k ^MIRROR(mirname,"Status")  ;reset our view of the other nodes
	k ^MIRROR(mirname,"MSG")     ;and our messaging i/o queue
	k ^MIRROR(mirname,"DejournalProcessor")
	k ^MIRROR(mirname,"retry")
	k ^||MIRROR(mirname,"retry")
	;
	s ^MIRROR(mirname,"Role")=""
	s role=""
	s forceBecomePrimary=0
	s signalpid=0  ;used in the waitloop as the pid to wakeup
	;
    s logSevereFailureMessage=1
    s wasBackup=0  ;Set when we used to be the backup
    if $G(^SYS("MIRRORSET",mirname,"Member"),0)>0 {
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc>0 {
			s info=$zu(78,22,$P(rc,",",2),99)
			s validend=+$P(info,",",16+1)
			if info>0,validend>0 {
				do ClearLastFileValidEnd(mirname)
				d $zu(9,"","Mirror Startup: valid end ("_validend_") of last journal file "_$P(rc,",",2)_"("_(+rc)_") is cleared.",0,0  /* Informational message */)
			}
		}
    }
	d $system.Util.SetInterruptEnable(1)
    do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
reinit ;come back here if we're not a valid member or we have a problem
	do $SYSTEM.Mirror.LastFileValidFlag(0)
	do $SYSTEM.Mirror.ActiveBackupFlag(0)
	do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if reportingNode&&($LG(localinfo,9)="") {
		s rc=$$PrimaryDiscovery(mirname)
		if 'rc {
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$PrimaryDiscovery("""""_mirname_""""") }"", .rc)","PrimaryFound1","Cannot determine primary mirror member")
			goto wait
		}
PrimaryFound1 s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	}
	s rc=$$ValidateAgent^MIRRORCOMM(reportingNode,$lg(localinfo,5))
	if 'rc {
	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateAgent^MIRRORCOMM("""""_reportingNode_""""","""""_$lg(localinfo,5)_""""") }"", .rc)","reinit","Failed to validate local agent")
	   goto wait
	}
	if 'reportingNode,validmember,systemcnt,'$G(PromotedDR) {
		s rc=$$ValidateFailoverPartner(mirname)
		if 'rc {
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateFailoverPartner("""""_mirname_""""") }"", .rc)","reinit","Failed to validate failover partner")
			goto wait
		}
	}
	; reading the mirrored db's to get the starting point or validating the
	; mirror journal log
	if 'reportingNode,'validmember {
	   ; if we're not a valid mirror member then try to contact the other 
	   ; mirror members to see if we're valid now
	   s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	   if ('rc) {
		   d $zu(9,"","Failed to read [Mirrors] configuration section for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit","Failed to read [Mirrors] configuration section")
		   goto wait
	   }
	   s cls.DefinedPrimary=""
	   s rc=cls.%Save()
	   s cls=""
	   if ('rc) {
		   d $zu(9,"","Failed to Clear DefinedPrimary for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit")
		   goto wait
	   }
	   if '$G(PromotedDR) {
		   s validmember=$$ValidateMirrorMembership^MIRRORCOMM(mirname)
		   if 'validmember {
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit","Failed to validate mirror membership")
			   goto wait
		   }
		   if validmember=1 goto goodmember
		   if +validmember=2 {
			   s id=$p(validmember,",",3)
			   s NewAsyncType=$p(validmember,",",2)
			   if id'="" {
				   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
				   s $list(info,8)=0
			   } else {
				   s info=""
			   }
			   s NotifyPrimary=1
			   goto demotemember
		   }
		   if +validmember=3 {
			   s info=$p(validmember,",",3,999)
			   s NewAsyncType=$p(validmember,",",2)
			   s NotifyPrimary=0
			   goto demotemember
		   }
	   }
	   s id=$o(PromotedDR(""),1,info)
	   s info=$LG(info)
	   s definedPrimary=$LG(info)
	   s NewAsyncType=$LG(info,8)
	   if NewAsyncType=0 s NewAsyncType=2
	   s mlist=definedPrimary_","_$lg(^SYS("MIRRORSET",mirname,"Member",0))
	   s targguid=$lg(info,2)
	   s basedir=$lg(info,6)
	   s agentip=$$BuildAgentAddrlist^MIRRORCTL(info)
	   s validmember=$$ValidatePromoteMembership^MIRRORCOMM(mirname,agentip,targguid,basedir,.mlist)
	   if validmember {
		   if systemcnt>0 {
			   s mobj=##class(Config.MapMirrors).Open(mirname,$LG(^SYS("MIRRORSET",mirname,"Member",1)),,,.rc)
			   if ('rc) {
				   d $zu(9,"","Failed to open failover member "_$LG(^SYS("MIRRORSET",mirname,"Member",1))_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
DFfailed		   s cls=##class(Config.MirrorMember).Open(,,.rc)
				   s cls.ValidatedMember=0
				   s rc=cls.%Save()
				   s cls=""
				   s validmember=0
				   do AddRetryEntry(mirname,"(""(rc) { s rc=1 }"", .rc)","reinit","Failed to open [MapMirrors] section in the configuration")
				   goto wait
			   }
			   s mobj.MemberType = NewAsyncType
			   s rc=mobj.%Save()
			   if ('rc) {
				   d $zu(9,"","Failed to demote failover member "_$LG(^SYS("MIRRORSET",mirname,"Member",1))_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				   goto DFfailed
			   }
			   s mobj=""
		   } 
		   s obj=##class(Config.MapMirrors).Open(mirname,definedPrimary,,,.rc)
		   if ('rc) {
			   d $zu(9,"","Failed to open failover member "_definedPrimary_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   goto DFfailed
		   } else {
			   s obj.MemberType=0
			   s rc=obj.%Save()
			   s obj=""
			   if ('rc) {
				   d $zu(9,"","Failed to modify failover member "_definedPrimary_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				   goto DFfailed
			   }
		   }
		   kill PromotedDR goto reinit
	   } else {
		   s rmtisfailover=mlist[(","_definedPrimary_",")
		   s localisfailover=($LG(info,8)=0)
		   if rmtisfailover'=localisfailover {
			   s $list(info,8)=$s(rmtisfailover:0,1:2)
		   } else {
			   s info = ""
		   }
		   s NotifyPrimary=0
demotemember ;
		   L -^MIRROR(mirname,"MgrJobID")
		   do $SYSTEM.Mirror.ModifyControlJob(miridx,0)   ; clear us as control job.
		   s rc=##class(SYS.MirrorConfiguration).DemoteToAsyncMember(mirname,info,NewAsyncType,NotifyPrimary,1)
		   if ('rc) {
			   d $zu(9,"","Failed to demote to async member. Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   L +^MIRROR(mirname,"MgrJobID")
			   do $SYSTEM.Mirror.ModifyControlJob(miridx,1)   ; clear us as control job.
			   goto DFfailed
		   } else {
			   Halt
		   }
	   }
	}
	k PromotedDR
goodmember ;
    if '$$InitDejournal(miridx,mirname) {  ; id=1 is failover backup node connection -> primary
	    d $zu(9,"","("_mirname_") Failed to initialize dejournal memory. Mirror manager exited",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
	    l
	    quit
    }
	; 
	do MountMirroredDBs("Mirror startup",mirname)
	k ^MIRROR(mirname,"dejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"firstdejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"transroll")    ;set by ValidateMirrorJournalLog
	k ^MIRROR(mirname,"lastvalidjrnfile") ;set by ValidateMirrorJournalFiles
	s rc=$$GetMirrorDejournalInformation(mirname,1)
	if 'rc {
	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$GetMirrorDejournalInformation("""""_mirname_""""",1) }"", .rc)","reinit","Failed to determine dejournaling start point")
	   goto wait
	}
    s rc=$$ValidateMirrorJournalLog(mirname)
    if 'rc {
       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryValidateMirrorJournalLog("""""_mirname_""""",1) }"", .rc)","reinit","Failed to validate mirror journal log")
	   goto wait
	}
	s useOldActiveBackupCode=0
	if 'reportingNode {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		if info'="" {
			s mtype=+$LG(info,8)
			if mtype'=0 {
				d $zu(9,"","ActiveBackup not cleared for member #1 (type "_mtype_") which is not a failover member",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				s name=$lg(info,1)
				s rc=$$ClearActiveBackup^MIRRORCTL(mirname,1)
				if $LG(rc)="UNKNCMD" {
			        d $zu(9,"","ClearActiveBackup not supported by other mirror member - using old failover logic",1 /* broadcast and log message*/,1  /* Warning */)
	        		s useOldActiveBackupCode=1
				} elseif $LG(rc)="ERR" {
					; We can't continue until we get an OK back from this routine
					d $zu(9,"","ClearActiveBackup failed: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
			        do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearActiveBackup("""""_mirname_""""") }"", .rc)","Restart","Error contacting other failover member to clear active backup state")
			        goto wait
				} elseif $LG(rc)="TIMEOUT" {
					if forceBecomePrimary {
						d $zu(9,"","Ignoring timeout clearing active backup flag becuase forceBecomePrimary flag is set",1 /* broadcast and log message*/,1  /* Warning */)
					} else {
						d $zu(9,"","Failed to contact other failover member to clear active backup flag - waiting for other node to become available",1 /* broadcast and log message*/,1  /* Warning */)
						do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearActiveBackup("""""_mirname_""""") }"", .rc)","Restart","Timed out contacting other failover member to clear activate backup state")
						goto wait
					}
				}
			}
		}
	   if '$G(TimestampSet) Set $p(^SYS("MIRRORTIME",mirname),"^")=$ZTS,TimestampSet=1
	}
	Kill ^MIRROR(mirname,"DejournalFile") Set ^MIRROR(mirname,"DejournalStarted")=-1
Restart ; 
	do $SYSTEM.Mirror.ModifyDecidingState(0)
	if '$$LockMirroredDB(mirname) {
		do AddRetryEntry(mirname,"(""(rc) { s rc=$$LockMirroredDB("""""_mirname_""""") }"", .rc)","DBLocked","Failed to lock mirrored databases.")
		goto wait
	}
DBLocked ;
	if reportingNode&&($LG(localinfo,9)="") {
		s rc=$$PrimaryDiscovery(mirname)
		if 'rc {
			d UnlockMirroredDB()
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$PrimaryDiscovery("""""_mirname_""""") }"", .rc)","PrimaryFound2","Failed to locate the primary mirror member")
			goto wait
		}
PrimaryFound2 s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	}
	if $SYSTEM.Mirror.ActiveBackupFlag() {
		; When activebackupflag is set we know we have all the journal data
		; so we can skip directly to ActiveBackupRestart
		if useOldActiveBackupCode {
			; If the other mirror member doesn't support the new code then we need
			; to clear the activebackup flag ourselves here. At topDecisionLoop we
			; will need to try to contact the other member to figure out its status
			; because the ActiveBackupFlag doesn't tell us whether it has started or
			; not.
			do $SYSTEM.Mirror.ActiveBackupFlag(0)
			d $zu(9,"","ActiveBackup state cleared - Old failover code still in effect",0,0  /* Informational message */)
		}
		if $$Updatelastjvalidjrnfile(mirname) {
			goto ActiveBackupRestart
		}
		do $SYSTEM.Mirror.ActiveBackupFlag(0)
		if $SYSTEM.Mirror.LastFileValidFlag() do ClearLastFileValidEnd(mirname)
	}
    if '$$InitDejournal(miridx,mirname) {  ; id=1 is failover backup node connection -> primary
	    d $zu(9,"","("_mirname_") Failed to re-initialize dejournal memory. Mirror manager exited",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
	    quit
    }
    if forceBecomePrimary {
	    d $zu(9,"","Attempting startup with forceBecomePrimary flag set",1 /* broadcast and log message*/,1  /* Warning */)
    }
    Do CheckStartDejournalProcessor(mirname,0,0)
    ; Non-backups and backups which are not active start here.
    ; "Active" backups skip this step because they know they have all the
    ;    journal files
 	s rc=$$GetMissingMirrorJournalFiles(mirname,forceBecomePrimary)
	if 'rc {
	   if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	   d UnlockMirroredDB()
	   if $G(^MIRROR(mirname,"Status","MGR"))="Exit" {
		   do ClearRetryList(mirname)
		   goto waitnext
	   }
	   ;RetryGetMissingJournalFiles tries to retrieve the missing
	   ; files again but it also watches for changes in the earliest
	   ; file we require as that may affect what files we need to get
 	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetMissingMirrorJournalFiles("""""_mirname_""""") }"", .rc)","Restart","Failed to retrieve missing journal files")
	   goto wait
	}
	if $G(^MIRROR(mirname,"DejournalStarted"),-1)>=0 {
		d StopDejournalProcessor(mirname,0)
		s rc=$$UpdateMirrorJournalCheckPoint(mirname)
		if '+rc {
			d $zu(9,"","MIRRORMGR: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	;Set $SYSTEM.MIRROR.LastFileValidFlag() = 0/1
	s rc=$$SetLastFileValidFlag(mirname)
	if ('rc) {
	   d UnlockMirroredDB()
 	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$SetLastFileValidFlag("""""_mirname_""""") }"", .rc)","Restart","Failed to mark last journal file as valid")
	   goto wait
	}
ActiveBackupRestart ;
	/* Active backups come back to this tag when they lose their
	   connection to the primary. Inactive backups, and non-backups,
	   start up higher */
	s rc=$$ApplyJournalFiles(mirname) ; may update ^MIRROR("dejrnchkpnt")
	if rc'=1 {
		d UnlockMirroredDB()
		if 'rc {
	       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryApplyJournalFiles("""""_mirname_""""") }"", .rc)","Restart","Failed to apply existing journal files")
		} else {
		 ; rc = -1 which means retry ValidateJournalFiles
	        do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryValidateMirrorJournalFiles("""""_mirname_""""") }"", .rc)","Restart","Must re-validate journal files to continue")
		}
	    goto wait
	}
	d UnlockMirroredDB()
	if NeedProgagateData {
	   ; If GetECPSessionData() returns 0 we don't add it to the retry list, we'll just
	   ; call it again if we get back here or log an error that ECP Client sessions
	   ; may be dropped if we become the primary
	   s rc=$$GetECPSessionData^MIRRORCOMM(mirname,NeedProgagateData)
	   if rc {
		   s NeedProgagateData=0  ;succeeded, we don't need to do this again
	   }
	}
	if reportingNode {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if (systemcnt=0) goto wait  ;no other node to talk to
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		s mtype=+$LG(info,8)
		if mtype'=0 {
			; We're an async member connecting to another async member (relay)
			s id=1  ;node to connect to
		} else {
		   ; become backup checks whether the other node is the primary. If so
		   ; we try to become the backup.
		   s id=$$GetCurrentPrimaryID(mirname)
		   if id=-1 {
	          do AddRetryEntry(mirname,"(""(rc) { s rc=($$GetCurrentPrimaryID("""""_mirname_""""")'=-1) }"", .rc)","Restart","Failed to locate current primary")
	          goto wait
		   }
		}
		do BecomeBackup(mirname,id)
    	s role=$G(^MIRROR(mirname,"Role"))  ;Become backup updated Role if it succeeded
		goto wait
	}
	if '$SYSTEM.Mirror.LastFileValidFlag() {
		if forceBecomePrimary {
			d $zu(9,"","Failed to validate journal files - ForceBecomePrimary aborting",1 /* broadcast and log message*/,1  /* Warning */)
			goto wait  ;don't try to become the backup (yet) if ForceBecomePrimary is set
		}
	}
	if role="" {
	   d $zu(9,"","Manager initialized for "_mirname,0,0  /* Informational message */)
	}
	s role="Starting"  /* Entered the top of the decision loop */
topDecisionLoop ;
	/* If there's no primary, we should become the primary */
	do $SYSTEM.Mirror.ModifyDecidingState(1)  ;1 = enter transition state
	if $SYSTEM.Mirror.ActiveBackupFlag() {
		s NeedProgagateData=0
		do BecomePrimary(mirname,forceBecomePrimary,wasBackup)
		s forceBecomePrimary=0 ; this gets cleared after we try once
		s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
		do QueueCheckForDuplicatePrimary(mirname)
		goto wait
	}
	; Retrieve state of other node
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) {
		; We're the only node in the mirror, become the primary
        d $zu(9,"","No other mirror members configured, becoming primary mirror server",0,0  /* Informational message */)
        if NeedProgagateData=1 {
	       d $zu(9,"","Missing current ECP Client data - ECP client sessions may reset rather than recover",0,0  /* Informational message */)
        } elseif NeedProgagateData=2 {
	       d $zu(9,"","Missing progagated data - mirror journal file purge might be inaccurate.",0,0  /* Informational message */)
        }
		s NeedProgagateData=0
		do BecomePrimary(mirname,forceBecomePrimary,wasBackup)
		s forceBecomePrimary=0 ; this gets cleared after we try once
        s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
		goto wait
	}
	s ourguid=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),2)
getStatus ;          
	; There are a max of 2 failover nodes in a mirror so systemcnt
	; is 1 here. If this changes, this logic needs to be updated to
	; scan the status of all the members.
	s id=1  ;this is the other node
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	   do $SYSTEM.Mirror.ModifyDecidingState(0)
	   d $zu(9,"","Missing information for mirror member #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	   do AddRetryEntry(mirname,"(""(rc) { s info=$G(^SYS(""MIRRORSET"","""""_mirname_""""",""Member"","_id_")) s rc=$L(info) }"", .rc)","Restart","Internal error: ^SYS(""MIRRORSET"") missing information for mirror member")
	   goto wait
    }
	s name=$lg(info,1)
    s guid=$lg(info,2)
    s rc=$$GetStatus^MIRRORCTL(mirname,id)
    s status=$LG(rc)  
checkStatus 
	if status="ERR" {
		h 1
		s rc=$$GetStatus^MIRRORCTL(mirname,id)
		s status=$LG(rc)  
		if status="ERR" {
			d $zu(9,"","Cannot takeover, error fetching status of "_name_": "_$LG(rc,3),1 /* broadcast and log message*/,1  /* Warning */)
	        do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetStatus("""""_mirname_""""","""""_id_""""","""""_status_""""") }"", .rc)","Restart","GetStatus returned ""ERR"" - Unable to determine state of other failover member")
	        goto wait
		}
		; fall into rest of checkStatus now that status is not ERR
	}
	if '$get(resolved) {
		s resolved=$$ResolveFrozenPrimary(mirname,rc)
		if (resolved<0) || (resolved>1) {
			goto Restart ; state has changed
		}
	}
    if status="PRIMARY" {
	   do $SYSTEM.Mirror.ModifyDecidingState(0) ; clear transition state
	   d $zu(9,"","Found "_name_" as primary, becoming backup",0,0  /* Informational message */)
	   do BecomeBackup(mirname,1)  ;other node is id #1
       s role=$G(^MIRROR(mirname,"Role"))  ;Become backup updated Role if it succeeded
	   goto wait
    }
    if status="HUNG" {
	   s lastjrninfo=$$GetDejrnChkpntInfo(mirname)  ;returns cnt^pos
	   if '+lastjrninfo {
		   s lastjrnfilecnt=0
		   s lastjrnend=0  ;no journal files yet	
	   } else {
		   s lastjrnend=+$P(lastjrninfo,"^",2)
		   s lastjrnfilecnt=+lastjrninfo
	   }
	   if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
		   d $zu(9,"","HUNG primary not forced down - Backup missing one or more required databases",1 /* broadcast and log message*/,2  /* Severe error */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckRequiredDatabases("""""_mirname_""""","_lastjrnfilecnt_","_lastjrnend_") }"", .rc)","Restart","Hung primary not forced down because one or more required databases are missing")
		   goto wait
	   }
	   if $$CheckDefinedPrimary(1)'=1 {
		   d $zu(9,"","HUNG primary not forced down - 'No Failover' is set.",1 /* broadcast and log message*/,2  /* Severe error */)
		   do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","'No Failover' is set")
		   goto wait
	   }
	   ; force it down and wait until status is not hung
	   d $zu(9,"","("_mirname_") Forcing down hung node "_name_" (#"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
	   s status=$$ForceNodeDown^MIRRORCTL(mirname,id,1)
	   s waittime=120  ;two minutes, then we give up and go to wait
	   do {
	      h 1
	      s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
          s waittime=waittime-1
	   } while waittime && ((status="HUNG") || (status="ERR"))
	   if ((status="HUNG") || (status="ERR")) {
		  d $zu(9,"","Member "_name_" failed to be forced down, code="_$lg(rc,3),1 /* broadcast and log message*/,1  /* Warning */)
		  do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetStatus("""""_mirname_""""","""""_id_""""",""""HUNG"""") }"", .rc)","Restart","Waiting for other failover member to report it is down")
		  goto wait
	   }
	   d $zu(9,"","Forced member "_name_" now reports status: "_status,0,0  /* Informational message */)
	   goto Restart
    } 
    if (status="UP")!(status="DOWN") {
	   s dejrnfilecnt=+$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	   if dejrnfilecnt>0&&(dejrnfilecnt<(+$LG(rc,2))) {
		  d $zu(9,"","Checking for additional journal files from #"_dejrnfilecnt_" to #"_$LG(rc,2),0,0  /* Informational message */)
		  goto Restart
	   }
	   if $LG(rc,3)="ACTIVEBACKUPFLAGSET" {
		   s rc2=$$ClearActiveBackup^MIRRORCTL(mirname,id)
		   if $LG(rc2)="ERR" {
			   ; We can't continue until we get an OK back from this routine
			   d $zu(9,"","Error clearing active backup flag of ""UP"" backup ("_$LG(rc,2)_") - cannot become primary",1 /* broadcast and log message*/,1  /* Warning */)
		       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearActiveBackup("""""_mirname_""""") }"", .rc)","Restart","Failed to clear the active backup state on other failover member")
			   goto wait
		   }
		   d $zu(9,"","Cleared active backup flag of ""UP"" system - continuing",0,0  /* Informational message */)
	   }
	   d $zu(9,"",name_" reports it is "_status_", becoming primary mirror server",0,0  /* Informational message */)
       if NeedProgagateData=1 {
	      d $zu(9,"","Missing current ECP Client data - ECP client sessions may reset rather than recover",0,0  /* Informational message */)
	   } elseif NeedProgagateData=2 {
	       d $zu(9,"","Missing progagated data - mirror journal file purge might be inaccurate.",0,0  /* Informational message */)
       }
       s NeedProgagateData=0
	   do BecomePrimary(mirname,forceBecomePrimary,wasBackup)
	   s forceBecomePrimary=0 ; this gets cleared after we try once
       s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
	   goto wait
    }
    if status="DECIDING" {
	   if $$CompareGUIDs(ourguid,guid)<0 {
	      ; if we have the lower guid, then we're the decider
		  ; we keep our status as "DECIDING" and wait for the
		  ; other node to do something.
		  hang 1
		  goto getStatus
	   }
	   do $SYSTEM.Mirror.ModifyDecidingState(0) ; clear transition state
	   d $zu(9,"","Waiting for "_name_" to become primary",0,0  /* Informational message */)
	   do {
	      hang 1
	      s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
       } while (status = "DECIDING")
       goto Restart
	}
	if status="TIMEOUT" {
	   if 'forceBecomePrimary {
		   d $zu(9,"","("_mirname_") Failed to contact other node's agent - Waiting",0,0  /* Informational message */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckOtherNodeIsReachable("""""_mirname_""""") }"", .rc)","Restart","Waiting to contact agent on other failover member")
		   goto wait
	   }
	   s forceBecomePrimary=0
	   d $zu(9,"","("_mirname_") Becoming Primary - ForceBecomePrimary flag is set",0,0  /* Informational message */)
       if NeedProgagateData=1 {
	      d $zu(9,"","Missing current ECP Client data - ECP client sessions may reset rather than recover",0,0  /* Informational message */)
	   } elseif NeedProgagateData=2 {
	       d $zu(9,"","Missing progagated data - mirror journal file purge might be inaccurate.",0,0  /* Informational message */)
       }
       s NeedProgagateData=0
	   do BecomePrimary(mirname,forceBecomePrimary,wasBackup)	
       s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
       ; CheckForDuplicatePrimary will keep trying to contact the agent on the
       ; other node and if it succeeds & the other node is the primary, it will
       ; force down the mirror
       do QueueCheckForDuplicatePrimary(mirname)
	   goto wait
	}
	d $zu(9,"","Unknown status /"_status_"/ from GetStatus - Ignored",1 /* broadcast and log message*/,1  /* Warning */)
    do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetStatus("""""_mirname_""""","""""_id_""""","""""_status_""""") }"", .rc)","Restart","Other failover member is in an unknown state")
wait ;
	do $SYSTEM.Mirror.ModifyDecidingState(0)
	s status=$SYSTEM.Mirror.GetStatus(mirname)
	if status="TRANSITION"||(status="SYNCHRONIZING") {
		/* TRANSITION  is set when the mirror configuration is loaded and if
		   it is still set here, we change it to waiting */
		do $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		s ^MIRROR(mirname,"Role")=""
		s role=""
	}
	g:$G(^MIRROR(mirname,"Status","MGR"))="Exit" waitnext
	if forceBecomePrimary {
	   d $zu(9,"","Failed to force this node to become the primary",1 /* broadcast and log message*/,1  /* Warning */)
	   s forceBecomePrimary=0
	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckOtherNodeIsReachable("""""_mirname_""""") }"", .rc)","Restart")
	}
	if +$G(logSevereFailureMessage) {
		s logSevereFailureMessage=0
		if (role'="PRIMARY") && (role'="BACKUP") {
		   if wasBackup {
		      d $zu(9,"","Backup failed to take over as primary",1 /* broadcast and log message*/,2  /* Severe error */)
		   } else {
			  if reportingNode {
		         d $zu(9,"","Async member for "_mirname_" started but failed to connect to primary",1 /* broadcast and log message*/,2  /* Severe error */)
			  } else {
		         d $zu(9,"","Failed to become either Primary or Backup at startup",1 /* broadcast and log message*/,2  /* Severe error */)
			  }
		   }
		   if 'reportingNode {
			   try {
				   do NotifyBecomePrimaryFailed^ZMIRROR()
			   } catch errv {
				   ; Its ok if the routine or the entry point doesn't
				   ; exist but report other errors
	   		       if "<NOROUTINE>,<NOLINE>"'[errv.Name {
					   s errtext=errv.Name_" at "_errv.Location
				       d $zu(9,"",errtext_" calling NotifyBecomePrimaryFailed^ZMIRROR",1 /* broadcast and log message*/,1  /* Warning */)
	   		       }
			   }
		   }
		}
	}
	; If MIRROR_STATUS_RESTART is still set then clear it now. This is
	; set at startup and when a backup resets. While this is set
	; we hold incoming ECP connections in case we're about to become
	; the primary. At this point if we're not the primary then we want
	; to reject these so they get redirected to the primary. 
	; Its not an error to call ClearRestart() when MIRROR_STATUS_RESTART 
	; isn't set.
	do $SYSTEM.Mirror.ClearRestart() 
	;
	s ^MIRROR(mirname,"Status","MGR")="Run"  ; can be killed or set to shut down MGR node and all TCP readers
waitloop ;	
	; Main work loop. Sit here waiting for messages to be posted
	; to the incomming queue. 
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if (''rc),reportingNode'=cls.isAsyncMember() {
		if '$$BackupDaemonExit(mirname,0) {
			do $SYSTEM.Mirror.Shutdown(10)
		}
		S ^MIRROR(mirname,"Status","MGR")="Exit"
		s RestartMirror=1
		goto waitnext
	}
	s cls=""
	If wasBackup,role'="PRIMARY",+$G(OrigECPRecoveryTimeout)'=0 {
		if OrigECPRecoveryTimeout<60 d $SYSTEM.ECP.SetProperty("ECPRecoveryTimout",OrigECPRecoveryTimeout)
		k OrigECPRecoveryTimeout
	}
	if $get(resolved)<1 {
		if (reportingNode) || (role="PRIMARY") || (role="BACKUP") || ('systemcnt) {
			set resolved=1 
		} else {
			set resolved=$$ResolveFrozenPrimary(mirname)
		}
	}
	if '$SYSTEM.Util.GetSwitch(16) {
		s tag=$$CheckRetryList(mirname)
	} else {
		s tag=""
	}
	if tag'="" {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Returning to """_tag_"""")
	   if $SYSTEM.Mirror.GetStatus(mirname)="WAITING" {
		   do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	   }
	   goto $case(tag,"Restart":Restart,
					   "reinit":reinit,
					   "PrimaryFound1":PrimaryFound1,
					   "PrimaryFound2":PrimaryFound2,
					   "DBLocked":DBLocked,
					   :retryTagErr)
	} 
	if signalpid {
		do $SYSTEM.Event.Signal(signalpid)
		s signalpid=0
	}
	if role="PRIMARY" {
		do UpdateJournalFilesSent(mirname,.sentfilelist)
	}
	if $D(^MIRROR(mirname,"PendingPurgeList"))\10 {
		if +$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))'=0 {
			k ^MIRROR(mirname,"PendingPurgeList")
		} else {
			; If there are children, then see if we can purge them now
			; (the children are mirror journal file #'s which have been
			; fully dejournaled).
		   do AsyncJrnfilePurge(mirname)
		}
	}
	if '$SYSTEM.Util.GetSwitch(16) && $d(sw16MSGQ) {
		s x=$o(sw16MSGQ(""),1,msg)
		k sw16MSGQ(x)  ; remove it.
		s id=$LG(msg,1)
		s text=$LG(msg,2)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" msg: from #"_id_" text = /"_text_"/ resumed.")
		goto EVENT
	}
	; 5 seconds if role is still Starting, otherwise 30
	s msgwait=$S($G(role)="Starting"  /* Entered the top of the decision loop */:5,1:30)
	s msg=$SYSTEM.Event.WaitMsg("",msgwait)  ;no args = our $J event
	if (msg="") ! ($LL(msg)'=2) {
		d $zu(9,"","MIRRORSVR: Invalid result from EventWait, exiting",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		quit
	}
	if $Lg(msg)=1 {
	   s msg=$LG(msg,2)  ; extract the useful part
	   ; The message itself is a list which has a command and an optional value
	   s cmd=$LG(msg,1) 
	   if $LL(msg)>1 s val=$LG(msg,2)
	   if cmd="STOP" {
		  d $zu(9,"","MIRRORSVR: Stop request received, exiting",0,0  /* Informational message */)
	  	  do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		  quit
	   }
	   if cmd="MSGQ" {
		   ; most common message, there is a message from another member for us 
		   s msg=$G(^MIRROR(mirname,"MSG","InQ",val))
		   k ^MIRROR(mirname,"MSG","InQ",val)  ;delete old messages
		   if msg'="" {
			   s id=$LG(msg,1)
			   s text=$LG(msg,2)
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" msg: from #"_id_" text = /"_text_"/")
			   if '$SYSTEM.Util.GetSwitch(16)||($E(text,1,9)="SHUTDOWN:") goto EVENT  ;comes back to waitnext or Restart
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" msg: from #"_id_" text = /"_text_"/ queued and skipped.")
			   s sw16MSGQ($i(sw16MSGQidx))=msg
		   }
	   }
	   if cmd="REQ" {
		   ; this is a message with the text in the message itself
		   ; these come from our system's C code via $SYSTEM.Event.Signal()
		   ; and have the form $LB("REQ",<sending pid>,<text>)
		   s id=val
		   s text=$LG(msg,3)
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" REQ: from pid"_id_" text = /"_text_"/")
		   goto REQMSG
	   }
	}
waitnext ;		
	; Check our status node and wait again
	g:$G(^MIRROR(mirname,"Status","MGR"))="Run" waitloop
	If $SYSTEM.Mirror.GetInfo()["BACKUP" do $SYSTEM.Mirror.BackupStartupAbort()
	; Time to Exit
	s ^MIRROR(mirname,"Status","MGR")="Stop"
	s ^MIRROR(mirname,"State")="Halted"
	s ^MIRROR(mirname,"MgrJobID")=""
    s x=$SYSTEM.Mirror.DejournalFree(miridx)
    do StopDejournalProcessor(mirname,0)
	do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
	do $ZU(61,10,$ZU(61),origtype)
	if $G(RestartMirror) {
		s rc=$$Startup(mirname)
		if (''rc) {
			d $zu(9,"","Mirror: Manager restarted mirroring ("_mirname_")",0,0  /* Informational message */)
		} else {
			d $zu(9,"","Mirror: Manager failed to restart mirroring ("_mirname_") error="_$SYSTEM.Status.GetErrorText(rc),0,0  /* Informational message */)
		}
	}
	d $zu(9,"","Mirror: Manager for "_mirname_" exited.",0,0  /* Informational message */)
	quit	
err ;
	s $zt=""
	if $ze["EXTERNAL INTERRUPT" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Got external interrupt signal to shutdown. $ze="_$ze)
		s ^MIRROR(mirname,"Status","MGR")="Exit"
		g waitnext
	}
	If $SYSTEM.Mirror.GetInfo()["BACKUP" do $SYSTEM.Mirror.BackupStartupAbort()
	if $G(mirname)="" s mirname="<:unknown>"
	s ^MIRROR(mirname,"State")="ErrorHalt"
	s ^MIRROR(mirname,"MgrJobID")=""
    s:$G(miridx)'="" x=$SYSTEM.Mirror.DejournalFree(miridx)
    do StopDejournalProcessor(mirname,0)
	d $zu(9,"","MIRRORSVR: Unexpected error /"_$ZE_"/ - Halted",1 /* broadcast and log message*/,2  /* Severe error */)
	do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
	do $ZU(61,10,$ZU(61),origtype)
	d:logerr BACK^%ETN
	quit	
retryTagErr ;	
	d $zu(9,"","MIRRORSVR: Missing target for retry /"_tag_"/ in goto $case",1 /* broadcast and log message*/,1  /* Warning */)
	goto Restart  
	; These are message handlers for the keywords posted on the MSGQ
EVENT ;
    if $E(text,1,9)="RUNCYCLE:" {
	    s signalpid=id
	    g waitnext
    }
	if $E(text,1,8)="MIRDOWN:" {
		; MIRDOWN is posted by Backup() and Server() when the $SYSTEM.Mirror
		; .Client() or .Server() returns because the connection to the other
		; node was terminated. 
		; 
		; $SYSTEM.Mirror.Client() waits for the dejournaling jobs to finish 
		; processing the received journal data before it returns.
		;
		if role="Pause"  /* Stop sending messages to other systems */ {
            do $SYSTEM.Mirror.ActiveBackupFlag(0)
			goto waitnext  ; ignore this if we're shutting down
		}
		; One of the connections from Backup() or Primary()
		; has exited (or failed while initializing). The message
		; contains details on what happened.
		; 
		; The message is "MIRDOWN:<reason>:<text>" where <reason> is 0 for 
		; an unknown error or one of the MIR_SHUTDOWN_ codes. <text>
		; is more information if we know it.
		s ^MIRROR(mirname,"Status","Member",id,"Role")=text
		if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"","MIRDOWN: ("_mirname_")Set member #"_id_" role to "_text)
		s reason=+$P(text,":",2)
		s cliexit=$p(text,":",3),cliexit=(cliexit="CLIENTEXIT"||(cliexit="CLIERROR"))
		if role="BACKUP"&&cliexit {
	 	   ; Clear Role and we'll reset it if we become the primary or
	 	   ; reconnect as a backup. If we fail to reconnect though we want
	 	   ; it clear when we reach wait so that we know to generate a message
	 	   s ^MIRROR(mirname,"Role")=""
	 	   s role=""
		   ; If we're a backup and the primary shut down then the
		   ;	 remaining backups want to elect a new primary. Before starting
		   ; that process we need to figure out whether the primary died
		   ; or whether we just lost our connection.
		   s state=$SYSTEM.Mirror.GetInfo()
		   s dejrninfo=$SYSTEM.Mirror.GetInfo(2)  ;save info cleared by ResetBackup()
		   do $SYSTEM.Mirror.ResetBackup() ;clears BACKUP sets RESTART status
		   if (reason = 5) {
			   if '$G(^SYS("MIRRORSET")) {
				   s cls=##class(Config.MirrorMember).Open(,,.rc)
				   if (''rc) {
					   s cls.ValidatedMember = 0
					   s rc = cls.%Save()
					   if ('rc) {
						   d $zu(9,"","("_mirname_") ERROR: Failed to clear ValidatedMember: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					   }
				   }
			   }
			   d $zu(9,"","("_mirname_"): Primary removed this member from its mirror configuration",1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"Status","MGR") = "Exit"
			   goto waitnext
		   }
		   ; We use the stored dejournal checkpoint when calling ApplyJournalFiles
		   ; but it may be behind if the dejournal job did not update it as it exited.
		   ; Lookup the current value in memory and publish it before we might return
		   ; to restart.
		   s chkpntjrncnt=$P(dejrninfo,",",6)
		   s chkpntjrnpos=$P(dejrninfo,",",7)
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Set last checkpoint to "_chkpntjrncnt_", "_chkpntjrnpos)
		   if chkpntjrncnt s (^MIRROR(mirname,"dejrnchkpnt"),^MIRROR(mirname,"firstdejrnchkpnt"))=chkpntjrncnt_"^"_chkpntjrnpos
		   if reportingNode {
			  ; Note that non-failover nodes always take this pathway
			  ; because they are never considered active by the primary.
			  s ^MIRROR(mirname,"State")="Restarting"
			  goto Restart
		   }
		   if (reason = 4) {
			   d SynchConfigWithPrimary^MIRRORCOMM(mirname,1)
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateFailoverPartner("""""_mirname_""""") }"", .rc)","Restart","UseSSL updated in primary")
			   goto wait
		   }
		   if state'["BACKUP" {
			  ; ouch we thought we were a backup but we weren't.
			  s role=""
	    	  d $zu(9,"","("_mirname_") ERROR: Non Backup is down (node #"_id_")",1 /* broadcast and log message*/,2  /* Severe error */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;probably already clear in this case
			  goto Restart
		   }
	   	   s logSevereFailureMessage=1  ;post a SevereMsg if we fail to become primary
	   	   s wasBackup=1  ;the message will say we failed to become the primary
	 	   s OrigECPRecoveryTimeout = $SYSTEM.ECP.GetProperty("ECPRecoveryTimout")
	 	   if OrigECPRecoveryTimeout<60 d $SYSTEM.ECP.SetProperty("ECPRecoveryTimout",60)
	 	   s resolved=""
	 	   s rawactivebackupflag=$SYSTEM.Mirror.ActiveBackupFlag(-1)
		   if rawactivebackupflag=0 {
		      ; if we weren't considered an active backup at the time 
			  ; of the failure then go back to the top. We may become the
			  ; primary but 1st we need to get more journal data.
	    	  d $zu(9,"","("_mirname_") Non-active Backup is down (node #"_id_")",0,0  /* Informational message */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;almost certainly already clear
		 	  s failoverRule=$SYSTEM.Mirror.FailoverRule()
   			  if failoverRule=1 {
			     do $SYSTEM.Mirror.FailoverRule(2)
	   			 if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Non active backup switched to agent contact mode before restarting")
   			  }
			  goto Restart
		   }
			if rawactivebackupflag=2 {
				if reason = 6 {
					d $zu(9,"","Backup taking over due to clean shutdown of primary",0,0  /* Informational message */)
				} else {
					d $zu(9,"","Backup taking over for primary in permanent trouble",0,0  /* Informational message */)
				}
				s (forced,svrfilecnt)=0
				goto checkJournalData
			}
		    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    	    if info="" {
	    	   ; this shouldn't ever happen
	    	   d $zu(9,"","("_mirname_") ERROR: Missing configuration information old primary (node #"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;don't restart w/out talking with other instance
	    	   goto Restart
    	   }
		   if '$$BackupWaitForArbiterChange(mirname) {
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) 
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Restarting: BackupWaitForArbiterChange signaled failure")
			   goto Restart
		   }
    	   s failoverRule=$SYSTEM.Mirror.FailoverRule()
    	   if failoverRule=1 {
	    	   s arbiterState=$SYSTEM.Mirror.ArbiterState()
	    	   if '$ZB(+arbiterState,+2,1) {
		    	   ; we lost our arbiter connection, reset
			   	   do $SYSTEM.Mirror.ActiveBackupFlag(0) 
			   	   do $SYSTEM.Mirror.FailoverRule(2)
				   d $zu(9,"","Backup switched from Arbiter Controlled failover mode to Agent Controlled due to lost arbiter connection - lost arbiter connection",0,0  /* Informational message */)
		    	   goto Restart
	    	   }
			   if $ZB(+arbiterState,+4,1) {
				   ; primary still has its arbiter connection!
				   d $zu(9,"","Backup found primary still connected to the arbiter unexpectedly and won't become primary",1 /* broadcast and log message*/,1  /* Warning */)
				   do $SYSTEM.Mirror.ActiveBackupFlag(0)
				   goto Restart
			   }
			   s forced=0 
			   s svrfilecnt=0 ; we will mark journal end as valid w/out checking it
			   do $SYSTEM.Mirror.ActiveBackupFlag(1)
			   d $zu(9,"","Backup taking over for primary in arbiter controlled mode",0,0  /* Informational message */)
			   goto checkJournalData
    	   }
	       s name=$lg(info,1)
	       s rc=$$GetStatus^MIRRORCTL(mirname,id)
           s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
		   if status="ERR" {
           	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Old primary reports ERR - fetching new status")
			   h 1
			   s rc=$$GetStatus^MIRRORCTL(mirname,id)
			   s status=$LG(rc)  
			   if status="ERR" {
				   d $zu(9,"","Error fetching status of "_name_" in "_mirname_": "_$LG(rc,3),1 /* broadcast and log message*/,1  /* Warning */)		
				   s ^MIRROR(mirname,"State")="Restarting"
				   goto Restart
			   }
			   ; keep going now that status is not ERR
		   }
           if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Old primary reports status: "_status_", filecnt="_$LG(rc,2)_", code="_$lg(rc,3))
           if status="PRIMARY" {
	           d $zu(9,"","("_mirname_") Lost connection to node "_name_" (#"_id_") which reports it is still the primary",1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   if $SYSTEM.Mirror.ActiveBackupFlag() {
				   ; Just a sanity check, this shouldn't be set
				   d $zu(9,"","ActiveBackupFlag found set when other instance reports it is still the primary",1 /* broadcast and log message*/,2  /* Severe error */)
			   }
			   do $SYSTEM.Mirror.ActiveBackupFlag(0)
	           goto Restart
           }
           if (status="HUNG") {
	          ;If the primary is hung we need to force it down. If we get an
	          ; OK back from the force then the force code declared a permenant
	          ; trouble state so we know the other node won't do any more 
	          ; "mirror work" even if the force doesn't shut it down for
	          ; some reason.
			  s lastjrninfo=$$GetDejrnChkpntInfo(mirname)  ;returns cnt^pos
			  if '+lastjrninfo {
				  s lastjrnfilecnt=0
				  s lastjrnend=0  ;no journal files yet	
			  } else {
				  s lastjrnend=+$P(lastjrninfo,"^",2)
				  s lastjrnfilecnt=+lastjrninfo
			  }
			  if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
				  d $zu(9,"","Backup found primary is hung but takover is blocked because the backup missing one or more required databases",1 /* broadcast and log message*/,2  /* Severe error */)
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckRequiredDatabases("""""_mirname_""""","_lastjrnfilecnt_","_lastjrnend_") }"", .rc)","Restart","Cannot become primary because one or more required databases are missing")
			      goto Restart
			  }
			  if $$CheckDefinedPrimary(1)'=1 {
				  d $zu(9,"","Backup found primary is hung but takover is blocked because 'No Failover' is set",1 /* broadcast and log message*/,2  /* Severe error */)
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","Failed to locate current primary")
			      goto Restart
			  }
	          d $zu(9,"","("_mirname_") Forcing down failed primary, node "_name_" (#"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
		      s status=$$ForceNodeDown^MIRRORCTL(mirname,id,$s(reason=1:0,1:1))
		      if $LG(status)'="OK" {
			      d $zu(9,"","Failed to force down failed primary ("_name_"). Reason: "_$LG(status,2),1 /* broadcast and log message*/,1  /* Warning */)
			      ; This is pretty unusual, we're not sure what state the 
			      ; other node is in so its best if we don't take over without
			      ; talking to it and confirming that it isn't still the primary
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      goto Restart
		      }
		      if $LL(status)=1 {
			      d $zu(9,"","Forced down older primary ("_name_") - Must contact old primary to determine current journal file",0,0  /* Informational message */)
			      ; This is pretty unusual, we're not sure what state the 
			      ; other node is in so its best if we don't take over without
			      ; talking to it and confirming that it isn't still the primary
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      goto Restart
		      }
			  s svrfilecnt=$LG(status,2)
			  s svrfileoff=$LG(status,3)
			  ; We can take over without talking with the other node if we have
			  ; the journal point which the server said was current at the time
			  ; the trouble condition was declared by the cforce.
			  s forced=1
			  goto checkJournalData
           }
           s forced=0  ;JO2559
           s svrfilecnt=$LG(rc,2)
           if status="TIMEOUT" {
			   d $zu(9,"","("_mirname_") Failed to contact agent on former primary, can't take over",1 /* broadcast and log message*/,1  /* Warning */)
			   ;s ^MIRROR(mirname,"State")="Restarting"
			   goto Restart
           }
           ;
		   if status'="DOWN" {
			   d $zu(9,"","Old primary reports """_status_""" not ""DOWN"" - Cannot take over",1 /* broadcast and log message*/,1  /* Warning */)
			   goto Restart
		   }
		   if $$TroubleTimeExpired() {
			   goto Restart
		   }
		   d $zu(9,"","("_mirname_") Agent on active backup reported old primary down within trouble period - Ok to become new primary",0,0  /* Informational message */)
		   do $SYSTEM.Mirror.ActiveBackupFlag(1)
           if "UP/DOWN/TIMEOUT"'[status {
			   d $zu(9,"","Expected status to be one of UP, DOWN or TIMEOUT, got """_status_""" - Cannot take over",1 /* broadcast and log message*/,1  /* Warning */)
			   goto Restart
           }
           ;
checkJournalData ;JO2559           
		   s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		   if +rc=-1 {
		      ; This is an error reading the log file other than the log file
		      ; doesn't exist. This shouldn't happen. 
		      d $zu(9,"","("_mirname_") Take over failed, failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,2  /* Severe error */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
		      goto Restart
		   }
		   if +rc=0 {
	          d $zu(9,"","("_mirname_") Take over failed, failed to open mirror journal file to lookup last journal file",1 /* broadcast and log message*/,2  /* Severe error */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
	          goto Restart
		   }
		   s jrnfilecnt=+rc    ;1st piece = jrnfilecnt
		   s jrnfile=$P(rc,",",2)  ; 2nd piece = jrnfilename
		   if $SYSTEM.Mirror.LastFileValidFlag() {
			   ; If the active backup marked the file as valid because the primary
			   ; exited due to a permenant trouble state, then skip to setting up
			   ; the globals and return to Restart so we can take over
 			   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","File already marked valid, skipping to JournalDataOk")
 			   goto JournalDataOk
		   }
		   if +svrfilecnt,+svrfilecnt'=jrnfilecnt {
			   ; The GetStatus message included the last journal file the primary
			   ; was writing and this is different (presumably beyond) our journal
			   ; file. Return to the top so we retrieve whatever we're missing before
			   ; becoming the primary
	           d $zu(9,"","("_mirname_") Take over failed: The failed primary reports last journal file is #"_svrfilecnt_" but the local last file is #"_jrnfilecnt,1 /* broadcast and log message*/,2  /* Severe error */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
	           goto Restart
		   }
		   if (forced) {
			   s fd=$zu(78,5,jrnfile,0)
			   if fd<0 {
				   d $zu(9,"","("_mirname_") Take over failed: failed to open "_jrnfile_" to validate the end after a force ("_svrfileoff_")",1 /* broadcast and log message*/,1  /* Warning */)
				   s ^MIRROR(mirname,"State")="Restarting"
				   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
				   goto Restart
			   }
			   do $zu(78,6,fd)
			   s endoff=+$zu(78,18,0)
			   do $zu(78,7,fd)
			   if endoff<svrfileoff {
				   d $zu(9,"","Local copy of "_jrnfile_" requires more data (end reported by primary = "_svrfileoff_"). Must contact old primary before continuing",0,0  /* Informational message */)
				   s ^MIRROR(mirname,"State")="Restarting"
				   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
				   goto Restart
			   }
			   d $zu(9,"","Node eligible to take over after force: Local copy of "_jrnfile_" contains end reported by primary ("_svrfileoff_")",0,0  /* Informational message */)
			   do $SYSTEM.Mirror.ActiveBackupFlag(1)
		   }
		   if '$SYSTEM.Mirror.ActiveBackupFlag() {
			   goto Restart
		   }
           s rc=$SYSTEM.Mirror.MarkJournalFileEndValid(jrnfile)
           if '+rc {
	           d $zu(9,"","("_mirname_") Take over failed, failed to mark end of "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
	           goto Restart
           }
JournalDataOk ;
		   s ^MIRROR(mirname,"lastvalidjrnfile")=jrnfilecnt_"^"_jrnfile 
           do $SYSTEM.Mirror.LastFileValidFlag(1)  ;set flag in case its not set yet
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Set last valid file to "_jrnfile_" (#"_jrnfilecnt_")")
           ; Ok, we're ready to become the primary (assuming that's
           ; ok with the other backups). If the primary is up, try and
           ; kill it.
           ;
           ; we can become the primary now since our journal file is
           ; up to date. restart will negotiate with the other backup,
           ; if there is one, who should be the primary
		   s ^MIRROR(mirname,"State")="Restarting"
		   if $zb($g(^MIRROR(mirname,"Features",id),0),1,1) {
			   s NeedProgagateData=0
		   } else {
			   s NeedProgagateData=2
		   }
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Set dejrn checkpoint to offset "_chkpntjrnpos_" in mirror journal file #"_chkpntjrncnt)
		   goto Restart
		} elseif role="PRIMARY" {
			; We're the primary and a connection to a backup node exited.
			; It could be that the backup shut down and we're still the
			; primary or it could be our side of the connection died. If
			; we're shutting down role would be "Paused" so we know that's
			; not the case here. If we're in arbiter controlled mode then 
			; we need to ask the backup via the arbiter channel to switch
			; to agent controlled mode. Other than that, we log a message and
			; wait to see what happens (the trouble time out may expire, we
			; may get forced down by the backup, the data channel might
			; be rebuilt).
			s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
			if info'="" {
				Set $list(info,10)=0
				s ^SYS("MIRRORSET",mirname,"Member",id)=info
				if $LG(info,8)=0 {
					s failoverRule=$SYSTEM.Mirror.FailoverRule()
					if failoverRule=1 {
						s arbiterPid=$G(^MIRROR(mirname,"Arbiter","pid"),"")
						if arbiterPid="" {
							d $zu(9,"","Cannot locate arbiter pid to signal lost backup connection",1 /* broadcast and log message*/,1  /* Warning */)
						} else {
							do $SYSTEM.Event.Signal(arbiterPid,$LB("BackupConnectionLost"))
							if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Signaled arbiter (pid: "_arbiterPid_") lost data channel to backup")
						}
					}
				}
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Connection to member #"_id_" exited for reason #"_reason) 
		} elseif (role="BACKUP"&&'cliexit) {
			s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
			if info'="" {
				Set $list(info,10)=0
				s ^SYS("MIRRORSET",mirname,"Member",id)=info
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Connection to async member node #"_id_" exited for reason #"_reason) 
		} else {
			; I don't think we should get down messages if we're not
			; activly involved in the mirror (primary/backup).
		    d $zu(9,"","MIRRORSVR: Message /"_text_"/ recived from "_id_" but current role is: "_role,0,0  /* Informational message */)
		}
		goto waitnext
	}
	if $E(text,1,6)="BACKUP" {
		s state=$SYSTEM.Mirror.GetInfo()
		if state["BACKUP" {
			s rc=$SYSTEM.Mirror.BackupStartupAbort()
			if 'rc {
				d $zu(9,"","Failed to abort backup startup - Node may fail to reconnect",1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		s rest=$E(text,7,*)
		s rest=$P(rest,":")
		if rest="RESET" {
			; some unexpected error occured in Backup^MIRRORCOMM that we
			; should have caught here before we ever tried to become a backup.
			; Start over at reinit and hopefull we catch it this time.
			goto reinit
		}
		if rest="RESTART" {
			; Something changed and we should restart from the top and
			; presumably something different will happen this time.
		    goto Restart
		}
		if rest="CONNECTFAILED" {
			; id here is the system we were trying to connect to.
			; This is posted by Backup^MIRRORCOMM
	        s ok=$$TrackReconnections(mirname,id,.ConnectHistory)
	        if 'ok {
	           do AddRetryEntry(mirname,"(""(ConnectHistory, rc) { s rc=$$TrackReconnections("""""_mirname_""""","_id_",.ConnectHistory) }"", .ConnectHistory, .rc)","Restart","Failed to build a connection")
	        }
	        goto Restart
	    }
		d $zu(9,"","Ignored unrecognized BACKUP event /"_text_"/",0,0  /* Informational message */)
		goto waitnext
	}
	if $E(text,1,9)="SHUTDOWN:" {
		; These are sent from SHUTDOWN. There are 2 messages, SHUTDOWN:SUSPEND
		; and SHUTDOWN:EXIT. SUSPEND is set when SHUTDOWN doesn't want us to talk
		; to other systems any more (tell them we're the primary) and :EXIT is sent
		; when we should terminate, after $SYSTEM.Mirror.Shutdown() has returned.
		s text=$E(text,10,$L(text))
		if text="SUSPEND" {
			; If we set our role to pause we'll stop answering
			; "START" messages
			s delVIP=(role="PRIMARY")
		    s role="Pause"  /* Stop sending messages to other systems */
		    if delVIP set ok=$$DeleteVirtualAddress(mirname)
		}
		if text="EXIT" {
			s ^MIRROR(mirname,"Status","MGR")="Exit"
		}
		do ClearRetryList(mirname)  ;if there's a retry list, reset it now
		goto waitnext
	}
	if $E(text,1,10)="ADDMEMBER:" {
		s cur=$ZU(190,13)  ;wdpass,wdqsize,wdwritesiz
		do $ZU(51,1) ;wake wd
		s wdpass=+cur
		s reqpass=wdpass+2
		do {
		   hang 1
		   do $ZU(51,1)
		   s cur=$ZU(190,13)
		   s wdpass=+cur
		   s blks=$P(cur,",",2)+$P(cur,",",3)
		} while (blks && (wdpass <= reqpass))
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		d NotifyAsyncMembers(mirname,id,0)
		s status=$SYSTEM.Mirror.GetInfo()
		if (role'="PRIMARY") && (role '= "BACKUP") {
		   ; A new node was added and we're not the primary nor
		   ; a backup. We should restart at Restart to see if we should
		   ; change our role. Presumably there is already something posted
		   ; to the retry list, but if not, add one.
		   s ^MIRROR(mirname,"State")="Restarting"
		   goto Restart
		}		
		goto waitnext
	}
	if $E(text,1,10)="DELMEMBER:" {
		s cur=$ZU(190,13)  ;wdpass,wdqsize,wdwritesiz
		do $ZU(51,1) ;wake wd
		s wdpass=+cur
		s reqpass=wdpass+2
		do {
		   hang 1
		   do $ZU(51,1)
		   s cur=$ZU(190,13)
		   s wdpass=+cur
		   s blks=$P(cur,",",2)+$P(cur,",",3)
		} while (blks && (wdpass <= reqpass))
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		s id=$p(text,":",2)
		d NotifyAsyncMembers(mirname,id,1)
		s status=$SYSTEM.Mirror.GetInfo()
		if (role'="PRIMARY") && (role '= "BACKUP") {
		   ; A new node was deleted and we're not the primary nor
		   ; a backup. We should restart at Restart to see if we should
		   ; change our role. Presumably there is already something posted
		   ; to the retry list, but if not, add one.
		   s ^MIRROR(mirname,"State")="Restarting"
		   goto Restart
		}		
		goto waitnext
	}
	if $E(text,1,14)="CLRDEFPRIMARY:" {
		; Ignore this message. It should be removed. We needed it
		; before the retry code to get the node to re-test whether it
		; should become the primary
		goto waitnext
	}
	if $e(text,1,12)="UPDATEIPADDR" {
		If ($zversion(1)=3) {
			s cur=$ZU(190,13)  ;wdpass,wdqsize,wdwritesiz
			do $ZU(51,1) ;wake wd
			s wdpass=+cur
			s reqpass=wdpass+2
			do {
				hang 1
				do $ZU(51,1)
				s cur=$ZU(190,13)
				s wdpass=+cur
				s blks=$P(cur,",",2)+$P(cur,",",3)
			} while (blks && (wdpass <= reqpass))
		}
		s oip=$p(text,",",2),oiface=$p(text,",",3)
		s nip=$p(text,",",4)
		if (oip'=""||(oiface'="")) {
			s ok=$$DeleteVirtualAddress(mirname,oip,0,oiface)
			if '$lg(ok) {
				d $zu(9,"","Could not delete virtual address ip="_$s(oip="":$G(^SYS("MIRRORSET",mirname,"VirtualAddress")),1:oip)_" iface="_$s(oiface="":$G(^SYS("MIRRORSET","%VIPInterface")),1:oiface)_" - IP address update failed",1 /* broadcast and log message*/,1  /* Warning */)
			}	
		}
		s ok=$$AddVirtualAddress(mirname,nip,0)
		if '$lg(ok) {
			d $zu(9,"","Could not add virtual address ip="_$s(nip="":$G(^SYS("MIRRORSET",mirname,"VirtualAddress")),1:nip)_" iface="_$G(^SYS("MIRRORSET","%VIPInterface"))_" - IP address update failed, error="_$p($lg(ok),",",2,999),1 /* broadcast and log message*/,1  /* Warning */)	
		} else {
			s ^||FirstVIPMonitor=1
		}
		if $SYSTEM.Mirror.IsPrimary() d NotifyAsyncMembers(mirname,"",1)
		goto waitnext
	}
	if $E(text,1,10)="SENDDBINFO" {
		s dbname=$P(text,":",2)
		s expectedguid=$P(text,":",3)
		s fulldbname=":mirror:"_mirname_":"_dbname
		s info=$SYSTEM.Mirror.GetNextDBBySFN(0)
		while +info'=-1 {
			s dbname=$P(info,"^",2)
			quit:dbname=fulldbname
			s info=$SYSTEM.Mirror.GetNextDBBySFN(+info)
		}
		if +info=-1 {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Received SENDDBINFO message for unknown database: """_dbname_""" ("_expectedguid_")")
			goto waitnext
		}
		s sfn=$P(info,"^",4)
		if sfn=$zu(40,0,41) {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","SENDDBINFO message for dismounted database """_dbname_""" ignored")
			goto waitnext
		}
		s fullinfo=$SYSTEM.Mirror.DBGetInfo(0,sfn)
		s dbguid=$P(fullinfo,"^",6)
		if dbguid'=expectedguid {
			d $zu(9,"","In SENDDBINFO found "_dbguid_" for mirrored db """_dbname_""". Expected "_expectedguid,1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			do $SYSTEM.Mirror.SendDBInfo(sfn)
		}
		goto waitnext
	}
	if $E(text,1,11)="NEWFOMEMBER" {
		s idx=$P(text,":",2)
		s md=$LG($P(text,":",3,9999))
		if idx'=($G(^SYS("MIRRORSET",mirname,"Member"))) {
			d $zu(9,"","NEWFOMEMBER: mis-match index idx="_idx_" member "_$G(^SYS("MIRRORSET",mirname,"Member")),1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		s mobj=##Class(Config.MapMirrors).%New()
		if '$isobject(mobj) {
			d $zu(9,"","NEWFOMEMBER: Config.MapMirror.%New failed",1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		s mobj.ID = mirname
		s mobj.Name = $LG(md,1)
		s mobj.GUID = $LG(md,2)
		s mobj.AgentAddress = $p($LG(md,5),"|")
		s mobj.AgentPort = $p($LG(md,5),"|",2)
		s mobj.ECPAddress = $p($LG(md,3),"|")
		s mobj.MirrorAddress = $p($LG(md,4),"|")
		s mobj.MirrorSSPort = $p($LG(md,4),"|",2)
		s mobj.InstanceDirectory = $LG(md,6)
		s mobj.SSLComputerName = $LG(md,7)
		s mobj.MemberType = +$LG(md,8)
		s mobj.ConnectsTo = $LG(md,9)
		s rc=mobj.%Save()
		if ('rc) {
			s mobj=""
			k err
			Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
			d $zu(9,"","NEWFOMEMBER: add new failover member idx="_idx_" error="_$g(err(1)),1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		s mobj=""
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
		goto waitnext
	}
	if $E(text,1,11)="DELFOMEMBER" {
		s membername=$P(text,":",2),mcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if mcnt'=2&&($SYSTEM.Mirror.GetInfo()'["PRIMARY") {
			d $zu(9,"","DELFOMEMBER: Could not delete the only failover mirror member "_membername,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		if $e(membername,*)=$c(0) {
			s membername=$e(membername,1,*-1)
			s newtype=0
		} else {
			s newtype=2
		}
		s found=0
		f idx=1:1:mcnt i membername=$LG($G(^SYS("MIRRORSET",mirname,"Member",idx))) s found=1 q
		if 'found {
			d $zu(9,"","DELFOMEMBER: Could not find mirror member "_membername,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		if $SYSTEM.Mirror.IsPrimary() {
			k props s props("MemberType")=newtype
			s rc=##class(Config.MapMirrors).Modify(mirname,membername,.props)
			if ('rc) {
				d $zu(9,"","DELFOMEMBER: failed to demote failover to async for index="_idx,1 /* broadcast and log message*/,1  /* Warning */)
				goto waitnext
			}
			s systemcnt=^SYS("MIRRORSET",mirname,"Member")
			d NotifyAsyncMembers(mirname,membername,1)
		} else {
			s rc=##class(Config.MapMirrors).Delete(mirname,membername)
			if ('rc) {
				d $zu(9,"","DELFOMEMBER: failed to delete failover for index="_idx,1 /* broadcast and log message*/,1  /* Warning */)
				goto waitnext
			}
			s systemcnt=^SYS("MIRRORSET",mirname,"Member")
		}
		goto waitnext
	}
    if $e(text,1,12)="ForcePrimary" {
	   if role="Pause"  /* Stop sending messages to other systems */ {
	      d $zu(9,"","ForcePrimary message ignored - node is shutting down",1 /* broadcast and log message*/,1  /* Warning */)
  	   } elseif role="BACKUP" {
          ; This shouldn't happen because DesignatePrimary forces
          ; the primary down before sending the ForcePrimary message
          ; so we shouldn't be connected right now. If we are just abort.
         d $zu(9,"","ForcePrimary message rejected - Node is currently a backup member",1 /* broadcast and log message*/,1  /* Warning */)
       } elseif role="PRIMARY" {
	      ; If we forced down the other node and sent a ForcePrimary message
	      ; then its possible we're already the primary in which caes we
	      ; just ignore this.
	      if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Current primary ignored ForcePrimary message")
       } else {
	      ; Setting forceBecomePrimary causes the routine which
	      ; marks journal files as valid to go ahead and use the
	      ; current end of the file as the valid end if the other node 
	      ; can't be contacted.
	      s forceBecomePrimary=1
	      do ClearRetryList(mirname)  ;if there's a retry list, reset it
	      if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Setting forceBecomePrimary flag and returning to restart")
	      goto Restart
       }
	   goto waitnext
    }
	if $E(text,1,8)="PROMOTE:" {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
		s sysname=$p(text,":",2,999)
		s found=0
		f idx=1:1:systemcnt i sysname=$LG($G(^SYS("MIRRORSET",mirname,"Member",idx))) s found=1 q
		if 'found {
			d $zu(9,"","PROMOTE: Could not find mirror member "_sysname,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		d NotifyAsyncMembers(mirname,idx,0)
		goto waitnext
	}
	if $E(text,1,12)="SYNCHCONFIG:" {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
		s primary=$p(text,":",2,999)
		s found=0
		f idx=1:1:systemcnt i primary=$LG($G(^SYS("MIRRORSET",mirname,"Member",idx))) s found=1 q
		if 'found {
			d $zu(9,"","SYNCHCONFIG: Could not find primary mirror member "_primary,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		d SynchConfigWithPrimary^MIRRORCOMM(mirname,idx)
		goto waitnext
	}
	if $E(text,1,8)="UPDATEDN" {
		s sysname=$p(text,":",2)
		s DN=$p(text,":",3,9999)
		s cls=##class(Config.MapMirrors).Open(mirname,sysname)  ;open primary's configuration
		if '$IsObject(cls) {
			d $zu(9,"","UPDATEDN Event: Failed to open Config.MapMembers("_mirname_","_sysname_")",1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			set cls.SSLComputerName = DN
			s rc=cls.%Save()
			if (''rc) {
				if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","UPDATEDN Event: updated DN of "_sysname_" with "_DN)
			} else {
				d $zu(9,"","UPDATEDN Event: Failed to save Config.MapMembers("_mirname_","_sysname_") Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		goto waitnext
	}
	if $E(text,1,14)="NOTIFYMEMBERS:" {
		if $SYSTEM.Mirror.IsPrimary() d NotifyAsyncMembers(mirname,id,1)
		goto waitnext
	}
	if $E(text,1,13)="PURGEJOURNAL:" {
		d PURGE^JRNUTIL
		goto waitnext
	}
	if $E(text,1,13)="NOTIFYBACKUP:" {
		if ##class(EMS.Instance).IsManaged("Config.Mirrors") goto waitnext
		if $SYSTEM.Mirror.IsPrimary(),systemcnt>0 {
			s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
			if (+$LG(info,10)) {
				s rc=$$NotifyMirrorChange^MIRRORCTL(mirname,1,$LG($G(^SYS("MIRRORSET",mirname,"Member",0))))
				if $LG(rc)'="OK" d $zu(9,"","NOTIFYBACKUP event: NotifyMirrorChange failed with "_$LG(rc)_","_$LG(rc,2),1 /* broadcast and log message*/,2  /* Severe error */)
			}
		}
		goto waitnext
	}
	if $E(text,1,17)="ASYNCTYPECHANGED:" {
		if ##class(EMS.Instance).IsManaged("Config.Mirrors") goto waitnext
		s primaryid=1
		if systemcnt>1 {
			s primaryid=$$GetCurrentPrimaryID(mirname)
			if primaryid<0 goto waitnext
		}
		s rc=$$NotifyAsyncTypeChanged^MIRRORCTL(mirname,primaryid,$LG($G(^SYS("MIRRORSET",mirname,"Member",0))),id)
		if $LG(rc)'="OK" if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","ASYNCTYPECHANGED event: NotifyAsyncTypeChanged failed with "_$LG(rc)_","_$LG(rc,2))
		goto waitnext
	}
	; error case (text="ERR")
	goto waitnext	
UNKNOWN ;
	d $zu(9,"","MIRRORSVR found unknown message on queue: "_keyword_" from "_id_" ("_text_")",1 /* broadcast and log message*/,1  /* Warning */)
	goto waitnext
REQMSG ;
	; Come here to process REQ messages
	if $e(text,1,10)="ASYNCDONE:" {
		if +$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))'=0 goto waitnext
		s jrnfilecnt=+$E(text,11,*)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Dejournaling complete for mirror: "_mirname_", file #"_jrnfilecnt_" - Queuing to be deleted")
		; Post this to the list of files which can be purged
		s ^MIRROR(mirname,"PendingPurgeList",jrnfilecnt)=""
		goto waitnext
	}
	d $zu(9,"","MIRRORSVR received unknown REQ msg: from "_id_" ("_text_")",1 /* broadcast and log message*/,1  /* Warning */)
	goto waitnext	
}  ;End of Start()
 /* TroubleTimeExpired() 
       1 -> the trouble timelimit has expired so the backup can't be 
	        sure that the end of the file which it has is valid 
	   0 -> the trouble timelimit hasn't expired so if the backup knows
    		the primary is down, it can mark the end of its journal file
    		as valid and try to become the primary 
 */
TroubleTimeExpired() {
	s rc=$SYSTEM.Mirror.TroubleTimeoutExpired()
	;rc=success/fail,timeout(msec),endtime(usec),starttime(usec)
	s tout=+$P(rc,",",2)/1000  ;msec->sec
	s elapsed=($P(rc,",",3)-$P(rc,",",4))/1000000  ;usec->sec
	s elapsed=$FN(elapsed,"",3)  ;3digits = msec
	;
	if +rc {
	   d $zu(9,"","Mirror recovery time of "_elapsed_" seconds exceeded trouble timeout of "_tout_" seconds. Restarting",0,0  /* Informational message */)
	   quit 1  ;timeout expired
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Mirror recovery time of "_elapsed_" seconds is within trouble timeout of "_tout_" seconds - Continuing")
	quit 0  ;not expired
}
 /* BackupWaitForArbiterChange() 
    When MIRDOWN is called because the data channel on the backup
    is lost and we're in arbiter mode and both arbiter connections
    exist we come here to wait for something to change. At the
    expiration of the mirrortimeout (worst case) we expect either one
    or both arbiter connections will be dropped or we'll switch to 
    agent controlled mode (if the primary can talk to us over the
    arbiter channel).  If we wait here for twice the mirror timeout
    we assume something has gone wrong and we clear the ActiveBackup
    flag so we can't take over without talking to the primary.
       1 -> We can continue with failover in mirdown. Either we're 
            now in agent contact mode or one or both of the arbiter
            connections has gone down
	   0 -> ActiveBackupFlag has been cleared and we should contact
	        the agent on the other member to find out what to do
 */
BackupWaitForArbiterChange(mirname) {
	s $zt="err"
top ;
	s failoverRule=$SYSTEM.Mirror.FailoverRule()
   	if failoverRule'=1 {
		quit 1
   	}
	s arbiterState=$SYSTEM.Mirror.ArbiterState()
	s bits=2+4
	if ($ZB(+arbiterState,+bits,1)'=bits) {
		quit 1  ; one of the nodes disconnected
	}
	s rc=$SYSTEM.Mirror.TroubleTimeoutExpired()
	;rc=success/fail,timeout(msec),endtime(usec),starttime(usec)
	s tout=+$P(rc,",",2)/1000  ;msec->sec
	s elapsed=($P(rc,",",3)-$P(rc,",",4))/1000000  ;usec->sec
	if rc {
	    d $zu(9,"","Mirror wait time of "_elapsed_" seconds in Arbiter Controlled mode with both connections up exceeded trouble timeout of "_tout_" seconds. Clearing ActiveBackup state and restarting",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s rc=$$MonitorArbiterConnection^MIRRORCOMM(mirname)
	hang 1
	goto top
err ;
	s $zt=""
	d $zu(9,"","BackupWaitForArbiterChange caught "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
	d BACK^%ETN
	quit 0 
}
 /* AsyncJrnfilePurge()
    Called to check the list of mirror journal files queued to
         ^MIRROR(<mirname>,"PendingPurgeList",<mirjrnfile count 1>)
         ^MIRROR(<mirname>,"PendingPurgeList",<mirjrnfile count 2>)
         .
         .
         .
         ^MIRROR(<mirname>,"PendingPurgeList",<mirjrnfile count n>)
    to see if they can be purged. The files can be purged when they are
    no longer required for transaction rollback. 
    When the dejournaling reader finishes with a journal file on an
    async member it sends a REQ+ASYNCDONE message to the MIRRORMGR process
    on the machine via $SYSTEM.Event.Signal(). The MIRRORMGR process then
    issues a set to add an entry to the PurgeList. In the idle loop (at waitloop)
    any time there's an entry in the list, this routine is called...as
    the journal files are purged, they are removed from the list.
 */
AsyncJrnfilePurge(mirname) [PUBLIC] {
    ; Get the transaction rollback point for the databases which
    ; are part of this mirror
	s mindbinfo=$$GetMinDBJrnInfo^MIRRORMGR(mirname)
	if '$LG(mindbinfo) {
	   s txt=$LG(mindbinfo,2)
	   k err
	   Do DecomposeStatus^%apiOBJ(txt,.err,"-d") 	
	   s msg=""
  	   for i=1:1:err s msg=msg_err(i)_". "
	   d $zu(9,"","AsyncJrnfilePurge("_mirname_") failed to read minimum db info: "_msg,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 1  ;remove retry entry
	}
	s minjrncnt=+$LG(mindbinfo,2)
	; When $LG(mindbinfo,2) and $LG(mindbinfo,3) are both 0 then
	; this system doesn't have any mirrored db's so technically it
	; doesn't require any journal files. However, someone is probably
	; going to add some soon so don't delete any files yet in case
	; they're needed. Once we get a database then we can delete any
	; files we didn't need.
	if 'minjrncnt {
		quit
	}
	;
loop ;
	s mirfilecnt=$O(^MIRROR(mirname,"PendingPurgeList",""))
	if mirfilecnt="" quit  ; nothing to do
	if minjrncnt<=mirfilecnt {
		; the minimum required file for transaction rollback is earlier
		; than the file we want to delete. Queue a retry entry and we'll
		; come back to check this later on the next cycle (this routine
		; is called from the wait loop if the list isn't empty).
	   quit
	}
	; Remove this from the list now so if we run into an error,
	; we don't retry it over and over forever
	k ^MIRROR(mirname,"PendingPurgeList",mirfilecnt)
	;
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
   	if +rc<=0 {
	   d $zu(9,"","AsyncJrnfilePurge failed ("_rc_") looking up journal file #"_mirfilecnt_" from "_mirname_" in log",1 /* broadcast and log message*/,1  /* Warning */)
	   goto loop
   	}
    s jrnfile=$P(rc,",",2)
    ; check the file size as a way to see whether it still exists
    s size=$ZU(140,1,jrnfile)  ;negative values are errors
    if size<0 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","AsyncJrnfilePurge("_mirname_") found file "_jrnfile_" (#"_mirfilecnt_") already deleted")
	   goto loop
    }
	; Great, this file is ripe and ready to be deleted
    s rc=$ZU(140,5,jrnfile)
    if rc {
      d $zu(9,"","Error ("_rc_") deleting "_jrnfile_" (file #"_mirfilecnt_" from "_mirname_") after dejournaling completed",1 /* broadcast and log message*/,1  /* Warning */)
    } else {
	  d $zu(9,"","Mirror ("_mirname_") journal file "_jrnfile_" (#"_mirfilecnt_") deleted after dejournal completed",0,0  /* Informational message */)
    }
    goto loop
}
UpdateJournalFilesSent(mirname,filesentlist) {
	s $zt="err"
	s clientcnt=$SYSTEM.Mirror.ClientQuery()
	if '$D(filesentlist) {
		s name=$O(^MIRROR(mirname,"LastJrnfileSent",""),1,val)
		while (name '= "") {
			s filecnt=$P(val,"^",2)
			s filesentlist(name)=filecnt
			s name=$O(^MIRROR(mirname,"LastJrnfileSent",name),1,val)
		}
	}
	if +clientcnt {
		for id=1:1:clientcnt {
			s info=$SYSTEM.Mirror.ClientQuery(id)
			if +info {
				s name=$P(info,",",2)
				s mirfilecnt=$P(info,",",4)
				s mirackpos=+$P(info,",",6)
				if mirackpos,$G(filesentlist(name))'=mirfilecnt {
			        s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
		   	        if +rc>0 {
			  	       s jrnfile=$P(rc,",",2)
			  	       s shortname=$p(jrnfile,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$l(jrnfile,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")))
		   	        } else {
			   	       s shortname=""
		   	        }
		   	        s str=$ZTS_"^"_mirfilecnt_"^"_shortname
		   	        s rc=$SYSTEM.Mirror.SetSystemGlobal($LB("MIRROR",mirname,"LastJrnfileSent",name),str)
					s filesentlist(name)=mirfilecnt
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Updated lastfilesent for "_name_" to "_str_$s(rc:" with JRNMIRSET record",1:""))
				}
				s checked(name)=mirfilecnt
			}
		}
	}
	s clientcnt=$SYSTEM.Mirror.ClientInfo()
	if +clientcnt {
		for id=1:1:clientcnt {
			s info=$SYSTEM.Mirror.ClientInfo(id)
			if +info {
				s name=$P(info,",",2)
				s mirfilecnt=$P(info,",",4)
				if '$d(checked(name)),mirfilecnt>$p($G(^MIRROR(mirname,"LastJrnfileSent",name)),"^",2) {
			        s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
		   	        if +rc>0 {
			  	       s jrnfile=$P(rc,",",2)
			  	       s shortname=$p(jrnfile,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$l(jrnfile,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")))
		   	        } else {
			   	       s shortname=""
		   	        }
		   	        s str=$ZTS_"^"_mirfilecnt_"^"_shortname
		   	        s rc=$SYSTEM.Mirror.SetSystemGlobal($LB("MIRROR",mirname,"LastJrnfileSent",name),str)
					s filesentlist(name)=mirfilecnt
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Updated lastfilesent from ClientInfo for "_name_" to "_str_$s(rc:" with JRNMIRSET record",1:""))
				}
			}
		}
	}
	quit
err ;
	d $zu(9,"","UpdateJournalFilesSent^MIRRORMGR: Caught error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	ztrap $ze  ;resignal error
}
LogClassError(msg,rc,logonly=1) {
	/* msg is some text message we want to display
	   $$$ISERR(rc) is true (rc is the status from a ##class()
	   logonly is 1/0 (0 = display error message on current output device)
	*/
	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	if 'logonly {
		w !,msg
		for i=1:1:err w !,?5,err(i)
	}
	d $zu(9,"",msg_$C(13,10)_"         ErrorText: "_err,1 /* broadcast and log message*/,1  /* Warning */)
}
CompareGUIDs(guid1,guid2) PUBLIC {
	/* Takes 2 GUIDs in string form and returns:
	       -1 -> first<second
	        0 -> first=second
	        1 -> first>second
	*/
	; GUID = xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxx
	s pieces=$L(guid1,"-")
	if pieces'=$L(guid2,"-") ztrap "BGUID"  ;<ZBDUI> error
	f i=1:1:pieces {
		s hex1=$P(guid1,"-",i)
		s hex2=$P(guid2,"-",i)
		q:hex1'=hex2
	}
	if hex1=hex2 quit 0  ;all pieces are equal
	s val1=+$ZH(hex1_" ")
	s val2=+$ZH(hex2_" ")
	if (val1 < val2) {
		quit -1  ;first < second
	}
	quit 1 ; first > second
}
    /* RetryCheckBecomePrimaryOK is added to the retry list in
       BecomePrimary when $$CheckBecomePrimaryOK^ZMIRROR() returns
       0. Here we retry the call to CheckBecomePrimaryOk until it
       return 1 or until we find that the other node has started up
       and is the primary */
RetryCheckBecomePrimaryOK(mirname) PUBLIC {
	try {
	   s ok=$$CheckBecomePrimaryOK^ZMIRROR()
	} catch errv {
	   if "<NOROUTINE>,<NOLINE>"[errv.Name {
		  ; we failed on a prior call so it must have existed even
		  ; though now its missing. Treat this as "OK" but log a
		  ; note in the console log.
		  d $zu(9,"",errv.Name_" calling CheckBecomePrimaryOK^ZMIRROR - assuming success",1 /* broadcast and log message*/,1  /* Warning */)
		  s ok=1
	   } else {
		  s ok=0
	   }
	}
	if ok {
		d $zu(9,"","CheckBecomePrimaryOK now reports it is ok to proceed",0,0  /* Informational message */)
		quit 1
	}
	s ok=$$CheckPrimaryIsUp(mirname)
	if ok quit 1  ;we can try to become the backup
	quit 0
}
CheckPrimaryIsUp(mirname) PUBLIC {
	/* Returns TRUE if the other node is the primary.
	   Returns FALSE if the other node is not the primary.
	   Call this when retrying some operation that blocks us
	   from becoming the primary if we want to give up if we
	   can become the backup instead 
	*/
    s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
    if systemcnt=0 {
	   quit 0  ;no other failover members
    }
    s id=1  ;this is the id of the other failover node
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
   	if info="" {
	   d $zu(9,"","CheckPrimaryIsUp missing info for node #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0  ;failed to contact it
   	}
   	s name=$lg(info,1)
   	;
   	s rc=$$GetStatus^MIRRORCTL(mirname,id)
   	s status=$LG(rc) 
   	if status="PRIMARY" {
		quit 1  ;we can try to become a backup
   	}
   	quit 0
}
RecheckArbiterControlledFailover(mirname) PUBLIC {
   /* RecheckArbiterControlledFailover returns:
        1 - Not in arbiter controlled failover mode, data channel 
            exists, or we're connected to the arbiter but the other 
            node is not - we can retry failover
        0 - continue to wait
      This is queued in the decision loop when we're in arbiter
      controlled failover mode and the data channel doesn't exist
      but either we're not connected to the arbiter or the primary
      is still connected to the arbiter. We're in a wait state until
      either we're not in arbiter controled mode any more or we're
      in a state where we can try to become the primary.
   */
   if '$SYSTEM.Mirror.ActiveBackupFlag() {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found ActiveBackupFlag cleared - continuing")
	   quit 1
   }
   if +$SYSTEM.Mirror.GetInfo(5)'=0 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found data channel up - continuing")
	   quit 1
   }
   s mode=$SYSTEM.Mirror.FailoverRule()
   if (mode'=1) {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found system in "_mode_" mode - continuing")
	   quit 1
   }
   s state=$SYSTEM.Mirror.ArbiterState()
   s mask=2+4
   s state=$zb(+state,+mask,1)  ;mask off other bits
   if state=2 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found state bits 0x"_state_" - continuing")
	   quit 1
   }
   quit 0  ;keep waiting
}
RecheckCanNodeStartToBecomePrimary(mirname) PUBLIC {
   /* RecheckIsOtherNodeDown returns:
        1 - other node is primary or CanNodeStartToBecomePrimary returns 1
        0 - continue to wait
      This entry point is added to the retry queue when 
      CanNodeStartToBecomePrimary^ZMIRROR returns failure at the top of
      BecomePrimary(). In that case the node was all ready to become the 
      primary but the user has decided that we should wait for a while.
	  We know the other node isn't the primary at this point so there must 
	  have been some other reason they aborted (eg. they may require manual 
	  intervention before a node becomes the primary).
      In any case we wait until either the other node is the primary and we
      can become the backup or CanNodeStartToBecomePrimary returns true.
    */
   try {
      s ok=$$CanNodeStartToBecomePrimary^ZMIRROR() 
   } catch except {
	  ; Since we know we succeeded in calling it once already, if we get an
	  ; error here we treat that as a failure, not a success
	  d $zu(9,"","RecheckCanNodeStartToBecomePrimary: Unexpected error ("_$ze_") calling CanNodeStartToBecomePrimary^ZMIRROR() - continuing to wait",1 /* broadcast and log message*/,1  /* Warning */)
	  s ok=0
   }
   if ok {
	   quit 1  ;we can try to become the primary again
   }
   ; If the other node is the primary, we should stop waiting and become the backup
   s rc=$$CheckPrimaryIsUp(mirname)
   quit rc
 }
CheckOtherNodeIsReachable(mirname) PUBLIC {
   /* CheckOtherNodeIsReachable returns:
        1 - other node is Reachable (agent)
        0 - we couldn't reach other node
      This is called by the retry logic when we can't contact the
      other node or if we fail in some manner which requires that
      we can reach the other node in order to recover (continue).
      This routine returns TRUE when we succesfully contact the agent
      on the other node. 
   */
   ; If there is only one node in the mirror, the other node
   ; must have been deleted
   s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
   if systemcnt=0 {
	   d $zu(9,"","Only one node remaining in mirror - OtherNodeIsReachable passes",0,0  /* Informational message */)
	   quit 1
   }
   s id=1  ;this is the id of the other failover node
   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
   if info="" {
	   d $zu(9,"","CheckOtherNodeIsReachable missing info for node #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0  ;failed to contact it
   }
   s name=$lg(info,1)
   ;
   s info=$$GetStatus^MIRRORCTL(mirname,id)
   s status=$LG(info) 
   if ((status'="TIMEOUT") && (status'="ERR")) {
	   quit 1  ;we reached the other node, execute the Restart loop
   }
   quit 0  
}
QueueCheckForDuplicatePrimary(mirname) PUBLIC {
   s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
   if systemcnt=0 {
	   quit ;only one node nothing to do
   }
   s ourinfo=$SYSTEM.Mirror.GetInfo()
   if ourinfo'["PRIMARY" {
	  ;The other node is the primary but we're not. This is ok although
	  ; it is strange that this is called while we're not the primary
      quit
   }
   s id=1  ;this is the id of the other failover node
   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
   if info="" {
	   d $zu(9,"","QueueCheckForDuplicatePrimary("_mirname_") cannot locate other failover member",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 
   }
   k ^MIRROR(mirname,"ConsoleLog","CheckForDuplicatePrimaryNetworkErr")
   s name=$lg(info,1)
   s addrlist=$$BuildAgentAddrlist^MIRRORCTL(info)  ; comma delimited list of addresses
   s basedir=$LG(info,6)
   s targguid=$LG(info,2)
   do AddMonitorEntry(mirname,"(""(rc) { s rc=$$CheckForDuplicatePrimary("""""_mirname_""""","""""_name_""""","""""_addrlist_""""","""""_targguid_""""","""""_basedir_""""") }"", .rc)")
}
CheckForDuplicatePrimary(mirname,name,addrlist,targguid,basedir) PUBLIC {
   /* CheckOtherNodeIsDown returns:
          1 - agent on other node contacted and node is not Primary
          0 - agent on other node failed to respond
      When a node becomes the primary when agent contact required is
      set to 0 (eg. $$IsOtherNodeDown^ZMIRROR() reported 1) we add
      a retry entry to call this routine where we recheck to see
      if we can contact the agent on the other node periodically. When
      we contact the agent on the other node if we find the other node
      is the primary then we declare a problem and halt the mirror.
      Otherwise we return 1 so that this entry gets removed from the
      retry list. 
   */
   s ourinfo=$SYSTEM.Mirror.GetInfo()
   if ourinfo'["PRIMARY" {
	  ;The other node is the primary but we're not. This is ok although
	  ; it is strange that this retry entry is queued while we're not
	  ; the primary
      quit 1
   }
   s rc=$$GetStatusByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir)
   s status=$LG(rc)
   if (status="TIMEOUT") || (status="ERR") {
	   quit 0
   }
   if status="HUNG" {
	   s rc=$$ForceNodeDownByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir,1)
	   d $zu(9,"","Status from forcing down old (now hung) primary ("""_name_"""): "_$$Format^%qcr(rc,1),0,0  /* Informational message */)
	   quit 1  ;other node is not the primary
   }
   if status'="PRIMARY" {
	   quit 1  ;success, other node is not the primary
   }
   if $LL(rc)>4 {
	   s remoteSystemGUID=$LG(rc,5)
	   if remoteSystemGUID=$SYSTEM.ECP.SystemGUID() {
		   if $G(^MIRROR(mirname,"ConsoleLog","CheckForDuplicatePrimaryNetworkErr"))="" {
			   s ^MIRROR(mirname,"ConsoleLog","CheckForDuplicatePrimaryNetworkErr")=1
			   d $zu(9,"","Check for duplicate primary reached local system. Ignored. Consider re-configuring mirror network addresses using numeric IP values to avoid DNS problems",0,0  /* Informational message */)
		   }
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Check for duplicate primary reached local system. Will be retried later")
		   quit 0
	   }
   }
   s failoverMode=$SYSTEM.Mirror.FailoverRule()
   if failoverMode'=3 {
	   if $LL(rc)>=3 {
		   s trouble=+$LG(rc,3)  ;3rd element is trouble flag
	   } else {
		   s trouble=1  ;assume its set
	   }
	   if trouble {
	      d $zu(9,"","Forcing down old primary ("""_name_""") which is currently in a trouble state",0,0  /* Informational message */)
	   } else {
		  d $zu(9,"","Duplicate Primary Detected: Forcing down old primary ("""_name_""") which is NOT in a trouble state",1 /* broadcast and log message*/,2  /* Severe error */)
	   }
   } else {
	   s $ZE="<ZDUPLICATE PRIMARY>"
	   d BACK^%ETN
	   d $zu(9,"","Two primaries detected in the mirror - Forcing node """_name_""" and shutting down",1 /* broadcast and log message*/,1  /* Warning */)
   }
   s status=$$ForceNodeDownByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir,1)
   if failoverMode'=3 {
	   quit 1
   }
   d $zu(9,"","Shutting down",1 /* broadcast and log message*/,1  /* Warning */)
   l  ; release all locks
   do INT^SHUTDOWN
   halt
}
RecheckRequiredDatabases(mirname,lastjrnfilecnt,lastjrnend) PUBLIC {
	/* Added to the retry list when CheckRequiredDatabases() fails.
       This returns success when either CheckRequiredDatabases
       succeeds or CheckForDuplicatePrimary() is true
    */
    if $$CheckRequiredDatabases^MIRRORCOMM(0,lastjrnfilecnt,lastjrnend) {
	    quit 1
    }
	s ok=$$CheckPrimaryIsUp(mirname)
	if ok quit 1  ;we can try to become the backup
	d $zu(9,"","Required Database checks still failing, waiting for primary to start",1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
ReCheckDefinedPrimary(mirname) PUBLIC {
	/* Added to the retry list when CheckRequiredDatabases() fails.
       This returns success when either CheckRequiredDatabases
       succeeds or CheckForDuplicatePrimary() is true
    */
    if $$CheckDefinedPrimary(1)=1 {
	    quit 1
    }
	s ok=$$CheckPrimaryIsUp(mirname)
	if ok quit 1  ;we can try to become the backup
	d $zu(9,"","'No Failover' checks still failing, waiting for primary to start",1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
AddRetryEntry(mirname,cmd,tag,reasonMSG="") {
	; Warning: Any tags (routines) referenced in the command need to be listed
	;          in the goto $case where $$$CheckRetryList() returns a value.
	;		   Any tags passed need to be accessible from an execute
	;          statement at the "level" of tag 'wait:'
	s ri=$I(^||MIRROR(mirname,"retry","list"))
	s ^||MIRROR(mirname,"retry","list",ri)=cmd
	if $G(tag)'="" {
		s ^||MIRROR(mirname,"retry","list",ri,"goto")=tag
	}
	; Update non-ppg version so we can see the list
	s ^MIRROR(mirname,"retry","list")=ri
	s ^MIRROR(mirname,"retry","list",ri)=cmd
	s:$G(tag)'="" ^MIRROR(mirname,"retry","list",ri,"goto")=tag
	k ^MIRROR(mirname,"retry","lasttime")
	s ^MIRROR(mirname,"RetryReason")=$G(reasonMSG,"")
}
AddMonitorEntry(mirname,cmd) {
	s ri=$I(^||MIRROR(mirname,"retry","monitor"))
	s ^||MIRROR(mirname,"retry","monitor",ri)=cmd
	; Update non-ppg version so we can see the list
	s ^MIRROR(mirname,"retry","monitor")=ri
	s ^MIRROR(mirname,"retry","monitor",ri)=cmd
}
GetCurrentPrimaryID(mirname) PUBLIC {
	/* Called on a reporting node to get the id of the
	   current primary which it should connect to.
	   Returns: -1 -> some problem or no current primary
	           >=0 -> MIRRORSET Member # (0/1) of current primary
	*/
	s $zt="err"
	;
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
	if systemcnt="" quit -1  ;no failover nodes configured
	s status=""
	Set id=+$G(^MIRROR(mirname,"PrimaryMember"))
	If 'id||(id>1&&(systemcnt<2)) s id=1
	while (systemcnt) {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
	      if status="PRIMARY" {
		      Set ^MIRROR(mirname,"PrimaryMember")=id
		      quit
	      }
       }
       if $i(systemcnt,-1) Set id=$s(id=1:2,1:1)
	}	
	if status="PRIMARY" quit id
	quit -1  ;no primary found
err ;
	s $zt=""
	d $zu(9,"","Unexpected error in GetCurrentPrimaryID: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit -1	
}
ClearRetryList(mirname) {
	; This is called when a node begins the process of becoming
	; the primary or a backup. Up to that point the retry list contains
	; things that need to be retried to get to the point of becoming
	; the primary or backup (if there is anything). When the node starts
	; becoming the primary or the backup if there's anything still on the
	; list it can be removed as we may add new items related to 
	; failures becoming the backup/primary.
	k ^||MIRROR(mirname,"retry")
	k ^MIRROR(mirname,"retry")
}
CheckRetryList(mirname) ;
	/* This is NOT a procedure block routine because we want it
	   executed with the same private variable list as the
	   main mirror manager loop because a couple of arrays need
	   to be passed (obviously by reference) to a couple of the
	   functions. We could just declare those variables 
	   (RequiredRecoveryAction and ConnectHistory) as public so we
	   can see their values, or even pass them in by reference but
	   this seems easier.
	   If there is an item on the retry list we execute it.
	   If it returns TRUE (non-zero) we remove it from the list
	   and if it has an associated goto target, we return that 
	   target. If it doesn't have a goto target then we repeat the
	   process until the list is empty.
	   Note that many, if not all, of the commands we execute expect
	   mirname set to the mirror name we're processing and they return
	   with 'rc' set to TRUE/FALSE for PASS/FAIL.
	   We read the commands from the PPG because we don't want someone
	   to be able to set a string into the ^MIRROR global which we then
	   execute.
	*/
	s index=$O(^||MIRROR(mirname,"retry","monitor",""),1,cmd)
	while (index '= "") {
		s rc=0  ; cmd returns its status in rc
		x @cmd
		if rc {
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Monitor item /"_cmd_" (index "_index_") succeeded - Removed from list")
		   k ^||MIRROR(mirname,"retry","monitor",index)
		   k ^MIRROR(mirname,"retry","monitor",index)
		}
		s index=$O(^||MIRROR(mirname,"retry","monitor",index),1,cmd)
	}
top ;	
	s index=$O(^||MIRROR(mirname,"retry","list",""),1,cmd)
	if index="" quit ""
	; 
	s rc=0  ; cmd returns its status in rc
	x @cmd
	q:'rc ""  ; failed
	s tag=$G(^||MIRROR(mirname,"retry","list",index,"goto"))
	if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Retried cmd /"_cmd_" (index "_index_") succeeded. Restart tag = /"_tag_"/")
	k ^||MIRROR(mirname,"retry","list",index)
	k ^MIRROR(mirname,"retry","list",index)
	k ^MIRROR(mirname,"RetryReason")
	if tag'="" quit tag
	goto top	
TakeOverAsPrimary() PUBLIC {
	/* TakeOverPrimary() is invoked by a user or script when the
	   mirror is up, this node is a backup, and they want this node 
	   to take over as the primary. We force the other node down
	   which should trigger a takeover by this node.
	   If this node fails to become the primary, or it is not 
	   currently a backup and you want it to become the primary,
	   DesignatePrimary() should be used instead. This routine will
	   not force this node to become a primary if doing so would 
	   mean we then have to rebuild the other node. DesignatePrimary()
	   can ignore certain types of errors to force a node to become
	   the primary in disaster type situations where the concern is
	   getting back up rather than preserving the mirror state of the
	   other node. This may involve loosing some data which was present
	   on the other node. The user is responsible for understanding the
	   state of the mirror and the consequences of their actions.
	   returns $LB(0,<error text>)
	           $LB(1)
	*/
	s $zt="err"
	s info=$SYSTEM.Mirror.GetInfo()
	if info'[",DEFINED," {
		quit $LB(0,"Not configured as a mirror member")
	}
	if info["PRIMARY" {
		quit $LB(1,"This system is already a primary member.")  ;we're currently the primary, signal success
	}
	if info'["BACKUP" {
		quit $LB(0,"TakeOverAsPrimary failed - not currently a backup node")
	}
	;
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") {
		quit $LB(0,"Operation requires %Admin_Manage:Use privilege")
	}
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname="" {
		quit $LB(0,"Failed to locate current mirror name in [Mirrors] section")
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [Mirrors] configuration section for "_mirname)
	}
	s definedPrimary=cls.DefinedPrimary
	s cls=""
	;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [MirrorMember] configuration section")
	}
	s reportingNode=cls.isAsyncMember()
	s systemid=cls.SystemName
	s validmember=cls.ValidatedMember
	s cls=""
	if reportingNode {
		quit $LB(0,"Reporting nodes are not eligible to become the primary mirror member")
	}
	if 'validmember {
		; this test is silly because we already know we're a backup...
		quit $LB(0,"Current node is not eligible to become the primary as it is not a validated mirror member")
	}
	;
	s lastjrninfo=$$GetMaxDejrnStart(mirname,3)  ;returns $LB(rc,<jrnfilecnt>,<jrnendoff>)
    if '$LG(lastjrninfo)||($LG(lastjrninfo,2)=0) {
	    s lastjrnfilecnt=0
	    s lastjrnend=""  ;no journal files yet	
    } else {
	    s lastjrnend=+$LG(lastjrninfo,3)
	    s lastjrnfilecnt=+$LG(lastjrninfo,2)
    }
	if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
		quit $LB(0,"One or more required mirrored databases are not active - see console log")
	}
	if definedPrimary'="",definedPrimary'=systemid {
		; try to clear this since we're going to take over 
		; as the primary
	   s rc=$$ClearMirrorNoFailover^MIRRORCTL("Primary")
	   if $LG(rc)="ERR" {
		   s rc=$LG(rc,2)
		   quit $LB(0,"Cannot become primary - Failed to clear the nofailover state. Error = /"_rc_"/")
	   }
	}
	s id=1  ;The other failover member which we know already exists
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	   quit $LB(0,"Cannot become primary - Failed to read current primary information from MIRRORSET Member id #1")
    }
    s name=$lg(info,1)
	s rc=$$GetStatus^MIRRORCTL(mirname,id)
	s status=$LG(rc)  
	if status="ERR" {
		h 1
		s rc=$$GetStatus^MIRRORCTL(mirname,id)
		s status=$LG(rc)  
		; we'll continue and return failure
	}
	if (status'="PRIMARY")&&(status'="HUNG") {
	   quit $LB(0,"Cannot force other node, status is """_status_""" - not HUNG or PRIMARY")
	}
	s force=0
	if (status = "HUNG") {
	    d $zu(9,"","TakeOverAsPrimary forcing down hung primary """_name_"""",0,0  /* Informational message */)
	} elseif (status="PRIMARY") {
	   d $zu(9,"","TakeOverAsPrimary forcing down current primary """_name_"""",0,0  /* Informational message */)
	}
	s status=$$ForceNodeDown^MIRRORCTL(mirname,id)
	s waittime=15
	do {
	   h 1
	   s rc=$$GetStatus^MIRRORCTL(mirname,id)
       s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
       s waittime=waittime-1
	} while waittime && (status'="DOWN")
	if (status'="DOWN") {
	   d $zu(9,"","Primary "_name_" failed to shut down (status="""_status_""")",1 /* broadcast and log message*/,1  /* Warning */)
	} else {
	   d $zu(9,"","Primary "_name_" killed",0,0  /* Informational message */)
	}
	;
	;Should trigger a takeover by this node so
	;   we should see this node become the primary	
	s waittime=15
	do {
	   h 1
	   s info=$SYSTEM.Mirror.GetInfo()
       s waittime=waittime-1
	} while waittime && (info'["PRIMARY")
	if info[",PRIMARY," {
	   quit $LB(1,"Success.")  ;succeeded
	}
	quit $LB(1,"This system did not become a primary after 15 seconds wait, please check mirror status later.")
err ;
	s $zt=""
	quit $LB(0,"Caught error: /"_$ZE_"/")	
}
DesignatePrimary(forcetakeover=0) PUBLIC {
	/* DesignatePrimary() is invoked by the system manager when there
	   is some problem with the mirror that prevents a node from becoming
	   a primary and they want to force this node to become the primary
	   regardless of the consequences. This may result in this node starting
	   up without some of the data which was present on the old primary 
	   and it may result in being unable to start the other node without
	   restoring all of its mirrored db's from a new backup of this node. 
	   This is designed to be used in situations where the user has 
	   knowledge of the state of the journal files on this node (with
	   respect to the other node) or in situations where the data from
	   the other node has been lost and the best we can do is restart
	   with what we have on this one. 
	   This can still fail if we find we run into some problem we
	   can't get around (eg. we can't read the journal log, we have
	   some databases which require some journal file(s) we don't have,
	   etc...)
	   returns $LB(0,<error text>)
	           $LB(1)
	*/ 
	s $zt="err"
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") Quit $LB(0,"Required %Admin_Manage:USE privilege")
	s info=$SYSTEM.Mirror.GetInfo()
	if info'[",DEFINED," {
		quit $LB(0,"Not configured as a mirror member")
	}
	if info["PRIMARY" {
		quit $LB(1)  ;we're currently the primary, signal success
	}
	if 'forcetakeover,info["BACKUP" {
		quit $LB(0,"This node is an active backup, cannot force takeover")
	}
	;
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname="" {
		quit $LB(0,"Failed to locate current mirror name in [Mirrors] section")
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [Mirrors] configuration section for "_mirname)
	}
	s definedPrimary=cls.DefinedPrimary
	s cls=""
	;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [MirrorMember] configuration section")
	}
	s reportingNode=cls.isAsyncMember()
	s systemid=cls.SystemName
	s validmember=cls.ValidatedMember
	s cls=""
	if reportingNode {
		quit $LB(0,"Reporting nodes are not eligible to become the primary mirror member")
	}
	if 'validmember {
		quit $LB(0,"Current node is not eligible to become the primary as it is not a validated mirror member")
	}
	;
	if definedPrimary'="",definedPrimary'=systemid {
		; try to clear this since we're going to take over as the primary
	   s rc=$$ClearMirrorNoFailover^MIRRORCTL("Primary")
	   if $LG(rc)="ERR" {
		   s rc=$LG(rc,2)
		   d $zu(9,"","Warning: "_systemid_" is taking over as the primary but we failed to clear the nofailover state. Error = /"_rc_"/",1 /* broadcast and log message*/,1  /* Warning */)
	   }
	}
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	s status=""
	for id=1:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
	      if (status="PRIMARY") || (status="HUNG") {
		      quit
	      }
       }
	}
	s origstatus=status
	if (status="HUNG" || (status="PRIMARY")) {
	   d $zu(9,"","DesignatePrimary forcing down current primary """_name_""" (status = """_status_""")",0,0  /* Informational message */)
	   s status=$$ForceNodeDown^MIRRORCTL(mirname,id)
	   s waittime=15
	   do {
		  h 1
	      s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
          s waittime=waittime-1
	   } while waittime && (status'="DOWN")
	   if (status'="DOWN") {
	      d $zu(9,"","Primary "_name_" failed to shut down (status="""_status_""")",1 /* broadcast and log message*/,1  /* Warning */)
	   } else {
		  d $zu(9,"","Primary "_name_" killed",0,0  /* Informational message */)
	   }
	   ;should trigger a takeover by this node now.
    }
    if (origstatus'="PRIMARY") {
	   d $zu(9,"","DesignatePrimary marking this node as the primary",0,0  /* Informational message */)
       do post(mirname,0,0,"ForcePrimary")
    }
	;
	; We should see this node become the primary but it will take
	; at least 30 seconds, probaby 60, because it has to time out
	; once or twice while starting up (eg. assuming the other node can't
	; be reached).
	s waittime=70
	do {
	   h 1
	   s info=$SYSTEM.Mirror.GetInfo()
       s waittime=waittime-1
	} while waittime && (info'[",PRIMARY,")
	if info[",PRIMARY," {
	   quit $LB(1)  ;succeeded
	}
	; Maybe we should post a forceprimary message here and
	; wait again?
	quit $LB(0,"Failed to become the primary - reason unknown")
err ;
	s $zt=""
	quit $LB(0,"Caught error: /"_$ZE_"/")	
}
BecomeBackup(mirname,id) {
	/* Invoked when a node wants to try and become a backup mirror
	   member. Most of the work is done after we job off ^Backup
	   but we do some prelimary checking here. */
	s $zt="err"
	s status=$SYSTEM.Mirror.GetInfo()
	if (status["BACKUP") || (status["PRIMARY") {
	   ; this node shouldn't be either a primary or a backup at this
	   ; point unless this is an async member
	   if (status'["SHADOW") {
		   d $zu(9,"","BecomeBackup: Member is already in 'Primary' or 'Backup' state.",1 /* broadcast and log message*/,1  /* Warning */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=($SYSTEM.Mirror.IsPrimary()||$SYSTEM.Mirror.IsBackup()) }"", .rc)","Restart")
	      quit 
	   }
	}
	if +$SYSTEM.Mirror.GetInfo(5)'=0 {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","BecomeBackup: Found data channel already exists - ignoring request")
		quit
	}
    do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	s mtype=+$LG(info,8)
	if status[",SHADOW" {
       d $zu(9,"","("_mirname_") Becoming an async mirror member",0,0  /* Informational message */)
	} else {
       d $zu(9,"","("_mirname_") Becoming a backup mirror member",0,0  /* Informational message */)
	   s status=$system.License.KeyServer()
	   if (status '= "Multi") {
	      d $zu(9,"","Failed to become backup mirror member, multi-server license required. License Type = "_status,1 /* broadcast and log message*/,2  /* Severe error */)
	      do AddRetryEntry(mirname,"(""(rc) { s rc=($system.License.KeyServer()=""Multi"") }"", .rc)","Restart")
	      quit
	   }
	}
	if mtype=0 {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","BecomeBackup: Set member #"_id_" role to "_"PRIMARY")
	   s ^MIRROR(mirname,"Status","Member",id,"Role")="PRIMARY"
	} elseif mtype=1 {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","BecomeBackup: Set member #"_id_" role to "_"RELAY")
	   s ^MIRROR(mirname,"Status","Member",id,"Role")="RELAY"
	} else {
	   d $zu(9,"","Failed to become backup mirror member, connecting to bad member type = "_mtype,1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
	}
	do ClearRetryList(mirname)  ;if there's a retry list, reset it now
	if $d(^SYS("FirstMirrorStartSinceInstall"))&&(mtype=0) {
	   do updateCacheMirrorVersion($G(^SYS("CACHEMirrorVersion")))
	}
	do ResolveDBRollbackState(mirname)
	do $SYSTEM.Mirror.LastFileValidFlag(0)
	do $SYSTEM.Mirror.InitBackup()
	s ^MIRROR(mirname,"Role")="BACKUP"
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorArbiterConnection^MIRRORCOMM("""""_mirname_""""") }"", .rc)")
	job Backup^MIRRORCOMM(mirname,"",id,0,$G(^MIRROR(mirname,"MgrJobID"))):(:2):10  ;pass "" for io so it establishs a connection
	if '$T {
	   d $zu(9,"","MIRRORSVR failed to job backup client",1 /* broadcast and log message*/,2  /* Severe error */)
	   ; Not sure what to do here for AddRetryEntry(). I don't think we want to
	   ; retry jobbing the backup routine, nor am I sure we just want to post
	   ; a backup retry so we come here over and over...
	} else {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Backup client started ("_$ZC_")")
	}
	q
err ;
	s $zt=""
	d $zu(9,"","Unexpected error in BecomeBackup: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	q
}
BecomePrimary(mirname,forceBecomePrimary,wasBackup) {
	/* BecomePrimary() is called when this node needs to become the
	   primary. This could be at startup when we can't find another
	   primary in the mirror or it could be after $SYSTEM.Mirror.Client()
	   exited and this node (formerly a backup) has decided it should
	   become the new primary. 
	   If something goes wrong in the process of becoming the primary
	   we try to recover by aborting the process and returning to an
	   "idle" mirror member state. If this fails (we can't switch back to
	   a normal journal file) we have to shut down the system.
	   Should be called with the DECISION state (ModifyDecisionState(1))
	   Set. Exits with the DECISION state clear regardless of whether we
	   succesfully become the primary. If we do succeed though we were careful
	   not to clear the DECISION state until AFTER we set the PRIMARY state.
	   Idealy when something goes wrong we should signal the other mirror
	   member that it should become the primary if it can. Currently we don't 
	   do this.
	   Return values
	     0 - exit routine, something went wrong
	     1 - continue running. If we're the primary, ^MIRROR("role") is
	          now set to $$$Primary
	    -1 - This node is not the Designate Primary node.
	*/
	; We need to pass the last journal file into PrimaryStartupComplete() so
	; it can figure out which mirrored db's are up to date enough to become
	; part of the active mirror.
	s $zt="err"
	s blkuser=0  ; logins not blocked yet
	s vipacquired=0 ;flag to drop vip if we abort
	s info=$SYSTEM.Mirror.GetInfo()
	if info["BACKUP" {
		; If we're a backup that means we're connected to the primary
		; so this is a problem.
		d $zu(9,"","Backup node needs to reset before becoming primary member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s DemotingFlag=0
	try {
		s DemotingFlag=$SYSTEM.Mirror.DemotingFlag()
	} catch {}
	if DemotingFlag {
		d $zu(9,"","BecomePrimary: Demoting in progress, cannot become primary.",1 /* broadcast and log message*/,1  /* Warning */)
		do AddRetryEntry(mirname,"(""(rc) { s rc='$SYSTEM.Mirror.DemotingFlag() }"", .rc)","Restart")
		quit 0
	}
    do $SYSTEM.Mirror.SetStatus("TRANSITION")
	do ClearRetryList(mirname)  ;if there's a retry list, reset it now
	s ok=$$CheckDefinedPrimary(0)  ;0 = Clear definedPrimary setting if its us
	if ok'=1 {
		do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","Failed to locate current primary")
		quit ok  ;0 or -1 depending on what went wrong
	}
	if '$SYSTEM.Mirror.LastFileValidFlag() {
		if forceBecomePrimary {
			d $zu(9,"","BecomePrimary continuing due to force flag when LastFileValid is clear",0,0  /* Informational message */)
		} else {
			d $zu(9,"","BecomePrimary aborted - Other failover member may have created a new journal file",0,0  /* Informational message */)
			; Since lastfilevalid is clear we need to talk with the other node so ensure
			; activebackupflag is clear as well.
			do $SYSTEM.Mirror.ActiveBackupFlag(0)
			; The following will cause us to return to restart and activebackupflag 
			; is clear so we will contact the other system to find the last jrnfile
			do AddRetryEntry(mirname,"(""(rc) { s rc=1 }"", .rc)","Restart")
			quit 0
		}
	}
		try {
			s Ok2Continue=$$CanNodeStartToBecomePrimary^ZMIRROR()  ;returns 1/0
		} catch exception {
			; if there's a problem we assume success
			s Ok2Continue=1  
			if "<NOLINE>,<NOROUTINE>"'[exception.Name {
				d $zu(9,"","("_mirname_") "_exception.Name_" calling $$CanNodeStartToBecomePrimary^ZMIRROR() - BecomePrimary continuing, assuming success",1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		if 'Ok2Continue {
			d $zu(9,"","("_mirname_") CanNodeStartToBecomePrimary^ZMIRROR returned ""NO"" - Aborting BecomePrimary and Waiting",0,0  /* Informational message */)
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckCanNodeStartToBecomePrimary("""""_mirname_""""") }"", .rc)","Restart","CanNodeStartToBecomePrimary aborted process of becoming the primary failover member")
			quit 1
		}
	; Lookup VIP address to see if there is one
	s cls=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(cls) {
		d $zu(9,"","BecomePrimary aborted - Failed to open Config.Mirrors("_mirname_") to read virtual IP information",1 /* broadcast and log message*/,1  /* Warning */)	
		do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","Failed to open [Mirrors] configuration section")
	    quit 0
	}
	s vipAddr=cls.VirtualAddress  ;"" if there isn't one
	s cls=""
	;
	; We're trying to become the primary so dejrnchkpnt/transroll, the end of our
	; last journal file is valid and we've finished ApplyJournalFiles.
	;
	s lastjrninfo=$$GetDejrnChkpntInfo(mirname)  ;returns cnt^pos
    if '+lastjrninfo {
	    s lastjrnfilecnt=0
	    s lastjrnend=0  ;no journal files yet	
	    s transrollindex=0
	    s transrolljrnfilecnt=0   
    } else {
	    s lastjrnend=+$P(lastjrninfo,"^",2)
	    s lastjrnfilecnt=+lastjrninfo
	    ; 
	    ; If any of the db's which have been caught up to the dejrnchkpnt
	    ; have a lastfilecntrestored set then we need to back up the
	    ; transaction rollback point to the earliest file
		k dblist
		s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
		if '$LG(rc) {
		   d $zu(9,"","BecomePrimary: Failed to read list of mirrored databases, GetMirrorDBList returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	    }
	    s minxjrnfilecnt=lastjrnfilecnt
		s index=""
		for {
		   s index=$o(dblist(index),1,info)
		   q:index=""
	   	   s dbmirname=$P(info,"^",8)
	   	   s dbjrncnt=$P(info,"^",3)
	   	   if (dbmirname=mirname) && (dbjrncnt=lastjrnfilecnt) {
		      s dblastfilecnt=+$P(info,"^",11)
		      if dblastfilecnt && (dblastfilecnt < minxjrnfilecnt) {
		         s dbpath=$P(info,"^",1)
				 if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Rollback point changed from "_minxjrnfilecnt_" to "_dblastfilecnt_" based on 1st restored file for "_dbpath)
		         s minxjrnfilecnt = dblastfilecnt
		      }
	   	   }
		}
		k dblist  ;clean up
		;
	    s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(minxjrnfilecnt,mirname)
	    if +rc<=0 {
		    d $zu(9,"","BecomePrimary failed to lookup file name for file #"_minxjrnfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
		    ; can't ignore this error
			do AddRetryEntry(mirname,"(""(rc) { s x=$SYSTEM.Mirror.GetJournalFileByMjrncnt("_minxjrnfilecnt_","""""_mirname_""""") s rc=(x>0) }"", .rc)","Restart","Failed looking up next journal file to apply in the mirror journal log")
		    quit 0  ;failed
	    }
		s minxjrnfile=$P(rc,",",2)
		;
		s info=$zu(78,22,minxjrnfile,99)
		if '+info {
		   d $zu(9,"","Primary startup failed, failed to read header of "_minxjrnfile_" (file #"_minxjrnfilecnt_")",1 /* broadcast and log message*/,1  /* Warning */)
		   ; $$$JRNHDRALL(x) = $ZU(78,22,x,99)
		   do AddRetryEntry(mirname,"(""(rc) { s info=$zu(78,22,"""""_minxjrnfile_""""",99),rc=+info }"", .rc)","Restart","Failed to read header of next journal file to apply")
		   quit 0
		}
		s transrollindex=+$P(info,",",21+1)  ;+1 to skip status code
		s transrolljrnfilecnt=+$P(info,",",20+1)
	    if '+transrolljrnfilecnt {
		   ; if there's no tp restore point listed then we must not have had TP rollback
		   ; information when the file was created so if we scan back to the start of
		   ; this file, we should find all the open transactions, if there are any
		   ; 
		   d $zu(9,"","Journal file "_minxjrnfile_" is missing tp rollback information, using start of file",0,0  /* Informational message */)
		   s transrolljrnfilecnt=minxjrnfilecnt
		   s transrollindex=65536*2  ; set position to 1st real record in the file
	    }
	    if transrolljrnfilecnt'=minxjrnfilecnt {
	       s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(transrolljrnfilecnt,mirname)
	       if +rc<=0 {
		      d $zu(9,"","BecomePrimary failed to lookup file name for file #"_transrolljrnfilecnt_" for rollback",1 /* broadcast and log message*/,1  /* Warning */)
			  do AddRetryEntry(mirname,"(""(rc) { s x=$SYSTEM.Mirror.GetJournalFileByMjrncnt("_transrolljrnfilecnt_","""""_mirname_""""") s rc=(x>0) }"", .rc)","Restart","Failed to locate journal file for transaction rollback in the mirror journal log")
		      quit 0  ;failed
	       }
		   s minxjrnfile=$P(rc,",",2)
 		   ;
		   s info=$zu(78,22,minxjrnfile,99)
		   if '+info {
		      d $zu(9,"","Primary startup failed, failed to read header of "_minxjrnfile_" (file #"_transrolljrnfilecnt_") for rollback",1 /* broadcast and log message*/,1  /* Warning */)
		      ; $$$JRNHDRALL(x) = $ZU(78,22,x,99)
		      do AddRetryEntry(mirname,"(""(rc) { s info=$zu(78,22,"""""_minxjrnfile_""""",99),rc=+info }"", .rc)","Restart","Failed to read the header of journal file for transaction rollback")
		      quit 0
		   }
	    }
    }
    if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
		if 'forceBecomePrimary {
			; we're missing one or more required database or one or more
			; of the required mirrored databases is not active. 
			; If we can become a backup we'll do that otherwise we retry 
			; to see if the issues with the required databases have been resolved.
			d $zu(9,"","Primary startup failed, one or more required databases are missing",1 /* broadcast and log message*/,1  /* Warning */)
	 	    do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckRequiredDatabases("""""_mirname_""""","_lastjrnfilecnt_","_lastjrnend_") }"", .rc)","Restart","Cannot become primary because one or more required databases are missing")
		    quit 0
		}
		d $zu(9,"","ForceBecomePrimary set - ignoring required databases troubles",1 /* broadcast and log message*/,1  /* Warning */)
	}
	if $SYSTEM.Mirror.ActiveBackupFlag()=0 {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		if info'="" {
			s mtype=+$LG(info,8)
			if mtype'=0 {
				d $zu(9,"","ClearLastFileValid skipped, member #1 (type "_mtype_") is not a failover member",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				s name=$lg(info,1)
				s rc=$$ClearLastFileValidFlag^MIRRORCTL(mirname,1)
				; Just ignore $LG(rc)="UNKNCMD", its not an error
				if $LG(rc)="ERR" {
					; We can't continue until we get an OK back from this routine
					d $zu(9,"","Aboting BecomePrimary: ClearLastFileValid("""_mirname_""") for """_name_""" failed ("_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
					do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearLastFileValid("""""_mirname_""""") }"", .rc)","Restart","Error signaling to other failover member that its does not have the last journal file")
					quit 0
				}
			}
		}
	}
    ;
    ;From here down if we fail at some step we don't create a Retry list
    ; entry because there isn't any one thing that can fix the problem.
    ; These are fairly serious issues and we don't really expect to be 
    ; failing here (other than perhaps if the customer's code tells us not
    ; to become the primary) so if we do fail we'll return to our idle loop
    ; where we'll become a backup if we see the primary start up or we'll retry
    ; beoming the primary if the user tells us to.
    ;
    if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Primary starting up with last journal file #"_lastjrnfilecnt_" and TP rollback index "_transrollindex_" in file #"_transrolljrnfilecnt)
    s blkuser=1  ;indicate we've suspended logins
    Lock +^SYS("UpdateMblkuserInSTU")
    s origmblkuser=$V($ZU(40,2,93),-2,1)
    v $ZU(40,2,93):-2:1:3   ;set mblkuser=3
    Lock -^SYS("UpdateMblkuserInSTU")
	if vipAddr="" {    
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","info: Primary startup, no vip address specified")
	} else {
	   s ok=$$releaseVIPonAllMembers(mirname)
       if '$lg(ok) {
	 	   d $zu(9,"","Virtual IP address could not be released on failover members: "_$p($lg(ok),",",2,999),0,0  /* Informational message */)
	 	  ;Try to add it anyway 
       }
       s ok=$$AddVirtualAddress(mirname)
       if '$lg(ok) {
	      d $zu(9,"","AddVirtualAddress failed, cannot become primary: "_$p($lg(ok),",",2,999),1 /* broadcast and log message*/,2  /* Severe error */)
	      do AddRetryEntry(mirname,"(""(rc) { hang 5 s rc=1 }"", .rc)","Restart","Failed to establish virtual network address")
	      do RestoreMBlkuser(origmblkuser)
	      quit 0
       }
       s vipacquired=1
	}
	k ^MIRROR(mirname,"PendingNewMember"),^MIRROR(mirname,"PendingDNUpdates")
	s rc=$SYSTEM.Mirror.PrimaryInit() 
	; Now that the primary state is set, clear the decision state
	do $SYSTEM.Mirror.ModifyDecidingState(0)
	if 'rc {  ;uh oh, init primary failed
	   d $zu(9,"","Primary initialization failed",1 /* broadcast and log message*/,2  /* Severe error */)
	   ; Not sure what to do here. as hopefully we don't end up spinning,
	   ; calling this over and over. 
	   do AddRetryEntry(mirname,"(""(rc) { hang 5 s rc=1 }"", .rc)","Restart","Primary initialization failed")
	   if (vipacquired) {
	      s rc=$$DeleteVirtualAddress(mirname)
	      s vipacquired=0
	   }
	   do RestoreMBlkuser(origmblkuser)
	   quit 0
	}
	do $SYSTEM.Mirror.LastFileValidFlag(0) ; we have a new file now
	;
	; If we abort after this point we need to re-initialize the dejournal memory
	; as SYSTEM.Mirror.PrimaryInit() releated it.
	;
	s debugflags=$G(^SYS("MIRRORSET","Debug","ecpflags"))
	s debugflags=+$ZH("0"_debugflags)
	if debugflags {
	   s curflags=$SYSTEM.ECP.Debug()
	   ; leave the current bits set and or in the bits we want
	   ; on during ecprecovery
	   s newflags=$zb(+curflags,debugflags,7) ; 7=inclusive or
	   do $SYSTEM.ECP.Debug(newflags)
	}
    s ok=$$Mirror^ECPRecovery(mirname,lastjrnfilecnt,transrolljrnfilecnt,transrollindex) 
    if debugflags do $SYSTEM.ECP.Debug(curflags)  ;reset 
    if 'ok {
	    d $zu(9,"","ECPRecovery failed, cannot become primary - Waiting to become the backup",1 /* broadcast and log message*/,2  /* Severe error */)
		do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckPrimaryIsUp("""""_mirname_""""") }"", .rc)","Restart","ECPRecovery failed, waiting to become the backup")  ;JO2401
	    goto failed
    }
    ;Transaction rollback succeeded so go through and clear the rollback
    ; point for all databases which are current as of the current last
    ; journal file.
    do TransactionRollbackComplete(mirname)
	;
    ; Before we complete the transition to become the active
    ; primary, call CheckBecomePrimaryOK^ZMIRROR in case the
    ; user has somethings they want to check as well. If this
    ; returns 0 we'll abort the process of taking over as the primary.
    ;
    ; It is ok if ^ZMIRROR doesn't exist or if the tag in ^ZMIRROR is
    ; missing but any other error is treated as a failure.
	try {
	   s ok=$$CheckBecomePrimaryOK^ZMIRROR()
	} catch errv {
	   if "<NOROUTINE>,<NOLINE>"[errv.Name {
		  s ok=1
	   } else {
		  s ok=0
		  s errtext=errv.Name_" at "_errv.Location
		  d $zu(9,"","Unexpected error: "_errtext_" calling $$CheckBecomePrimaryOK^ZMIRROR()",1 /* broadcast and log message*/,1  /* Warning */)
	   }
	}
    if 'ok {
	   d $zu(9,"","CheckBecomePrimaryOK^ZMIRROR() returned 0, aborting primary startup",1 /* broadcast and log message*/,2  /* Severe error */)
       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryCheckBecomePrimaryOK("""""_mirname_""""") }"", .rc)","Restart","CheckBecomePrimaryOk indicated instance should not become the primary")
 	   goto failed
    }
	if '$SYSTEM.Mirror.PrimaryStartupComplete(lastjrnfilecnt,lastjrnend) { 
	    d $zu(9,"","Failed to complete primary startup process",1 /* broadcast and log message*/,2  /* Severe error */)
        ;probably need to drop ecp sessions or something
        do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckOtherNodeIsReachable("""""_mirname_""""") }"", .rc)","Restart","PrimaryStartupComplete failed")
        goto failed
	}
	; Mirrored db's are now read/write - see if we have post install
	; upgrade tasks before we allow ECP
	if $G(^SYS("FirstMirrorStartSinceInstall")) {
		if '$$RunMirrorUpgradeProcedure() {
			d $zu(9,"","Post-install Cache' Mirror upgrade procedure failed - The trouble must be resolved before restarting this node to become the primary",1 /* broadcast and log message*/,2  /* Severe error */)
			; If the other node becomes the primary we'll try to become
			; the backup but otherwise we need the user to fix some problem
			; and tell us to retry becoming the primary when they 
			; resolve the trouble
		    do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckPrimaryIsUp("""""_mirname_""""") }"", .rc)","Restart","Mirror upgrade procedure failed")
			goto failed
		}
	    k ^SYS("FirstMirrorStartSinceInstall")
	}
	; Finish the final sync point of ECPRecovery to transition the
	; connections to a normal state and let them resume processing.
	; This will set mserver_lockphase to 0 to complete recovery.
	do MirrorStartupComplete^ECPRecovery()
	do RestoreMBlkuser(origmblkuser)
    s blkuser=0
    do $SYSTEM.Mirror.ActiveBackupFlag(0) ; in case this is still set @ this poi
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorArbiterConnection^MIRRORCOMM("""""_mirname_""""") }"", .rc)")
	; 
	; If we're an ensemble system, start the productions which are
	; configured to be run @ startup. This is a no-op if we're not
	; an ensemble system.
	do Ensemble^STU()
	;
    ; Now that we've completed the transition to become the active
    ; primary, call NotifyBecomePrimary^ZMIRROR in case the site has
    ; "startup" code they want run.
	try {
	   do NotifyBecomePrimary^ZMIRROR()
	} catch errv {
	   if "<NOROUTINE>,<NOLINE>"'[errv.Name {
		  ; Report and log any unexpected errors but continue becoming
		  ; the primary
		  s errtext=errv.Name_" at "_errv.Location
		  d $zu(9,"","Unexpected error: "_errtext_" calling NotifyBecomePrimary^ZMIRROR()",1 /* broadcast and log message*/,1  /* Warning */)
		  D BACK^%ETN
	   }
	}
	if wasBackup {
		d $zu(9,"","Becoming primary mirror server",1 /* broadcast and log message*/,2  /* Severe error */)
	} else {
		d $zu(9,"","Becoming primary mirror server",1 /* broadcast and log message*/,1  /* Warning */)
	}
    s ^MIRROR(mirname,"Role")="PRIMARY"
    s $p(^SYS("MIRRORTIME",mirname),"^",2)=$ZTS_"|"_forceBecomePrimary
	s ^||FirstVIPMonitor=1
    do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorVIPAddress("""""_mirname_""""") }"", .rc)")
	quit 1  ;caller will check ^MIRROR("Role")
err ;
	s $zt=""
	d $zu(9,"","Unexpected error in BecomePrimary: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
failed ;    
    if vipacquired {
	   ; drop vip before allowing logins
	   s rc=$$DeleteVirtualAddress(mirname)
	   s vipacquired=0
    }
	do MirrorStartupAbort^ECPRecovery()
    if blkuser,$d(origmblkuser) {
	    do RestoreMBlkuser(origmblkuser)
	    s blkuser=0
    }
	if '$SYSTEM.Mirror.PrimaryStartupAbort() {
	   d $zu(9,"","PrimaryAbort failed, shutting down instance",1 /* broadcast and log message*/,3  /* Fatal */)
	   l  ; release all locks
	   do INT^SHUTDOWN
	   halt
	}
	if $SYSTEM.Mirror.ActiveBackupFlag() {
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc>0 {
			if $$getMirJrnEnd($P(rc,",",2))>0 {
				s ^MIRROR(mirname,"lastvalidjrnfile")=(+rc)_"^"_$P(rc,",",2)
			} else {
				d $zu(9,"","BecomePrimary abort: last journal file "_$P(rc,",",2)_"("_(+rc)_") did not have valid end",1 /* broadcast and log message*/,1  /* Warning */)
			}
		} else {
			d $zu(9,"","("_mirname_") BecomePrimary abort: failed to look up last valid file in journal log",1 /* broadcast and log message*/,1  /* Warning */)
		}
		s rc=$$SetLastFileValidFlag(mirname)
		if '$SYSTEM.Mirror.LastFileValidFlag() {
			d $zu(9,"","BecomePrimary failed to mark last file valid while resetting - Must contact other node to become primary",1 /* broadcast and log message*/,1  /* Warning */)
			do $SYSTEM.Mirror.ActiveBackupFlag(0)
		}
	}
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if (miridx<1) {  ;<1 because of the +1 above.
	   d $zu(9,"","BecomePrimary failed to locate mirror index for "_mirname_" to reinit dejournaling memory - Aborting",1 /* broadcast and log message*/,3  /* Fatal */)
	   halt
	} else {
       if '$$InitDejournal(miridx,mirname) {
	      d $zu(9,"","BecomePrimary failed to re-initialize dejournal memory - Aborting",1 /* broadcast and log message*/,3  /* Fatal */)
	      ; maybe we should just retry here instead of halting?
	      halt
	   }
	}
	quit 0
}
RestoreMBlkuser(origmblkuser) {
    Lock +^SYS("UpdateMblkuserInSTU")
    if $d(^SYS("STUInProgress"))||$g(^SYS("FirstRestartSinceInstall")) {
	    v $ZU(40,2,93):-2:1:origmblkuser   ;set with original value
    } else {
	    v $ZU(40,2,93):-2:1:0   ;clear it.
    }
    Lock -^SYS("UpdateMblkuserInSTU")
}
GetDejrnChkpntInfo(mirname) PUBLIC {
	/* Returns mirjrnfilecnt^jrnpos of the place our mirrored db's are
	   current as of or 0^<undefined> if we don't have any journal files
	   and/or mirrored dbs yet */
    s lastjrninfo=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;cnt^pos
	if '+lastjrninfo {
		s rc=$$GetMirrorDejournalInformation(mirname)
		s lastjrninfo=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;cnt^pos
	}
	quit lastjrninfo
}
RunMirrorUpgradeProcedure() {
	/* This is the 1st time this system has become the primary since
	   the cache upgrade. Now that the mirrored db's are writeable 
	   figure out whether we need to run the upgrade procedure in them. */
	s $zt="err"
	s MirrorVersion=+$G(^SYS("CACHEMirrorVersion"))
	s CacheSYSVersion=+$G(^SYS("CACHESYSVersion"))
	if 'CacheSYSVersion {
		quit 1  ;we need the CACHESYSVersion for this to work
	}
	if MirrorVersion>=CacheSYSVersion {
		quit 1  ;nothing to do, already up to date
	}
	if $$updateCacheMirrorVersion(MirrorVersion) {
	   s MirrorVersion=$G(^SYS("CACHEMirrorVersion"))
   	   if MirrorVersion>=CacheSYSVersion {
          quit 1  ;nothing to do, already up to date
   	   }
   	}
   	d $zu(9,"","Running upgrade procedure to "_MirrorVersion_" for mirrored databases",0,0  /* Informational message */)
   	; Ok, the Mirror Version is less than the last version
   	; that was installed and we're the primary so we should
   	; run the database specific part of the install procedure.
	do UpdateMirrorDatabases^INSTALL()
	s ^SYS("CACHEMirrorVersion")=CacheSYSVersion
	quit 1  ;succeeded
err	;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Unexpected error "_$ZE_" checking for pending mirror upgrade work",1 /* broadcast and log message*/,1  /* Warning */)
	quit 0  ;failed
}
updateCacheMirrorVersion(currentVersion) {
	/* This routine fetches the value of ^SYS("CACHEMirrorVersion")
	   from the other failover member and if the value is greater than
	   the passed version, it updates the local copy of
	   ^SYS("CACHEMirrorVersion") with the value from the other node. If
	   there is some trouble, the current value is left unchanged.
	   Returns: 1 - version fetched and updated from other node
	            0 - version not updated, not needed or we failed
	*/
	s $ZT="err"
	; retrieve the value of ^SYS("CACHEMirrorVersion") 
	; from the other mirror member, if there is one,
	; to see if its later than the passed version
    s mirname=$p($G(^SYS("MIRRORSET")),"^",2)
    if mirname="" {
	    d $zu(9,"","updateCacheMirrorVersion - mirname not defined",1 /* broadcast and log message*/,1  /* Warning */)
	    quit 0
    }
 	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) {
		quit 0   ;no other member - we're done 
	}
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
    if info="" {
	   d $zu(9,"","Cannot update CACHEMirror version from "_name_" - Missing information for mirror member #1",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0 
    }
    s name=$lg(info,1)
   ; Retrieve MirrorVersion from the other node
	s rc=$$GetCacheMirrorVersion^MIRRORCTL(mirname,1)
	s status=$LG(rc)
	if status'="OK" {
	   d $zu(9,"","Error retrieving CACHEMirrorVersion from "_name_". Assuming local update is not required ("_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
    s ver=$LG(rc,2)
    if ver>currentVersion {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CacheMirrorVersion "_ver_" from "_name_" is higher than local version ("_currentVersion_")")
       s ^SYS("CACHEMirrorVersion")=ver
       quit 1
    }
	quit 0 ; our version is >= their version - no update needed		    
err ;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Unexpected error "_$ze_" in updateCacheMirrorVersion^"_$ZN,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
CheckDefinedPrimary(TestOnly) PUBLIC {	
	if ('TestOnly) || (($zb(+$SYSTEM.Mirror.DebugFlags(),2,1))) {
		s log=1
	} else {
		s log=0
	}
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname="" {
	 	if (log) {
			d $zu(9,"","Failed to locate current mirror name in [Mirrors] section",1 /* broadcast and log message*/,1  /* Warning */)
	 	}
		quit 0
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		s definedPrimary=""
	} else {
		s definedPrimary=cls.DefinedPrimary
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
    if ('rc) {
	    if (log) {
	       d $zu(9,"","CheckDefinedPrimary failed to open mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
	    }
	    quit 0
    }
    s systemid=cls.SystemName
    s cls=""
	if definedPrimary'="" {
	   if definedPrimary'=systemid {
		   if (log) {
		      d $zu(9,"","Primary is configured to be "_definedPrimary_" - Waiting for primary to start",0,0  /* Informational message */)
		   }
		   quit -1
	   }
	   ; TestOnly is set when we're called from the retry code after some
	   ; kind of failure. We don't adjust the NoFailover flag in that case
	   ; because we'll be called again when the node actually tries to become
	   ; the primary.
	   if 'TestOnly {
	      s rc=$$ClearMirrorNoFailover^MIRRORCTL("Primary")
	      if $LG(rc)="ERR" {
		     s rc=$LG(rc,2)
		     d $zu(9,"","Error clearing no failover state: "_rc,1 /* broadcast and log message*/,1  /* Warning */)
	      }
	   }
	}
	quit 1  ;success
}
TrackReconnections(mirname,id,history) PUBLIC {
	/* 'history' is the ConnectHistory passed by reference
	   here we make sure that we're not trying to reconnect
	   too often by keeping track of the last 10 reconnections.
	   If the last reconnection was >5 minutes old we continue
	   without checking anything else. 
	   history = <cnt of # of entries>
	   history(n...n+10) (n>0) = last 10 time deltas between 
	            reconnections
	   history(0,"last") = $ztimestamp of last attempt
	   history(0,"sum") = sum(history(n)...history(n+10))
	   (note if history (cnt) is < 10, then we only have that
# of entries. Once cnt goes over 10, we start removing the
	    old entries so we retain the last 10).
	   Returns: 0 = abort connection to primary
	            1 = continue & try to connect to primary
	                (currently always returns 1)
	   There are 3 configuration entries in ^MIRROR which affect
	   how we behave. These are not usually defined but they are
	   present in case we need them to deal with problems that arise.
	   ^MIRROR(mirname,"reconnect","disable")=0/1
	   ^MIRROR(mirname,"reconnect","mininterval") = min # of seconds we permit
	               between reconnections. If a backup tries to connect
	               more often, we delay it. Defaults to 60 when missing.
	   ^MIRROR(mirname,"reconnect","largedelay") = If we've reconnected 10 times in
	               a row and our average connection time is less than
	               minreconnect, this is an added delay. Defaults to 
	               5 minutes.
	   ^MIRROR(mirname,"reconnect","fixeddelay") = # of seconds which every
	          reconnection attempt waits. This overrides "minreconnect"/"largedelay"
	*/	
	s curtime=$ztimestamp
	s status=$SYSTEM.Mirror.GetStatus(mirname)
	if status="TRANSITION"||(status="SYNCHRONIZING") {
		/* We end up here when we failed to become a backup due to some
		   connection problem. Set the state to waiting rather than
		   transition in this case */
		do $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		s ^MIRROR(mirname,"Role")=""
		s role=""
	}
	if '$D(history(0)) {
       s history(0,"last")=curtime
	   s history(0,"sum")=0
	   quit 1  ;1st connection attempt
    }
    if $G(^MIRROR(mirname,"reconnect","disable"))=1 {
	    d $zu(9,"","Reconnections disabled for "_mirname_" node #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit 0
    }
	s cnt=$I(history)
	s last=history(0,"last")
	s elapsed=$$TimeDiff(last,curtime)
	s history(0,"last")=curtime
	s history(0,"sum")=history(0,"sum")+elapsed
	s history(cnt)=elapsed
	if cnt>10 {
		s val=$G(history(cnt-10))
		if val="" {
			; shouldn't ever happen but if the debugger is
			; broken, it can so recalculate the sum of the values
			s val=0,sum=0
			s x=$O(history(0),1,val)
			for  quit:x=""  s sum=sum+val s x=$O(history(x),1,val)
			s val=0
			s history(0,"sum")=sum
		}
		s history(0,"sum")=history(0,"sum")-val
		kill history(cnt-10)  ;keep the latest 10 values
		s earliestcnt=cnt-9
	} else {
		s earliestcnt=1
	}
	if cnt>=1000000 {
		; cnt is becoming quite large, reshuffle the
		; array so we can make it small again. The only
		; point here is to keep cnt from getting to the
		; place where cnt+1=cnt. 1000000 is no where close
		; to that but its large enough that we won't do this
		; that often
		s x=$O(history(0))
		for i=1:1 {
			quit:x=""
			s history(i)=history(x)
			s next=$O(history(x))
			k history(x)
			s x=next
		}
		s history=10
		s cnt=10
		s earliestcnt=1
		s x=$I(history(0,"reshufflecnt"))
	}
	if elapsed>300 {
		; its been more than 5 minutes since we last
		; reconnected, its ok to try again now
		quit 1
	}
	s sum=history(0,"sum")
	if sum>3600 {
		; its been more than an hour since the oldest
		; reconnection we're tracking, its ok to try
		; again. Since sum is the total of the last 10
		; elapsed times, it represents the time since
		; the oldest reconnection attempt
		quit 1
	}
	s avg=sum/(cnt-earliestcnt+1)
	; Figure out whether we're reconnecting to fast
	s minreconnect=+$G(^MIRROR(mirname,"reconnect","mininterval"),60)  ;in seconds
	s longdelay=+$G(^MIRROR(mirname,"reconnect","longdelay"),300)  ;in seconds
	s fixeddelay=+$G(^MIRROR(mirname,"reconnect","fixeddelay"))
	;
	if fixeddelay {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","("_mirname_") Reconnection delay enabled - Waiting "_fixeddelay_" seconds")
		hang fixeddelay
	} elseif avg<minreconnect {
		s wait=minreconnect-avg
		s wait=+$FN(wait,"",2)  ;trim to 2 decimal places
		if '(cnt#10) {
			; every 10 cycles, wait an additional 5 minutes
			if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","("_mirname_") Too many retries recently, adding "_longdelay_" seconds to wait time")
			s wait=wait+longdelay 
		}		
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","("_mirname_") Average reconnect time ("_$FN(avg,"",2)_" sec) is too short. Waiting "_wait_" seconds")
		hang wait
		; Now reset the history entry to so that it doesn't
		; include the time we waited because we want to know
		; how long the connections are lasting
		s curtime=$ztimestamp
		s history(0,"last")=curtime
	}
	quit 1
}
TimeDiff(start,end) {
	; Returns the difference between two $H (or $ztimestamp) times in seconds
	s days=+end-start
	s sec=+$P(end,",",2)-$P(start,",",2)
	if 'days quit sec
	s oneday=60*60*24
	s sec=sec+(days*oneday)
	quit sec
}
CheckVersion(mirname) {
	; Verify that ^MIRROR is in the format we require (eg. handle any
	; upgrade issues required here). If it is too old, we return 0 and
	; startup is aborted. 
	s ^MIRROR("Version")=1
	quit 1
}
post(mirname,mgrpid,id,text) {
	do post^MIRRORCOMM(mirname,mgrpid,id,text)
}
isMirroredDb(dir) public {
 	s mirrorbit=+$ZU(40,8,28)
 	s info=$zu(49,dir)
 	if info<-1 quit 0  ; doesn't exist, isn't mirrored
 	s dbattrib=+$p(info,",",17)  ;even when not mounted, $ZU(49) data is returned
 	if $zb(+dbattrib,+mirrorbit,1) quit 1
 	quit 0
}
 ; Startup^MIRRORMGR(mirname) to startup a mirror set.
 ; mirname - mirror set name to be started, use null string to startup all
 ;           mirror sets. For failover nodes it will be the default mirror set.
 ; return - $$$OK - success
 ;          $$$ERROR(<reason code>) - failed
Startup(mirname="") PUBLIC {
   if '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	   quit $$Error^%apiOBJ(2049)
   }
   quit:$SYSTEM.Mirror.GetInfo()'["DEFINED"&&('$G(^SYS("MIRRORSET"))) $$Error^%apiOBJ(2050)
   if mirname'="" {
	   if ##class(SYS.Mirror).IsMirrorStarted(mirname) q $$Error^%apiOBJ(2106,mirname)
	   if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",") q $$Error^%apiOBJ(2051,mirname)
       s ^MIRROR(mirname,"MgrJobID")="starting"
	   if $ZU(66,"USR","MirrorServer^STU",5,0,0,mirname)=-1 {
	       k ^MIRROR(mirname,"MgrJobID")
		   q $$Error^%apiOBJ(2052,mirname)
	   }
	   q 1
   }
   if +$G(^SYS("MIRRORSET")) {
	   s mirrorsets=$P(^SYS("MIRRORSET"),"^",2),ok=1
	   for i=1:1:$l(mirrorsets,",") {
		   s mirname=$p(mirrorsets,",",i)
		   if mirname="" continue
		   if ##class(SYS.Mirror).IsMirrorStarted(mirname) continue
		   s ^MIRROR(mirname,"MgrJobID")="starting"
		   s ok=($ZU(66,"USR","MirrorServer^STU",5,0,0,mirname)'=-1)
		   if 'ok {
			   k ^MIRROR(mirname,"MgrJobID")
			   quit
		   }
	   }
	   if '($zversion(1)=3)&&('ok) q $$Error^%apiOBJ(2052,$p(mirrorsets,",",i))
	   quit 1
   }
   s mirname=##class(Config.Mirrors).GetMirrorName()
   if mirname="" q $$Error^%apiOBJ(2051,mirname)
   if ##class(SYS.Mirror).IsMirrorStarted(mirname) q $$Error^%apiOBJ(2106,mirname)
   s ^MIRROR(mirname,"MgrJobID")="starting"
   if $ZU(66,"USR","MirrorServer^STU",5,0,0,"")=-1 {
	   k ^MIRROR(mirname,"MgrJobID")
	   q $$Error^%apiOBJ(2052,"")
   }
   q 1
}
 ; Shutdown^MIRRORMGR(timeout,mirname) to stop a mirror set.
 ; timeout - time to wait on the shutdown to be completed.
 ; mirname - mirror set name to be stopped, use null string to stop all
 ;           mirror sets. For failover nodes it will be the default mirror set.
 ; return -%Status
 ;         $$$OK - success
 ;         $$$ERROR(...) - Failed
 ;          0,reason : failed.
Shutdown(timeout,mirname="") PUBLIC {
	;Called from SHUTDOWN (or other places) when we want to shut down
	; the mirror system. 
   if '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	   quit $$Error^%apiOBJ(2093)
   }
   s state=$SYSTEM.Mirror.GetInfo()
   if state[",NOTINIT," quit $$Error^%apiOBJ(2050)  ; not a mirror member
   s remain=0
   if $G(^SYS("MIRRORSET")) {
	   if mirname'="" {
		   if ","_$p(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",") {
			   quit $$Error^%apiOBJ(2051,mirname)
		   }
		   if '##class(SYS.Mirror).IsMirrorStarted(mirname) q $$Error^%apiOBJ(2107,mirname)
		   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
		   ; we post on id #0 which is ourself. SHUTDOWN tells the mirror manager
		   ; this node is shutting down so it should not respond to any more
		   ; connections from other nodes (eg. if we're the primary, don't tell
		   ; a new node to become the backup).
		   if mgrpid do post(mirname,mgrpid,0,"SHUTDOWN:SUSPEND")
		   if state["BACKUP" {
			   s remain=$SYSTEM.Mirror.Shutdown(timeout,mirname)
		   }
		   ; send EXIT and the MIRRORMGR will exit which will close the
		   ; connections to the other nodes and the other nodes will reform
		   ; the mirror without us.
		   if mgrpid if '$$QuitMirrorMgr(mirname,mgrpid,1) Quit $$Error^%apiOBJ(2169,mirname)
		   if remain quit $$Error^%apiOBJ(2094,mirname)
		   if '$$BackupDaemonExit(mirname,timeout) quit $$Error^%apiOBJ(2168)
		   quit 1
	   }
 	   s mirlist=$p(^SYS("MIRRORSET"),"^",2)
 	   for i=1:1:$l(mirlist,",") {
	 	   s mirname=$p(mirlist,",",i)
	 	   if mirname="" continue
		   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
		   ; we post on id #0 which is ourself. SHUTDOWN tells the mirror manager
		   ; this node is shutting down so it should not respond to any more
		   ; connections from other nodes (eg. if we're the primary, don't tell
		   ; a new node to become the backup).
		   if mgrpid do post(mirname,mgrpid,0,"SHUTDOWN:SUSPEND")
 	   }
 	   if state["BACKUP" {
		   s remain=$SYSTEM.Mirror.Shutdown(timeout)
 	   }
 	   s dstatus=1
 	   for i=1:1:$l(mirlist,",") {
	 	   s mirname=$p(mirlist,",",i)
	 	   if mirname="" continue
		   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
		   ; send EXIT and the MIRRORMGR will exit which will close the
		   ; connections to the other nodes and the other nodes will reform
		   ; the mirror without us.
		   if mgrpid if '$$QuitMirrorMgr(mirname,mgrpid,1) s dstatus=$select(+dstatus:$$Error^%apiOBJ(2169,mirname),1:$$AppendStatus^%occSystem(dstatus,$$Error^%apiOBJ(2169,mirname)))
 	   }
 	   if '(''dstatus) Quit dstatus
  } else {
	   i mirname="" {
		   s mirname=$p(^SYS("MIRRORSET"),"^",2)
		   if mirname="" quit $$Error^%apiOBJ(2050)
	   } elseif mirname'=$p(^SYS("MIRRORSET"),"^",2) {
		   quit $$Error^%apiOBJ(2051,mirname)
	   }
	   if '##class(SYS.Mirror).IsMirrorStarted(mirname) q $$Error^%apiOBJ(2107,mirname)
	   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
	   ; we post on id #0 which is ourself. SHUTDOWN tells the mirror manager
	   ; this node is shutting down so it should not respond to any more
	   ; connections from other nodes (eg. if we're the primary, don't tell
	   ; a new node to become the backup).
	   if mgrpid do post(mirname,mgrpid,0,"SHUTDOWN:SUSPEND")
 	   if state["BACKUP"||(state["PRIMARY") {
		   s remain=$SYSTEM.Mirror.Shutdown(timeout)
 	   }
	   ; send EXIT and the MIRRORMGR will exit which will close the
	   ; connections to the other nodes and the other nodes will reform
	   ; the mirror without us.
	   if mgrpid if '$$QuitMirrorMgr(mirname,mgrpid,$s(state'["PRIMARY":1,1:0)) Quit $$Error^%apiOBJ(2169,mirname)
   }
   if remain quit $$Error^%apiOBJ(2094,mirname)
   if '$$BackupDaemonExit(mirname,timeout) quit $$Error^%apiOBJ(2168)
   quit 1
}
QuitMirrorMgr(mirname,mgrpid,intr=0) {
	do post(mirname,mgrpid,0,"SHUTDOWN:EXIT")
again ;
	Lock +^MIRROR(mirname,"MgrJobID"):$s(intr:3,1:5)
	I '$T {
		if intr {
			s ^MIRROR(mirname,"Status","MGR")="Exit"
			d $system.Util.SendInterrupt(mgrpid)
			s intr=0
			g again
		}
		d $zu(9,"","MirrorMgr not quit within 5 seconds after posted to quit",1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0
	} else {
		Lock -^MIRROR(mirname,"MgrJobID")
		Quit 1
	}
}
GetDBInfoFromPrimary(sfn) PUBLIC {
	;Called on an active Backup from the $ZU(17) mount code when a database
	; gets mounted to ask the primary to send us the current characteristics
	; of this database (eg. expandby/maxsize/etc).
	;
	if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	   quit "0,Insufficient privilege to shutdown mirroring"
    }
    s state=$SYSTEM.Mirror.GetInfo()
    if state'["BACKUP" quit
    s dbinfo=$SYSTEM.Mirror.DBGetInfo(0,sfn)
    s mirname=$P(dbinfo,"^",8)
    if ^SYS("MIRRORSET")'[mirname {
	    d $zu(9,"","GetDBInfo: System not part of mirror "_mirname_" for sfn #"_sfn,1 /* broadcast and log message*/,1  /* Warning */)
	    quit
    }
    s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
    if 'mgrpid {
	    d $zu(9,"","GetDBInfo: Control process not running, message not posted",1 /* broadcast and log message*/,1  /* Warning */)
	    quit
    }
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) {
		d $zu(9,"","GetDBInfo: No other systems in the mirror at this time",0,0  /* Informational message */)
		quit
	}
    for id=1:1:systemcnt {
	      s r=$G(^MIRROR(mirname,"Status","Member",id,"Role"))
	      if (r="PRIMARY") quit
	   }
	if (r'="PRIMARY") {
		if (state'["SHADOW") || (r '= "RELAY") {
		   d $zu(9,"","GetDBInfo failed to find primary in Member list, using id #1",1 /* broadcast and log message*/,1  /* Warning */)
		}
		s id=1
	}
	s dbinfo=$SYSTEM.Mirror.DBGetInfo(0,sfn)
	if dbinfo="" quit  ;not a mirrored db
	s dbname=$P(dbinfo,"^",2)
	s dbguid=$P(dbinfo,"^",6)
	s rc=$$SynchDBInfo^MIRRORCTL(mirname,id,dbname,dbguid)
	quit
}
InitDejournal(id,mirname) {
	/* InitDejournal() allocates memory and starts up the helper jobs for
	     the C based "shadow" dejournaling system.
	   id is the id of the mirror this is attached to. If we're a failover
	      node and this is the connection to the primary (eg. the active
	      channel) then this is 1. If we're a reporting member and this is
	      the connection to a primary, it is 2 or more indicating which 
	      primary we're connecting to. If this is for "catching up" older databases
	      then this is 0 and we assign an id here.
	   mirname is the name of the mirror this is attached to
	   Returns 0 - failed, 1 - succeeded
	         For many errors we retry in this routine until we succeed.
	         We only return failure for configuration type errors (eg.
	         mirroring not configured yet).
	  ---------------------------------------------------------------------
	   This is a slightly modified version of the shadow dejournaling system 
	   as these jobs knows they are associated with a mirror. We track the 
	   shared memory id internally and automatically set up redirection for
	   the mirrored databases in the journal files(s) as we open them. 
	   This entry point does not start an  actual "dejournaling" job to process
	   journal files. That is done with either $SYSTEM.Mirror.ProcessFile() to 
	   process a given journal file or by jobbing off StartDejournal() when a 
	   system is becoming a backup mirror member. StartDejournal() drives the 
	   dejournaling of the journal data as it is recieved from the primary.
	   The C based dejournaling system uses a global as temporary storage for
       handling 'very large' string data (HYY1255). The global is stored in 
       the shared memory structures and can have an arbitrary name. Here we 
       generate a global mapped to CacheTemp: 
                    ^CacheTemp("MIRROR",<mirronname>,threadid).
       This is killed off by $SYSTEM.Mirror.DejournalFree() as part of 
       shutting down the dejournaling system. $SYSTEM.Mirror.DejournalFree()
       is mostly called internally by other Mirroring functions (eg. shutdown,
       InitPrimary, etc).
    */
    s $zt="err"
	if mirname="" {
	   d $zu(9,"","Failed to initialize mirror dejournaling: mirror name not specified",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if (id < 1) {
		; make sure the id is >0 because 0 has special meaning
	   d $zu(9,"","("_mirname_") InitDejournal called with invalid id ("_id_"). Id's must be >0",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if $System.Mirror.IsAsyncMember() {
		if +$G(^MIRROR(mirname,"DejournalBlock"))=1 {
			if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","DejrnInit Skipped - Dejournaling for "_mirname_" is marked stopped.")
			quit 1
		}
		s AsyncStopOnError=1
	} else {
		s AsyncStopOnError=0
	}
	s NoDejrnSync= $s($$IsRelayClient^MIRRORCOMM(mirname):0,1:16)
    s dejrnid=mirname_"("_id_"): "
	s tempglo=$name(^CacheTemp("MIRROR",mirname,id))
	d ##class(%SYS.Journal.System).GetDejournalSettings("mirror",mirname,.numprefetch,.quesiz,.stksiz,.sizmod)
 	s x=$SYSTEM.Mirror.DejournalInit(id,tempglo,numprefetch,AsyncStopOnError+sizmod+NoDejrnSync,quesiz,stksiz)  ;JO2553
	q:+x>0 1  ; x>0 means Dejounaling was already initialized
	k ^MIRROR(mirname,"DejournalWorker")
	if +x<0 {
		d $zu(9,"",dejrnid_"Failed to initialize dejournaling memory, rc="_x_" retrying",1 /* broadcast and log message*/,1  /* Warning */)
		s cnt=0,nextmsg=5  ;another message in 5 minutes
		for {
			h 60
		 	s x=$SYSTEM.Mirror.DejournalInit(id,tempglo,numprefetch,AsyncStopOnError+sizmod+NoDejrnSync,quesiz,stksiz)  ;JO2553
		 	quit:x>=0
		 	s cnt=cnt+1
		 	if (cnt = nextmsg) {
			    d $zu(9,"",dejrnid_"Initialization of dejournaling memory still failing - Continuing to retry",1 /* broadcast and log message*/,1  /* Warning */)
			    s nextmsg=nextmsg*2
			    if nextmsg>60 s nextmsg=60  ;max 1 hour apart
			    s cnt=0
		 	}
		}
	    d $zu(9,"",dejrnid_"Initialization of dejournaling memory succeeded - continuing",0,0  /* Informational message */)
	}
	k @tempglo  ;make sure it starts out 'missing'
	; Start some prefetch jobs and the dejournalling job
	job DejrnSetKill(id,mirname,AsyncStopOnError):(:2):10   ;JO2553
    if '$T {
		d $zu(9,"",dejrnid_"Failed to job dejournaling worker process - Retrying",1 /* broadcast and log message*/,1  /* Warning */)
		s cnt=0,nextmsg=6  ;another message in 1 minute
		for {
			h 10  ;10 seconds between retries
			job DejrnSetKill(id,mirname,AsyncStopOnError):(:2):10  ;JO2552
			quit:$T
			s cnt=cnt+1
			if (cnt = nextmsg) {
				d $zu(9,"",dejrnid_"Still failing to start dejournal worker - Continuing to retry",1 /* broadcast and log message*/,1  /* Warning */)
				s nextmsg=nextmsg*2
				if nextmsg>60 s nextmsg=60  ;max 10 minutes
				s cnt=0
			}
		}
		d $zu(9,"",dejrnid_"Dejournal worker job started - continuing",0,0  /* Informational message */)
	}
	for i=1:1:numprefetch {
	   job DejrnPrefetch(id,i-1):(:2):10  ;don't use a jobserver
	   if '$T {
		 d $zu(9,"","Warning failed to job dejournaling prefetch job #"_i_" for "_dejrnid,1 /* broadcast and log message*/,1  /* Warning */)
		 ; don't quit 0 just because we failed to start a prefetch job
	   }
	}
	quit 1 ; success
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
DejrnPrefetch(id,jobnum) PUBLIC {
	s $ZT="DejrnPrefetchErr"
	; This is jobbed off as a prefetch job for dejournaling
	do $SYSTEM.Mirror.DejournalPrefetch(id,jobnum)
	quit
DejrnPrefetchErr ;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Dejournal Prefetch("_id_") Job #"_jobnum_" caught an error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit	
}
DejrnSetKill(id,mirname="",AsyncStopOnError=0) PUBLIC {
	; This is jobbed off as the "worker" (setkill) job for dejournaling
	s $zt="DejrnErr2"
	if id>0 {
	   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(id)
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		  d $zu(9,"","DejrnSetKill exited - Failed to locate sharid for primary id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		  quit
	   }
	} else {
	   s shrid=-id  ;id values <=0 are already shrid values
	}
	if $L(mirname) {
		s jobnum=$ZU(61)
		s ^MIRROR(mirname,"DejournalWorker","pid")=+$J
		s ^MIRROR(mirname,"DejournalWorker","jobnum")=jobnum
		s ^MIRROR(mirname,"DejournalWorker","jobid")=$ZH($ZU(61,30,jobnum))
		s ^MIRROR(mirname,"DejournalWorker","status")="running"
		k ^MIRROR(mirname,"DejournalWorker","errtext")
	}		
	; If we catch an error at DejrnErr then the quit in the error trap
	; returns to call DejournalWorker again. This is how errors during the
	; journal restore are handled. OTOH, if DejournalWorker returns with a value
	; because its shutting down (0) or if something is wrong (-1, -2) then we 
	; want to exit.
	s skiprec=0
	s rc=1  ;DejournalWorker() sets this if we return
	for  do  q:rc'=1
	. s $zt="DejrnErr"
	. s rc=$s(skiprec:$SYSTEM.Mirror.DejournalWorker(id,1),1:$SYSTEM.Mirror.DejournalWorker(id)),skiprec=1
	if rc=0 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalWorker("_id_") shutting down")
	   if $L(mirname) {
   	      s ^MIRROR(mirname,"DejournalWorker","status")="stopped"
	   }
	} else {
	   d $zu(9,"","DejournalWorker("_id_") shutting down due to a problem - status = "_rc,1 /* broadcast and log message*/,1  /* Warning */)
	   if $L(mirname) {
	      s ^MIRROR(mirname,"DejournalWorker","status")="error"
	      s ^MIRROR(mirname,"DejournalWorker","errtext")=rc
	   }
	}
	Do $zu(78,51,-1,0,-1)  ;mark dbupdater job as exited
	; This will cause the prefetch and reader jobs to exit and
	; tear down shared memory. InitDejournal() will start new
	; jobs when it is called.
	s rc=$SYSTEM.Mirror.DejournalFree(id,1)	;doesn't return a useful status	
	quit
DejrnErr2 ;
	s $zt=""
	d $zu(9,"","DejrnSetKill("_mirname_") caught unexpected error: "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	d BACK^%ETN
	try {
		Do $zu(78,51,-1,0,-1)  ;mark dbupdater job as exited
		; DejournalFree() will signal other jobs to exit as well
		s rc=$SYSTEM.Mirror.DejournalFree(id,1)	;doesn't return a useful status	
	} catch {
		d $zu(9,"","DejournalWorker("_id_") caught error shutting down dejournaling: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	}
	quit  ;halt?
DejrnErr ;
    s $zt="DejrnErrCont"
	s info=$zu(78,53,shrid,8) ;addr,sfn,gcol,gref
	s sfn=+$P(info,",",2)   ;JO2528
	s dbinfo=$ZU(49,sfn,3)
	s dbname=$P(dbinfo,"^",2)   ;JO2552
	s addr=+info
	s globcoll=$p(info,",",3)
	s globnode=$p(info,",",4,$l(info))
	s globref="^"_$zu(70,4,globnode,$zu(70,1,globcoll)) 
	s globnam=$qs(globref,0)
	d BACK^%ETN
DejrnErrCont ;
	s $zt=""  ;should we have a 3rd level of error handling?
	/* AsyncStopOnError is set for the main dejournaling connection
	   on a reporting async where if there's an error, rather than continuing
	   without that database, users want all databases to stop so they remain
	   more or less in sync at a given point in time. */
	if AsyncStopOnError&&$SYSTEM.Mirror.AsyncMemberType() {
		d $zu(9,"","Mirror dejournaling suspended for """_mirname_""": Caught error /"_$ZE_"/ working on "_dbname_" (sfn #"_sfn_")",1 /* broadcast and log message*/,2  /* Severe error */)
		Do $zu(78,53,shrid,0,1)
		Do $zu(78,51,-1,0,-1)  ;mark dbupdater job as exited
		; This will cause the prefetch and reader jobs to exit and
		; tear down shared memory. InitDejournal() will start new
		; jobs when it is called.
		s rc=$SYSTEM.Mirror.DejournalFree(id,1)	;doesn't return a useful status	
		; rc<0 generates an error record
		s rc="-1,Caught error "_$ze_" at address "_addr_" working on "_dbname_" (sfn #"_sfn_")"
	} else {
		; Setting SFNSKIP causes future dejournaling to this sfn to be
		; skipped and removes the "db i+n active mirror" flag.
		do $zu(78,76,shrid,sfn)  
		s skiprec=1
		d $zu(9,"","DejournalWorker("_id_") "_$s($SYSTEM.Mirror.IsPrimary():"Primary",$SYSTEM.Mirror.IsBackup():"Backup",1:$SYSTEM.Mirror.GetMemberType())_" member caught error /"_$ZE_"/ working on sfn #"_sfn_". "_dbname_" requires catchup to be activated again",1 /* broadcast and log message*/,2  /* Severe error */)
	}
 	q
}
DejrnReader(id,jrnname,mirjrnfilecnt,jrnpos) PUBLIC {
	/* This is the journal reader job for the mirror dejournaling
	   process. It is jobbed off when this system becomes and active
	   backup member and it process the journal data as it is received from
	   the primary mirror member. Any existing journal data on this machine
	   has already been processed during startup with 
	   $SYSTEM.Mirror.ProcessFile(). InitDejournal() has already been called
	   to initialize shared memory and start the prefetch and setkill jobs.
	   (jrnpos might be zero and jrnname might be null if mirjrnfilecnt
	    is a file we don't have yet and DejournalReader waits for the backup
	    to start sending it to us).
	*/
	s $zt="DejrnReaderErr"
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(id)
	; returns shrid which is 0->n or -1 if there's a problem 
	if shrid<0 {
		d $zu(9,"","DejrnSetReader - Failed to locate sharid for primary id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	} else {
		s prefstrategy=$G(^MIRROR(":config:","PrefetchStrategy"),-100)
		do $ZU(78,90,shrid,prefstrategy)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejrnReader set prefetch chunk size for sharid #"_shrid_" to "_(-prefstrategy))
	}
	s info=$SYSTEM.Mirror.GetInfo(3,id-1)
	s mirname=$P(info,",",1)
	s jobnum=$ZU(61)
	s ^MIRROR(mirname,"DejournalReader","pid")=+$J
	s ^MIRROR(mirname,"DejournalReader","jobnum")=jobnum
	s ^MIRROR(mirname,"DejournalReader","jobid")=$ZH($ZU(61,30,jobnum))
	s ^MIRROR(mirname,"DejournalReader","status")="running"
	k ^MIRROR(mirname,"DejournalReader","errtext")
	s RelayClient=$$IsRelayClient^MIRRORCOMM(mirname)
	s Validate=1
	s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
	if ('rc) {
		d $zu(9,"","DejournalReader ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		s ^MIRROR(mirname,"DejournalReader","errtext")="DejournalReader ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc)
		s ^MIRROR(mirname,"DejournalReader","status")="error"
		Quit
	}
	if filter'="" {
		s FilterObj=$classmethod(filter,"%New")
		if '$isobject(FilterObj) {
			d $zu(9,"","DejournalReader ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
			s ^MIRROR(mirname,"DejournalReader","errtext")="DejournalReader ("_mirname_") failed to run %New() method of class "_filter
			s ^MIRROR(mirname,"DejournalReader","status")="error"
			Quit
		}
		s FilterObj.InCatchupDB = 0
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalReader ("_mirname_") is running filter class "_filter)
	}
retry ;	
	try {
	   if filter'="" {
		   s rc=FilterObj.DejournalReader(id,jrnpos,jrnname,mirjrnfilecnt,Validate)
	   } else {
		   s rc=$SYSTEM.Mirror.DejournalReader(id,jrnpos,jrnname,mirjrnfilecnt,Validate)
	   }
	} catch {
		s Validate=0
		s info=$SYSTEM.Mirror.GetInfo(2)
		s startpos = jrnpos
		s jrncnt=$P(info,",",6)  ;mirinfochkpntjrncnt
		s jrnpos=$P(info,",",7)  ;mirinfochkpntjrnoff
		if RelayClient s jrnpos=$zu(78,94,jrnpos)
		if (jrncnt '= mirjrnfilecnt) {
			s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrncnt,mirname)
			if (+jrnfile<=0) {
				s rc="0,Failed to lookup file name for file #"_jrncnt_" after error: "_$ze
				s ^MIRROR(mirname,"DejournalReader","errtext")=rc
				s ^MIRROR(mirname,"DejournalReader","status")="error"
				quit  ;exit catch block, return to caller
			}
			s jrnname=$P(jrnfile,",",2)
			s mirjrnfilecnt=jrncnt
		} elseif jrnpos<startpos {
			s jrnpos = startpos
		}
		if $ZE["<OBJECT DISPATCH>" {
			d $zu(9,"","Dejournal Read Daemon ("_mirname_") exited abnormally due to Dejournal Filter error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
			s ^MIRROR(mirname,"DejournalReader","errtext")="Dejournal Read Daemon ("_mirname_") exited abnormally due to Dejournal Filter error: "_$ZE
			s ^MIRROR(mirname,"DejournalReader","status")="error"
			quit
		}
		d $zu(9,"","Dejournal Read Daemon ("_mirname_") continuing after an unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Dejournal Reader restarting from ("_jrncnt_","_jrnpos_")")
		h 1
		goto retry
	}
	s ^MIRROR(mirname,"DejournalReader","status")="stopped"
	if '+rc {
		d $zu(9,"","Dejournal Read Daemon("_id_") exited abnormally with status="_$p(rc,",",2,999),1 /* broadcast and log message*/,1  /* Warning */)
		s ^MIRROR(mirname,"DejournalReader","errtext")="Dejournal Read Daemon("_id_") exited abnormally with status="_$p(rc,",",2,999)
		s ^MIRROR(mirname,"DejournalReader","status")="error"
	}
	quit
DejrnReaderErr ;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Dejournal Read Daemon("_id_") caught an error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	if $d(mirname) {
		s ^MIRROR(mirname,"DejournalReader","errtext")="Dejournal Read Daemon("_id_") caught an error: "_$ze
		s ^MIRROR(mirname,"DejournalReader","status")="error"
	}
	quit	
}
GetTPInfoForMissingJournalFile(mirname,mirjcnt) {
	/* Called from ValidateMirrorJournalLog when the dejrnchkpnt file is
	   beyond the end of the local journal log and we need to get the
	   transaction rollback point stored in this journal file so we know
	   which journal file we need to start with.
	   Sends messages to the other node(s) and return the MAX value for the
	   TP rollback information. 
	   Returns: -1 - something went wrong and we failed to find the transroll point   
	            >=0 = transroll point for specified journal file
	*/
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if 'systemcnt {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Can't determine TP info for file #"_mirjcnt_" - no other mirror members")
		quit -1
	}
	k errlist
	s minxfilecnt=0,found=0
    for id=1:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s addr=$lg(info,5)
          s basedir=$lg(info,6)
          s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,3,mirjcnt)
          ; returns $LB(<status>,$LB($SYSTEM.Mirror.GetJournalFileInfo(),$$$JRNHDRALL))
	      s status=$LG(rc)
	      if status="OK" {
		      s val=$LG(rc,2)
		      s mirinfo=$LG(val,1)
		      s jrninfo=$LG(val,2)
			  s index=+$P(jrninfo,",",21+1)
			  s filecnt=+$P(jrninfo,",",20+1)
		      if 'found {
			      s minxfilecnt=filecnt
			      s found=1
		      } elseif (filecnt > minxfilecnt) {
			      ; use the highest minxfilecnt we see as that's
			      ; the one from the primary. If this is a failover
			      ; member, we only contact the 1 other node.
			      s minxfilecnt=filecnt
		      }
	      } elseif status="NOTFOUND" {
	         s errlist(name)="File #"_mirjcnt_" not found"
	      } elseif status="ERR" {
	         s errlist(name)=$LG(rc,2)  ;record reason in case we never find a copy of this file
          }
       }
    }
    if 'found {
	    s msg="("_mirname_") Failed to lookup mintransinfo for file #"_mirjcnt
	    s name=$O(errlist(""),1,err)
	    while name'="" {
		    s msg=msg_$C(10,13)_"     "_name_" reports /"_err_"/"
		    s name=$O(errlist(name),1,err)
	    }
	    d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
	    quit -1  ;failed
    }
    q minxfilecnt   ;>= 0
err ;
	s errstr=$ZE
	d $zu(9,"","Unexpected error: "_errstr,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit -1
}
GetMirrorDejournalInformation(mirname,Type=2) PUBLIC {
	/* Determine current mirror jrnroll point:
            jrnroll point = MAX(jrnroll points across mirrored databases)
            If there aren't any mirrored db's then the jrnroll
            point is zero as a signal we don't have any mirrored dbs.
	     Returns: 0 = something went wrong
	              1 = success
	                  We have at least one mirror database
	   		             ^MIRROR(mirname,"dejrnchkpnt")=<mirjrnfilecnt>^<jrnpos>
	                  We don't have any mirrored databases:
	   		             ^MIRROR(mirname,"dejrnchkpnt")=0
	   The starting point for the journal restore is recorded in the mirror
	   information block for the various mirrored databases. While all the mirrored
	   databases which were part of the active mirror should have the same starting
	   point its possible that some of the databases have been restored from backup,
	   where not accessible when the node was last running, etc. As a result we
	   check all the mirrored db's and find the maximum journal restore point. The 
	   majority (or all) of the mirrored database should have this value as in 
	   general, the databases are going to be "up to date" and only some of them 
	   (if any) will be "older".
	*/
	s $zt="err"
    s dbinfo=$$GetMaxDejrnStart(mirname,Type)
    if '$LG(dbinfo) {
	    ; something went wrong, we can't continue
	    quit 0
    }
	; dbinfo=$Lb(rc,<jrnfilecnt>,<jrnendoff>)
	s jrnfilecnt=$lg(dbinfo,2)
	s jrnpos=$LG(dbinfo,3)
    if '+jrnfilecnt {
	   if Type=1 {
		   s ^MIRROR(mirname,"firstdejrnchkpnt")=0
		   s ^MIRROR(mirname,"dejrnchkpnt")=0
	   } else {
		   s ^MIRROR(mirname,"dejrnchkpnt")=$G(^MIRROR(mirname,"firstdejrnchkpnt"),0)
	   }
	   quit 1  ; success but we don't have any mirrored db's so dejrnchkpnt is zero
    }
     if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","dejrnchkpnt set to maxdbjrninfo position "_jrnfilecnt_","_jrnpos)
    if Type=1 {
	    s (^MIRROR(mirname,"dejrnchkpnt"),^MIRROR(mirname,"firstdejrnchkpnt"))=+jrnfilecnt_"^"_+jrnpos
    } else {
	    s firstfcnt=+$p($g(^MIRROR(mirname,"firstdejrnchkpnt")),"^",1)
 	    s firstpos=+$p($g(^MIRROR(mirname,"firstdejrnchkpnt")),"^",2)
 	    if +jrnfilecnt<firstfcnt||(+jrnfilecnt=firstfcnt&&(+jrnpos<firstpos)) {
	 	    s ^MIRROR(mirname,"dejrnchkpnt")=^MIRROR(mirname,"firstdejrnchkpnt")
 	    } else {
	 	    s ^MIRROR(mirname,"dejrnchkpnt")=+jrnfilecnt_"^"_+jrnpos
 	    }
   }
	quit 1
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
GetMaxDejrnStart(mirname="",Type=2) PUBLIC {
	/* This is called at startup when we need to bring our databases up to
	   date as far as the journal files we have before getting in touch with
	   the other mirror members. This returns the highest position
	   from the "up to date" info of the databases mirror info blocks.
	   Type: 1 - Master daemon at starting up, it looks through all mirrored DBs in SFN table (active and non-active, though there should be no active ones).
	         2 - Master daemon after starting up, it looks through all 'active' mirrored DBs. They must be in SFN table.
	         3 - Non-Master daemon jobs, it looks through all mirrored DBs in SFN table, if any one of the DB is 'active' then calculate the dejrnchkpnt with active DBs, otherwise calculate it with all DBs.
	         4 - Single user mode ISCAgent job, it looks though mirrored DBs in ^SYS("UCI") and calculate the dejrnchkpnt from them.
	   Failure: $LB(0): Something went wrong
	   Success: $LB(1,max jrnfilecnt, max jrnpos)
	   			 If there aren't any mirrored databases, the max position
	   			 is returned as 0,0
	*/
	s maxjrncnt=0,maxend=0,found=0
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,$s(Type=4:0,1:2))
	if '$LG(rc) {
		d $zu(9,"","GetMaxDBJrnInfo: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit rc
	}
	s onlyactive=(Type=2||($LG(rc)>1&&(Type=3)))
	s dir=$o(dblist(""),1,info)
	while dir'="" {
	   if onlyactive,'$P(info,"^",20) {
		   s dir=$o(dblist(dir),1,info)
		   continue
	   }
	   s dbjrncnt=$P(info,"^",3)
	   s dbend=$P(info,"^",4)
	   if 'found {
	      s maxjrncnt=dbjrncnt
		  s maxend=dbend
		  s found=1
	   } elseif dbjrncnt>maxjrncnt {
		  s maxjrncnt=dbjrncnt
		  s maxend=dbend
	   } elseif dbjrncnt=maxjrncnt,dbend>maxend {
		  s maxend=dbend
	   }
	   s dir=$o(dblist(dir),1,info)
	}
	; If we didn't find any mirrored databases we return 0,0 for
	; the 'max' info. 
	quit $LB(1,maxjrncnt,maxend) ;succeeded.
}
GetMaxDBJrnInfo(mirname="") PUBLIC {
	/* This is called at various points where we want to know what is the
	   highest journal position that we care about for databases on this
	   member. This is used to determine how much of a journal file needs
	   to be kept (eg. when setting the valid end), whether the valid end
	   is set too early, etc. This uses the DEJRNTARG point set into the
	   db's as that is the highest point each db cares about. This is 
	   not the position to start dejournaling at (GetMaxDejrnStart).
	   Failure: $LB(0): Something went wrong
	   Success: $LB(1,max jrnfilecnt, max jrnpos)
	   			 If there aren't any mirrored databases, the max position
	   			 is returned as 0,0
	*/
	s maxjrncnt=0,maxend=0,found=0
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
	if '$LG(rc) {
		d $zu(9,"","GetMaxDBJrnInfo: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit rc
	}
	s dir=$o(dblist(""),1,info)
	while dir'="" {
	   s dbjrncnt=$P(info,"^",18)
	   s dbend=$P(info,"^",19)
	   if 'found {
	      s maxjrncnt=dbjrncnt
		  s maxend=dbend
		  s found=1
	   } elseif dbjrncnt>maxjrncnt {
		  s maxjrncnt=dbjrncnt
		  s maxend=dbend
	   } elseif dbjrncnt=maxjrncnt,dbend>maxend {
		  s maxend=dbend
	   }
	   s dir=$o(dblist(dir),1,info)
	}
	; If we didn't find any mirrored databases we return 0,0 for
	; the 'max' info. 
	quit $LB(1,maxjrncnt,maxend) ;succeeded.
}
GetMinDBJrnInfo(mirname="") PUBLIC {
	/* This is called when we're deciding which mirror journal files can
	   be purged.  This returns the earliest journal position from the 
	   "up to date" info of the databases mirror info blocks. This routine
	   is driven off the ^SYS("UCI") list rather than $SYSTEM.Mirror.GetNextDBBySFN
	   because the later works on mounted db's and this may be run by the
	   agent code against a "down" version of Cache. In that case the
	   ^SYS("UCI") list gives us the set of db's which were mounted
	   the last time Cache' was up, or, the list that is currently
	   mounted if Cache' is up.
	   Failure: $LB(0,error) - Failed
	   Success: $LB(1,jrnfilecnt, jrnpos)
	   			 If there aren't any mirrored databases, the min position
	   			 is returned as 0,0
	*/
	s $zt="err"
	s mirname=$zcvt(mirname,"U")
	if mirname="" {
		s mirname=$G(^SYS("MIRRORSET"))
		if mirname="" quit $LB(1,0,0)  ;not a mirror member, we don't need any journal files
		if +mirname'=0 quit $LB(0,$$Error^%apiOBJ(2002))  ;reporting nodes need to pass this 
		s mirname=$P(mirname,"^",2)
		if mirname="" quit $LB(0,$$Error^%apiOBJ(2002)) ;shouldn't happen
	}
	s initialvalue=1E40  ;1E40 is > (uint)$ZH("FFFFFFFFFFFFFFFF")
	s minjrncnt=initialvalue,minend=0  
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,0)
	if '$LG(rc) {
		d $zu(9,"","GetMinDBJrnInfo: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit rc
	}
 	k jrnfilelist
	s dir=""
	for {
		s dir=$o(dblist(dir),1,mirinfo)
		q:dir=""
	    s filecnt=$P(mirinfo,"^",11)
	    if 'filecnt {
		   ; If there's no lastfilecntrestored listed then we use the
		   ; tp rollback info from the journal restore point file instead
		   s filecnt=$P(mirinfo,"^",3)
	    }
	    if filecnt {
			if $D(jrnfilelist(filecnt),tpinfo) {
				s tpindex=+$P(tpinfo,"^",2)
				s tpfilecnt=+tpinfo
			} else {
				s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
				if (+jrnfile<=0) {
					s err=$$Error^%apiOBJ(2000,filecnt,dir,mirname)
					goto fail
				}
				s file=$P(jrnfile,",",2)
				s jrninfo=$zu(78,22,file,99)
				if +jrninfo'=1 {
					s err=$$Error^%apiOBJ(2001,file)
					goto fail
				}
				s tpindex=+$P(jrninfo,",",21+1)
				s tpfilecnt=+$P(jrninfo,",",20+1)
				s tpinfo=tpfilecnt_"^"_tpindex
				s jrnfilelist(filecnt)=tpinfo
				if tpfilecnt<minjrncnt {
					s minjrncnt=tpfilecnt
					s minend=tpindex
				} elseif tpfilecnt=minjrncnt,tpindex<minend {
					s minend=tpindex
				}
			}
	    }
	}
	; If we didn't find any mirrored databases we return 0,0 for
	; the 'min' info. 
	if minjrncnt=initialvalue {
		s minjrncnt=0
		s minend=0
	}
	quit $LB(1,minjrncnt,minend) ;succeeded.
err ;
	quit $LB(0,$ZE)	
fail ;
    quit $LB(0,err)	
}
LookupTransactionRollbackPoint(mirname,filecnt) PUBLIC {
	; Given a mirror journal file return the transaction rollback
	; point stored in its journal header. This is used both
	; by startup to set the "transroll" node and from MIRRORCTL
	; when getting the minimum required journal file for a system
	; as part of deciding what files can be purged.
	;
	if 'filecnt quit $LB(1,0,0)
    s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
    if +jrnfile<=0 {
	    d $zu(9,"","GetTransactionRollbackPoint: Failed to find file #"_filecnt_" in log",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB(0)
	}
	s file=$P(jrnfile,",",2)
	s jrninfo=$zu(78,22,file,99)
	if +jrninfo'=1 {
	   d $zu(9,"","GetTransactionRollbackPoint: Failed to read the header of the file: "_file,1 /* broadcast and log message*/,1  /* Warning */)
	   quit $LB(0)
	}
	s minxindex=+$P(jrninfo,",",21+1)
	s minxfilecnt=+$P(jrninfo,",",20+1)
	quit $LB(1,minxindex,minxfilecnt)
}
GetTransactionRollbackPoint(mirname,filecnt) {
	; Giving a journal file # get the transaction rollback point
	; from that file and store it in the "transroll" node.
	s rc=$$LookupTransactionRollbackPoint(mirname,filecnt)
	if '+$LG(rc) {
		quit 0
	}
	s minxindex=$LG(rc,2)
	s minxfilecnt=$LG(rc,3)
	s ^MIRROR(mirname,"transroll")=minxfilecnt_"^"_minxindex
	quit 1
}
ValidateMirrorJournalLog(mirname) PUBLIC {
	/* If the mirror journal log exists, validate the header. If the
	   header is invalid or the guid's do not match, delete the file.
	   Exits with 
	      ^MIRROR(mirname,"transroll")=minxtransfilecnt^minxtranspos
	             corresponding to dejrnchkpnt or to 0 if we don't have one
	   If the file doesn't exist, create it an populate it with whatever
  	   journal files we find in the current/alternate journal directories.
	   If dejrnchkpnt is beyond the last file listed in the log then return.
	   Otherwise, open that file and pull out the mintransindex from the header.
	   If this is non-zero then use this as our 'minreqfilecnt'. If it is zero
	   then use the dejrnchkpnt file.
	   For each journal file between the minreqfilecnt point and the 
	   last file listed in the log:
          a) if record is missing from log file => report an
             error that the log file needs to be rebuild and 
             return failure
          b) if file doesn't not exist on disk, retrieve file
             from other mirror member and if we fail, report
             an error and return failure
    */
    s $zt="err"
	s mir=##class(Config.Mirrors).Open(mirname)
	s mirguid=$s($IsObject(mir):mir.GUID,1:"")
	/* Get local mirror GUID from configuration, if not configured then use the
	   Instance GUID. */
	s mir=##class(Config.MirrorMember).Open()
	s lguid=""  ;local mirror system guid
	s sysname=$s($IsObject(mir):mir.SystemName,1:"")
	i sysname'="" {
	   if (mir.isAsyncMember()) {
		   s isasync=1
		   s lguid=mir.GetAsyncMemberGUID()
		   s mirguid=^SYS("MIRRORSET",mirname,"GUID")
	   } else {
		   k params
		   s x=##class(Config.MapMirrors).Get(mirname,sysname,.params)
		   if ('x) {
			 	 k err
		   		 Do DecomposeStatus^%apiOBJ(x,.err,"-d") 
				 w !,"Failed to read mirror set member info for: ",name
				 for i=1:1:err w !,?5,err(i)
				 d $zu(9,"","Error reading mirror set member info for "_name_". Text: "_err,1 /* broadcast and log message*/,1  /* Warning */)
		   } else {
 		      s lguid=$G(params("GUID"))
		   }
	   }
	}
	if (mirguid="") || (lguid="") {
	   d $zu(9,"","ValidateMirrorJournalLog error: Configuration is missing mirror guid or local guid",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	;
	s create=1
	s logf=$ZU(12)_"mirrorjrn-"_mirname_".log"
	if '$zu(140,4,logf) {
		; if the file exists, open it and check the header
	    o logf:"RSK\UTF8\":5
	    if '$t quit "0,Failed to open mirror journal log file"
	    k header
	    s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
	    close logf
	    i 'rc {
		    ; failed to read the header, delete the file
		    d $zu(9,"","Failed to read mirror journal log header, deleting log file",1 /* broadcast and log message*/,1  /* Warning */)
	    } else {
		    for i=1:1 {
			    s x=$D(header(i),v)
			    quit:'x
			    s header($P(v,"="))=$P(v,"=",2)
		    }
		    if (header("MirrorSetGUID")'=mirguid) {
			   d $zu(9,"","Mirror GUID in log ("_header("MirrorSetGUID")_") doesn't match mirror guid ("_mirguid_")",1 /* broadcast and log message*/,1  /* Warning */)
		    } elseif (header("LocalMirrorGUID") '= lguid) {
			   d $zu(9,"","Local GUID in log ("_header("LocalMirrorGUID")_") doesn't match local guid ("_lguid_")",1 /* broadcast and log message*/,1  /* Warning */)
		    } else {
			   s create=0  ;file is ok
		    }
	    }
	}
	;
	s pass=1
rebuild ;	
	if create {
	   s rc=$$BuildMirrorLogFromJournalFiles^MIRRORCOMM(mirname,0,"")
	   if +rc<0 {
		   d $zu(9,"","Failed to build new mirror journal log file. "_$P(rc,",",2,*),1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0	   
	   }
	}
	s minreqfilecnt=+^MIRROR(mirname,"dejrnchkpnt")  ;might be 0 if we don't have any files
	if 'minreqfilecnt {
		s ^MIRROR(mirname,"transroll")=0
		quit 1
	}
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s havejrncnt=+rc  ;can be 0 if we don't have any files
	if minreqfilecnt>havejrncnt {
	   s jrnfilecnt=$$GetTPInfoForMissingJournalFile(mirname,minreqfilecnt)
	   if jrnfilecnt<0 {
		   d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to find transaction rollback point for file #"_minreqfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	   }
	   if jrnfilecnt'=0 {
		   s minreqfilecnt=jrnfilecnt
	   }
	}
	s ^MIRROR(mirname,"transroll")=minreqfilecnt
	if minreqfilecnt>havejrncnt {
		quit 1
	}
	i +$g(isasync) do $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
	s rebuild=0
	for filecnt=minreqfilecnt:1:havejrncnt {
	   s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	   if +jrnfile>0 {
		  s file=$P(jrnfile,",",2)
	 	  s jrninfo=$zu(78,22,file,99)
		  if +jrninfo'=1 {
		      if '$$RetrieveJournalFile(mirname,filecnt,0,1,1) {
		         d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to retrieve journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		         goto failed
		      }
		  }
	   }
	   if +jrnfile<=0 {
	      if pass=2 {
			 ; after the 1st pass if we're still missing a file, we give up
		     d $zu(9,"","("_mirname_") ValidateMirrorJournalLog still missing journal #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     goto failed
		  }
		  d $zu(9,"","("_mirname_") ValidateMirrorJournalLog retrieving missing file #"_filecnt,0,0  /* Informational message */)
		  if '$$RetrieveJournalFile(mirname,filecnt,0,0,1) {
		     d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to retrieve journal file #"_filecnt_" without checking log file",1 /* broadcast and log message*/,1  /* Warning */)
		     goto failed
		  }
		  s rebuild=1
	   }
	}
	if rebuild {
	   s pass=2
	   s create=1
	   goto rebuild
	}
	quit 1
failed ;
	quit 0	
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","ValidateMirrorJournalLog: Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
ValidateMirrorJournalFiles(mirname, forceBecomePrimary=0) {
	/* Validate the mirror journal files which we have. This is a two
	   part process. We want to mark the end of the journal files we
	   have as valid so we can restore them to the mirrored databases. 
	   However for the files which are already marked valid, we need
	   to verify that both members agree on who created the file and
	   where the valid end is. If there is disagreement then there's a
	   problem as the databases will be out of sync across the mirror.
	   On input, ^MIRROR(mirname,"transroll") contains the 1st
	   file which we need to have. This is the 'required' journal
	   file.
	   Returns 1 = success, caller can continue
	            0 = failure, something went wrong, caller should stop
	   Sets ^MIRROR(mirname,"lastvalidjrnfile")=<mirjrncnt>^<jrnfile>
       1) Walk backwards from last journal file. Stop when we reach the required
          journal file or a journal file who's end is marked valid (this is called
          a valid journal file).
	   2) Starting with the required file or the 1st not-valid file
	   	  retrieve the end & state from "the mirror". 
	   	  State is one of: 
              Agent is down, node can't respond
              File is beyond end of log
              File is missing in log
              File has valid end
              File end is not valid
              File is current mirror journal file
           a) Agent is down => 
                forceBecomePrimary = 0 -> Report "failed to validate", Return FAILURE
                forceBecomePrimary = 1 -> mark current end as valid & log a message
           b) File is missing in other node's log file => 
                                    Report failed to validate, Return Failure
	 	   c) File is beyond the end of the other node's log file
	 		  Is this our last not-valid journal file?
	 			 -> Yes:
	                  is other node primary? yes-> big error 
	                  Mark current journal end as valid, Return SUCCESS
                 -> No: Report Error. Check to see if we can find file 
                            on other system. return FAILURE - something is wrong
                            here, the file should have been in the other node's 
                            log or it should be our last not-valid file....
           d) File is the current journal file
              Is this our last not-valid journal file?
                 -> No: Shut down mirror, big troubles, return FAILURE
                 -> Yes: Return Success
           e) If other size > our size
                 -> Retrieve missing parts of file
                 -> If end is not marked valid, set valid end to 
                     the end of file (on all nodes)
           f) other size <= our size
	 			 -> if not valid end, set valid end to
	 			 	our size otherwise set our valid
	 				end to the valid end reported by
	 				the other node.
	*/
	s $zt="err"
	k ^MIRROR(mirname,"lastvalidjrnfile")
	s minrequiredjrncnt=+^MIRROR(mirname,"transroll")
	if 'minrequiredjrncnt {
		s minrequiredjrncnt=+^MIRROR(mirname,"dejrnchkpnt")
	}
	if (forceBecomePrimary||($SYSTEM.Mirror.IsMember()=1&&$G(^MIRROR(mirname,"CheckExtraFiles")))) {
		s rc=$$CheckForExtraJournalFiles(mirname)
		if 'rc {
			quit 0
		}
	}
    k ^MIRROR(mirname,"CheckExtraFiles") ; reset., so it won't check checked again.
    ;
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   ; This is an error reading the log file (rc<0). This shouldn't happen. 
	   d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if '+rc {
	   ; the log file exists, but its empty, this is fine
	   quit 1  ;ok, we don't have any journal files
	}
	s lastjrncnt=+rc
	s isValid=0
	s jrncnt=+rc
	s jrnfile=$P(rc,",",2)
	k filelist
	if 'minrequiredjrncnt {
		; If neither transroll nor dejrnchkpnt are defined the
		; we only need to validate the last journal file we have
		s minrequiredjrncnt=jrncnt
		s norequiredfiles=1  ;don't require any journal files
	} else {
		s norequiredfiles=0
	}
	do {
	   s rc=$$getMirJrnEnd(jrnfile)
	   if rc>0 {
		  s validend=+rc
		  s isValid=1
	   } elseif 'rc {
	      s filelist(jrncnt)=jrnfile
	      s jrncnt=jrncnt-1
	      if jrncnt>=minrequiredjrncnt {
	         s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrncnt,mirname)
	         if rc<=0 {
	            d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read log info for file #"_jrncnt,1 /* broadcast and log message*/,1  /* Warning */)
	            quit
	         }
		     s jrnfile=$P(rc,",",2)
	      }
	   } else {
		   ; these files should already exist and be accessible
		   d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed (rc="_rc_") to open journal file "_jrnfile_" (#"_jrncnt_")",1 /* broadcast and log message*/,1  /* Warning */)
		   quit
	   }
	} while (jrncnt>=minrequiredjrncnt) && ('isValid)
	if +$G(^MIRROR(mirname,"PrimaryMember"))&&isValid&&(jrncnt=lastjrncnt) {
		s jrninfo=$zu(78,22,jrnfile,99)
		if +jrninfo'=1 {
			d $zu(9,"","("_mirname_") Failed to read header of "_jrnfile_" in ValidateMirrorJournalFiles",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		s locmirend=$P(jrninfo,",",16+1)
		s loccreguid=$P(jrninfo,",",14+1)  ;mirror system guid that created jrnfile
		s jrnguid=$P(jrninfo,",",7+1)
		s rcx=$$GetJournalEnd^MIRRORCTL(mirname,+$G(^MIRROR(mirname,"PrimaryMember")),jrnguid,jrncnt)
		if $LG(rcx)=-1 {
			s errstr=$LG(rcx,2)
			if errstr["GUID "&&(errstr[" doesn't match") {
				d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles: GetJournalEnd returned: "_errstr,1 /* broadcast and log message*/,1  /* Warning */)
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","("_mirname_") ValidateMirrorJournalFiles: GetJournalEnd returned: "_errstr)
		} elseif $LG(rcx)'=0 {
			s validflag=$LG(rcx,2)  ;1 = validend, 2 = current journal file (shouldn't happen)
			if validflag'=1 {
				if validflag=2 {
					d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has valid end while it is primary's current journal.",1 /* broadcast and log message*/,1  /* Warning */)
				} else {
					d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has valid end while it has not valid end in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				}
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if locmirend'=$LG(rcx,3) {
				d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has valid end ("_locmirend_") while it is "_$LG(rcx,3)_" in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if $LG(rcx,4)'=loccreguid {
				d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has system GUID ("_loccreguid_") while it is "_$LG(rcx,4)_" in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_" is last file in async member and matched with primary.")
		}
	}
	;
	if jrncnt>=minrequiredjrncnt {
		if (rc <= 0) {
			quit 0 ;some error occured
		}
		for filecnt=minrequiredjrncnt:1:jrncnt-1 {
			 s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	         if rc<=0 {
	            d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read log info for file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	            quit
	         }
		     s filename=$P(rc,",",2)			
		     s rc=$$getMirJrnEnd(filename)
		     if rc<0 {
			    quit  ;couldn't read the file, already logged a message
		     }
			 if 'rc {
				s rc=$$SetValidJournalFileEnd^MIRRORCOMM(mirname, filecnt, filename, 0, 0) ;lastflag=0,forceBecomePrimary=0
				if (rc) {
					d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles set validend of file #"_filecnt_" ("_filename_", subsequent files up to "_jrncnt_" are already marked valid)",0,0  /* Informational message */)
				} else {
					d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles Aborting - found end of file #"_filecnt_" ("_filename_") is not valid but subsequent files up to "_jrncnt_" are marked valid.",1 /* broadcast and log message*/,1  /* Warning */)
					quit  ;we have to stop
				}
			 }
		}
		if (rc <= 0) {
			quit 0 ;some error occured
		}
		s ^MIRROR(mirname,"lastvalidjrnfile")=jrncnt_"^"_jrnfile
		if jrncnt=lastjrncnt {
		   quit 1
		}
	}
	; jrncnt is the earliest valid file
	s rc=1
	s jrncnt=jrncnt+1  ;jrncnt is now the 1st not valid file
	for filecnt=jrncnt:1:lastjrncnt-1 {
		s jrnfile=filelist(filecnt)
		s rc=$$SetValidJournalFileEnd^MIRRORCOMM(mirname, filecnt, jrnfile, 0, forceBecomePrimary) ;lastflag=0
		q:'rc
	}
	if rc,jrncnt<=lastjrncnt {
	   s jrnfile=filelist(lastjrncnt)
	   s rc=$$SetValidJournalFileEnd^MIRRORCOMM(mirname, lastjrncnt, jrnfile, 1, forceBecomePrimary) ;lastflag=1
	}
	if 'rc && ((jrncnt<minrequiredjrncnt) || norequiredfiles) {
  	    s delrc=$zu(140,5,jrnfile) 
  	    if delrc {
	  	    d $zu(9,"","Failed to delete journal file "_jrnfile_" (#"_jrncnt_") which does not have a valid end but precedes the earliest required file #"_minrequiredjrncnt_" (error code = "_delrc_")",1 /* broadcast and log message*/,1  /* Warning */)
  	    } else {
	  	   	d $zu(9,"","Deleted journal file "_jrnfile_" (#"_jrncnt_") which does not have a valid end but precedes the earliest required file #"_minrequiredjrncnt,0,0  /* Informational message */)
  	        if jrncnt=lastjrncnt {
  	           quit 1
  	        }
  	    }
	}
	quit rc  ;0/1
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","ValidateMirrorJournalFiles: Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
RetryValidateMirrorJournalLog(mirname,Type=2) PUBLIC {
	k ^MIRROR(mirname,"dejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"transroll")    ;set by ValidateMirrorJournalLog
	k ^MIRROR(mirname,"lastvalidjrnfile") ;set by ValidateMirrorJournalFiles
	s rc=$$GetMirrorDejournalInformation(mirname,Type)
	if 'rc {
	   ; strange that this fails now but it succeeded before
	   ; (eg. because we got down to ValidateMirrorJournalFiles)
	   quit 0
	}
    s rc=$$ValidateMirrorJournalLog(mirname)
    quit rc
}
RetryValidateMirrorJournalFiles(mirname) PUBLIC {
	k ^MIRROR(mirname,"dejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"transroll")    ;set by ValidateMirrorJournalLog
	k ^MIRROR(mirname,"lastvalidjrnfile") ;set by ValidateMirrorJournalFiles
	s rc=$$GetMirrorDejournalInformation(mirname)
	if 'rc {
	   ; strange that this fails now but it succeeded before
	   ; (eg. because we got down to ValidateMirrorJournalFiles)
	   quit 0
	}
    s rc=$$ValidateMirrorJournalLog(mirname)
    if 'rc {
	   ; strange that this fails now but it succeeded before
	   ; (eg. because we got down to ValidateMirrorJournalFiles)
	   quit 0
	}
	; See whether validate journal files succeeds now
	s rc=$$ValidateMirrorJournalFiles(mirname)
	quit rc
}
RetryClearActiveBackup(mirname) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if info="" {
		d $zu(9,"","RetryClearActiveBackup continuing - found 2nd failover member is no longer listed",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ; success, we can continue
	}
	s mtype=+$LG(info,8)
	if mtype'=0 {
		d $zu(9,"","RetryClearActiveBackup continuing - found member #1 (type "_mtype_") is no longer a failover member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ;success
	}
	s name=$lg(info,1)
	s rc=$$ClearActiveBackup^MIRRORCTL(mirname,1)
	if $LG(rc)="OK" {
		d $zu(9,"","RetryClearActiveBackup succeeded - continuing",0,0  /* Informational message */)
		quit 1
	}
	quit 0  ;continue to retry
}
RetryClearLastFileValid(mirname) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if info="" {
		d $zu(9,"","RetryClearLastFileValid continuing - found 2nd failover member is no longer listed",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ; success, we can continue
	}
	s mtype=+$LG(info,8)
	if mtype'=0 {
		d $zu(9,"","RetryClearLastFileValid continuing - found member #1 (type "_mtype_") is no longer a failover member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ;success
	}
	s name=$lg(info,1)
	s rc=$$ClearLastFileValidFlag^MIRRORCTL(mirname,1)
	if $LG(rc)="OK" {
		d $zu(9,"","RetryClearLastFileValid succeeded - continuing",0,0  /* Informational message */)
		quit 1
	}
	quit 0  ;continue to retry
}
RetryGetMissingMirrorJournalFiles(mirname) PUBLIC {
	/* this is the entry point added to the retry list when 
	   GetMissingMirrorJournalFiles fails. This entry point will retry
	   the GetMissingMirrorJournalFiles but if that fails it will also
	   re-evaluate what journal file we require in case that has
	   changed as well (eg. someone refreshed the databases from
	   a backup). 
	*/
	s rc=$$GetMissingMirrorJournalFiles(mirname)
	if rc {
		quit 1  ;succeeded!
	}
    s rc=$$RetryValidateMirrorJournalLog(mirname)
    if 'rc {
	   if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
	   quit 0   ;failed, keep retrying
	}
	s rc=$$GetMissingMirrorJournalFiles(mirname)
	if rc {
		quit 1  ;succeeded!
	}
	if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
	quit 0  ;still failed, oh well.
}
GetMissingMirrorJournalFiles(mirname,forceBecomePrimary=0) PUBLIC {
	/* If the transroll point is prior to the end of the log file then
	   all of the files from the transrollpoint through last file in log 
	   exist and are valid. If the transroll point is beyond the end of
	   the log, we don't know anything about the validity of the files
	   in the log.
	   Calculate highest journal file # across ALL mirror members
	      a) if no mirror journal files => return success
	      b) if we don't have a required journal file then get the highest
	         journal file which exists and return success
          c) retrieve the files from our required point through the highest 
	         journal file in the mirror
		     -> If we fail, log a message and return FAILURE
	*/
	s $zt="err"
	s rc=$$ValidateMirrorJournalFiles(mirname,forceBecomePrimary)
	if 'rc {
		quit 0
	}
	;^MIRROR(mirname,"transroll")=<mirjrnfilecnt>^<jrnpos>
	s reqjrncnt=+$G(^MIRROR(mirname,"transroll"))
	if 'reqjrncnt {
	   s reqjrncnt=+$G(^MIRROR(mirname,"dejrnchkpnt"))
	   ; reqjrncnt might still be 0 in which case we don't
	   ; have a required journal file but we still want to
	   ; see whether the other node (if there is one) has any
	   ; journal files we don't have.
	}
	; Figure out the last file we have, if we have any, so we
	; can figure out what range of files we want to retrieve
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   ; This is an error reading the log file (rc<0)
	   d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s havejrncnt=+rc  ;can be 0 if the log file is empty
	s lastjrnfile=$p(rc,",",2)
	;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to read mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s reportingNode=cls.isAsyncMember()
	s cls=""
	;
	s systemcnt=+$G(^SYS("MIRRORSET",mirname,"Member"))  ;0 = only us in the mirror
	if 'systemcnt {
		; we're the only node in the mirror. If we don't have the required
		; journal file then the other node must have been deleted from the mirror
		; but we still need some files from it.
		if havejrncnt<reqjrncnt {
		   quit 0
		}
		quit 1  ;we're the only member and we have the files we need!
	}
	; There is more than one node. Node #1 is always a failover member.
	; If we're a reporting node and there are 3 nodes in the mirror,
	; then node #2 is also a failover node
	s id=1
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" {
        d $zu(9,"","Missing node information for member #"_id_" - GetMissingMirrorJournalFiles aborted",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
   	s name=$lg(info,1)
    s mtype=+$lg(info,8)  ;0 = failover, 1 = relay server, 2 = async
    if mtype=0 {
	  s rc=$$GetStatus^MIRRORCTL(mirname,id)
	  s status=$LG(rc)  
      if status'="PRIMARY",reportingNode {
	    ; if we're a reporting node connecting to a failover node,
	    ; then we need to reach the primary here.
	    ; Systemcnt=1 means there are 2 nodes, systemcnt=2 means
	    ; there are 3 and id #2 is the other failover node
	    if systemcnt>1 {
		    s id=2
	  	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
			if info="" {
	           d $zu(9,"","Missing node information for member #"_id_" - GetMissingMirrorJournalFiles aborted",1 /* broadcast and log message*/,1  /* Warning */)
		       quit 0
	        }
		 	s name=$lg(info,1)
    		s rc=$$GetStatus^MIRRORCTL(mirname,id)
    		s status=$LG(rc)  
	    }
	    if status'="PRIMARY" {
		    ; there isn't a primary so we can't continue. 
		    d $zu(9,"","No primary for "_mirname_" to provide missing journal files to async member - waiting",1 /* broadcast and log message*/,1  /* Warning */)
		    quit 0
	    }
      }
      if status="PRIMARY" do $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
    } else {
	    s rc=$LB(0,0)
    }
	/*  Calculate highest journal file # across ALL mirror members
	    a) if no mirror journal files => return success
	    b) if ^MIRROR(mirname,"dejrnchkpnt") is missing (we don't
	       have any jrnfile) then get only they highest jrn file in
	       the mirror
        c) retrieve the files from dejrnchkpnt through the highest 
	       journal file in the mirror
	       -> If we fail, log a message and return FAILURE
	*/
	s maxjrncnt=+$LG(rc,2)  ;might be 0 for "ERR" or "TIMEOUT"
	if 'maxjrncnt {
	   s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,1) ;get min/max jrninfo
	   s status=$LG(rc)
	   if status="ERR" {
		  if (forceBecomePrimary)&(havejrncnt>=reqjrncnt) {
			   d $zu(9,"","GetMissingMirrorJournalFiles ignoring failure to contact other node, have/req (#"_havejrncnt_"/#"_reqjrncnt_")",0,0  /* Informational message */)
			   quit 1
		   }
		   d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles error /"_$LG(rc,2)_" reading min/max journal info from "_name,1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	   }
	   if status="NOTFOUND" {
		  if havejrncnt<reqjrncnt {
		     quit 0
		  }
		  quit 1  ;success, other node doesn't have any files, we have files we need
	   }
	   s jrninfo=$LG(rc,2)
	   s maxjrncnt=$LG(jrninfo,2)
	}
	; 
	if havejrncnt>=maxjrncnt {
		if havejrncnt=maxjrncnt {
			s dejrnchkinfo=$$GetStartingDejrnPos(mirname)
			s dejrnchkcnt=+dejrnchkinfo
			s dejrnchkoff=+$P(dejrnchkinfo,"^",2)
			if havejrncnt=dejrnchkcnt {
				s fd=$zu(78,5,lastjrnfile,0) ;lastjrnfile is the havejrncnt/dejrncnhkcnt/maxjrncnt file
				s jrnendx=0  ; In case we can't open lastjrnfile to find the end
				if fd'<0 {
					do $zu(78,6,fd)
					s jrnend=$zu(78,18,0)
					s jrnendx=jrnend
					if $$IsRelayClient^MIRRORCOMM(mirname) s jrnendx=$zu(78,94,jrnend)
					do $zu(78,7,fd)
				}
				if (fd<0) || (dejrnchkoff>jrnendx) {
					if '$$RetrieveJournalFile(mirname,dejrnchkcnt,jrnendx,1,1) {
						d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to retrieve journal file #"_dejrnchkcnt_" from offset "_jrnendx,1 /* broadcast and log message*/,1  /* Warning */)
						quit 0
					}
				}
			}
		}
		quit 1
	}
	s ok=1,startoff=0
	if havejrncnt,(havejrncnt>=reqjrncnt) {
		s rc=$$getMirJrnEnd(lastjrnfile)
		if (rc > 0) {
			s startcnt=havejrncnt+1
		} else {
			s fd=$zu(78,5,lastjrnfile,0) ;lastjrnfile is the havejrncnt file
			if fd'<0 {
				do $zu(78,6,fd)
				s startoff=$zu(78,18,0)
				do $zu(78,7,fd)
			}
			s startcnt=havejrncnt
		}	
	} else {  
	   ;havejrncnt & reqjrncnt are 0 or havejrncnt<reqjrncnt - reqjrncnt is the 1st file we need
	   s startcnt=reqjrncnt
	   if 'startcnt {
		   s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,5)
		   s status=$lg(rc)
		   if (status="ERR"),($LG(rc,2)["Unrecognized function") {
		      s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,4)
		      s status=$lg(rc)
		      if (status="DBINFO")||(status="TRANSINFO") s status="OK"
		   }
		   if (status="OK") {
			   s startcnt=$lg(rc,2)
			   if startcnt=0 s startcnt=maxjrncnt 
		   } else {
			   s startcnt=maxjrncnt
		   }
	   }
	}
	if startcnt<1 s startcnt=1
	s dejrnstarted=$$CheckStartDejournalProcessor(mirname,startcnt-1,0)
newfiles  ;
	for filecnt=startcnt:1:maxjrncnt {
		; retrieve the files from our dejrncnkpnt through the highest
		; file in the mirror and update the ends to be valid. We don't
		; require the last file to have a valid end if it is the current
		; file being generated on the active primary
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
		if +rc=1 {
			s jrnfile=$P(rc,",",2)
			s jrninfo=$zu(78,22,jrnfile,99)
			if +jrninfo>0 goto getend
		}
	   if '$$RetrieveJournalFile(mirname,filecnt,$s(filecnt=startcnt:startoff,1:0),1,1) {
		  if 'reqjrncnt,filecnt'=maxjrncnt {
			  ; if we don't have a required journal file then the only
			  ; file which we really "HAVE" to retrieve is the maxjrncnt
			  ; file because we want to have that file when we connect
			  ; as a backup or become the primary so we ask for/create
			  ; the next file in the sequence.
		      d $zu(9,"","("_mirname_") Ignoring failure to retrieve missing journal file #"_filecnt,0,0  /* Informational message */)
			  continue
		  }
	      d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to retrieve journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      s ok=0
	      quit
 	   }
 	   s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
 	   if +rc'=1 {
	      d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to lookup name for file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      s ok=0
	      quit
 	   }
 	   s jrnfile=$P(rc,",",2)
getend s lastmirjrnend=$$getMirJrnEnd(jrnfile)
	   if lastmirjrnend<0 {
		   ; error finding, opening or reading file
	      d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed checking valid end of file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      s ok=0
	      quit
	   }
	   if lastmirjrnend=0 {
 	      if (filecnt=maxjrncnt) {
	 	     s lastflag=1
 	      } else {
	 	     s lastflag=0
 	      }
	      if '$$SetValidJournalFileEnd^MIRRORCOMM(mirname,filecnt,jrnfile,lastflag,forceBecomePrimary) {
	         d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed setting valid end of file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     s ok=0
		     quit
	      }
	   } else {
		   if filecnt>(+$G(^MIRROR(mirname,"lastvalidjrnfile"))) {
			   s ^MIRROR(mirname,"lastvalidjrnfile")=filecnt_"^"_jrnfile
		   }
	   }
	   if dejrnstarted<0 {
		   s dejrnstarted=$$CheckStartDejournalProcessor(mirname,filecnt,lastmirjrnend)
	   } elseif dejrnstarted=1 {
		   s dejrnstarted=$$AddFileToDejournalProcessor(mirname,filecnt,jrnfile)
	   }
	}
	if dejrnstarted>0 {
		while '$$StopDejournalProcessor(mirname,ok) {
			s rc=$$GetStatus^MIRRORCTL(mirname,id)
			if $LG(rc)="PRIMARY",+$LG(rc,2)>maxjrncnt {
				s startcnt=maxjrncnt
				s maxjrncnt=+$LG(rc,2)
				s startoff=0
				if (+$g(lastmirjrnend) > 0) {
					s startcnt=startcnt+1
				} else {
					s fd=$zu(78,5,jrnfile,0) ;jrnfile is the last file retrieved
					if fd'<0 {
						do $zu(78,6,fd)
						s startoff=$zu(78,18,0)
						do $zu(78,7,fd)
					}
				}
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","GetMissingJournalFiles: ("_mirname_") re-retrieving journal files from "_startoff_"/"_startcnt_" to "_maxjrncnt)
				goto newfiles
			}
			q:($G(^MIRROR(mirname,"Status","MGR"))="Exit")
			h .5
		}
		s rc=$$UpdateMirrorJournalCheckPoint(mirname)
		if '+rc {
			d $zu(9,"","GetMissingMirrorJournalFiles: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	quit ok
err ;
	s $zt=""
	d BACK^%ETN
	if +$G(dejrnstarted)>0 {
		Do StopDejournalProcessor(mirname,0)
		s rc=$$UpdateMirrorJournalCheckPoint(mirname)
		if '+rc {
			d $zu(9,"","GetMissingMirrorJournalFiles(err): UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	d $zu(9,"","GetMissingMirrorJournalFiles unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0	
}
 /* CheckForExtraJournalFiles() is called from ValidateMirrorJournalFiles()
	when the force become primary flag is set to see whether the user has put any
	journal files into our journal directory(ies) from the failed system. If so
	we delete the mirror journal log and rebuild it so it includes these new
	files. This must be called before we start to evaluate the "valid end" of the
	last file as we base our last file decision on the mirror journal log so we
	need the list to be accurate. 
	Returns:
		 1 - Found new journal files, rebuilt the log file
		 0 - failed, some error occured
		-1 - Succeeded but not new files were found
 */
CheckForExtraJournalFiles(mirname) PUBLIC {
	s $zt="err"
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc=-1 {
		; This is an error reading the log file other than the log file
		; doesn't exist. This shouldn't happen. 
		d $zu(9,"","("_mirname_") CheckForExtraJournalFiles failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0
	}
	if +rc=0 {
		d $zu(9,"","("_mirname_") CheckForExtraJournalFiles failed to open mirror journal file to lookup last journal file",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0
	}
	s lastjrnfilecnt=+rc    ;1st piece = jrnfilecnt
	s lastjrnfile=$P(rc,",",2)  ; 2nd piece = jrnfilename
	;
	/* Get mirror set GUID from the configuration. */
    s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	if mirguid="" {
		d $zu(9,"","CheckForExtraJournalFiles mirror GUID for "_mirname_" not defined.",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0		; Halt here? this is pretty serious
	}
	; Go through the primary and alternate directories looking for journal files
	; from the mirror which follow the last file listed in the mirror journal log
	; If we find one, we go off to rebuild which deletes the mirror journal log
	; and then rebuilds it.
	k dirlist
	s dir=$G(^%SYS("JOURNAL","CURDIR"),"")
	if dir'="" {
		s dirlist(dir)=""
	}
	s dir=$G(^%SYS("JOURNAL","ALTDIR"),"")
	if dir'="" {
		s dirlist(dir)=""
	}
	k newfiles  ;so we know its empty
	s dir=""
	s rc=1
	for  {
		s dir=$O(dirlist(dir))
		q:dir=""
		s cdir=$ZU(12,dir)  ;it should end in a seperator now
		s jrnf=$ZSEARCH(cdir_"MIRROR-"_mirname_"-*.*")
		while (jrnf '= "") {
			if ($zversion(1)=1) s jrnf=$p(jrnf,";")
			s sname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf)
			if (sname?8N1"."3.10N) {
				s jrninfo=$zu(78,22,jrnf,99)
				if +jrninfo<1 {
					d $zu(9,"","CheckForExtraJournalFiles failed to read header of journal file "_jrnf,1 /* broadcast and log message*/,2  /* Severe error */)
					s rc=0  ;exit loop, return failure
					quit
				}
				s jrncnt=+$P(jrninfo,",",13+1)
				s jrnmguid=$P(jrninfo,",",15+1)
				if jrnmguid'=mirguid {
					d $zu(9,"","CheckForExtraJournalFiles: GUID ("_jrnmguid_") for file "_jrnf_" doesn't match mirror guid "_mirguid,1 /* broadcast and log message*/,2  /* Severe error */)
					s rc=0  ;exit loop, return failure
					quit
				}
				if jrncnt>lastjrnfilecnt {
					s newfiles(jrncnt)=jrnf
				}
			}
			s jrnf=$ZSEARCH("")
		}
		q:'rc
	}
	if 'rc {
		quit 0  ;error
	}
	if '$D(newfiles) {
	   ; No new files found, we can continue
	   quit -1  ;-1 = success, no new files found
	}
	; Verify that there are no missing files in the newfiles list
	s prevfcnt=lastjrnfilecnt
	s prevfile=lastjrnfile
	s jrncnt=""
	s filecnt=0
	s rc=1
	for  {
		s jrncnt=$O(newfiles(jrncnt),1,jrnf)
		q:jrncnt=""
		if +jrncnt'=(prevfcnt+1) {
			d $zu(9,"","CheckForExtraJournalFiles found missing new journal file. Last file "_prevfile_" is #"_prevfcnt_" but next file is #"_jrncnt_" ("_jrnf_").",1 /* broadcast and log message*/,2  /* Severe error */)
			s rc=0
			quit   ;exit loop and return failure
		}
		s prevfcnt=jrncnt
		s prevfile=jrnf
		s filecnt=filecnt+1
	}
	if 'rc {
		quit 0
	}
	; Add the contents of newfiles to the end of the
	; existing log.
	s logf=$ZU(12)_"mirrorjrn-"_mirname_".log"
	d $zu(9,"","Found "_filecnt_" additional journal files, adding to "_logf,0,0  /* Informational message */)
	s rc=$$AddNewFilesToJournalLog^MIRRORCOMM(mirname,.newfiles)
	if 'rc {
		quit 0
	}
	quit 1  ; 1 = success, new files found and added to log
err ;
	s $zt=""
	d $zu(9,"","CheckForExtraJournalFiles caught unexpected error: "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
	quit 0
}
GetStartingDejrnPos(mirname) {
	/* Returns mirjrnfilecnt^jrnpos of the place we can start dejournal
	   for DejournalProcessFile to apply journal data during mirror starting.
	   If the dejournal position in jrnshare structure existed then we use
	   it otherwise we used the ^MIRROR(mirname,"dejrnchkpnt") position.
	   if dejournal is blocked this retruns zero. */
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if miridx<=0 Quit $G(^MIRROR(mirname,"dejrnchkpnt"))
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	if shrid<0 Quit $G(^MIRROR(mirname,"dejrnchkpnt"))
	s info=$zu(78,53,shrid,64)
	s jrnoff = $p(info,",",2) s jrnfilecnt = +$p(info,",",3)
	if +info=0 || 'jrnfilecnt Quit $G(^MIRROR(mirname,"dejrnchkpnt"))
	quit jrnfilecnt_"^"_jrnoff
}
StartDejournalProcessor(mirname,filecnt,dejrnchkcnt,dejrnchkoff) {
	/* Starting the DejournalProcessor daemon.
	   The ^MIRROR(mirname,"DejournalStarted") is the state for the daemon starting status.
	       -1 : We has not started the DejournalProcessor daemon yet.
	       0  : We tried to started the daemon but there is no mirrored DB to be restored so we don't need to start it.
	       1  : The DejournalProcessor daemon is started. We are in the middle of retrieving file from primary or the other failover.
	   The ^MIRROR(mirname,"DejournalProcessor") indicates whether the DejournalProcessor is running or not.
	       0  : The DejournalProcessor is not running.
	       Non-Zero : The PID of the DejournalProcessor daemon is running.
	   The ^MIRROR(mirname,"DejournalFile") is the file count of the last journal file has been put in the array.
	   The ^MIRROR(mirname,"DejournalFile",jrnfcnt) is the array of all journal files retrieved and
           waiting for DejournalProcessor to process, after it processed it it will be removed by DejournalProcessor.
       The above nodes are protected by ^MIRROR(mirname,"DejournalProcessor") lock.
	*/
	Try {
		Lock +^MIRROR(mirname,"DejournalProcessor")
		s ^MIRROR(mirname,"DejournalStarted")=1
		if $d(^MIRROR(mirname,"DejournalFile"))>=10||(+$G(^MIRROR(mirname,"DejournalProcessor"))'=0) {
			d $zu(9,"","StartDejournalProcessor: DejournalProcessor is running when it should not. Stopping the daemon!",1 /* broadcast and log message*/,1  /* Warning */)
			Lock -^MIRROR(mirname,"DejournalProcessor")
			Do StopDejournalProcessor(mirname,0)
			Lock +^MIRROR(mirname,"DejournalProcessor")
			s ^MIRROR(mirname,"DejournalStarted")=1
		}
		k ^MIRROR(mirname,"DejournalFile")
		s ok=1
		s offset=dejrnchkoff
		for i=dejrnchkcnt:1:filecnt {
			s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
			if (+rc < 1) {
				k ^MIRROR(mirname,"DejournalFile")
				d $zu(9,"","("_mirname_") StartDejournalProcessor failed to lookup name for file #"_i_" - Skipped starting dejournal process",1 /* broadcast and log message*/,1  /* Warning */)
				s ^MIRROR(mirname,"DejournalStarted")=-1
				Lock -^MIRROR(mirname,"DejournalProcessor")
				s ok=0
				quit
			}
			s xjrnfile=$P(rc,",",2)
			s ^MIRROR(mirname,"DejournalFile",i)=offset_","_xjrnfile
			s offset=0  ;after 1st file, start the rest at the beginning
		}
		if ok {
			s ^MIRROR(mirname,"DejournalFile")=filecnt
			job DejournalProcessor^MIRRORMGR(mirname)::3
			If '$T {
				k ^MIRROR(mirname,"DejournalFile")
				s ^MIRROR(mirname,"DejournalStarted")=-1
				Lock -^MIRROR(mirname,"DejournalProcessor")
				d $zu(9,"","("_mirname_") StartDejournalProcessor failed to start dejournal process",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				Lock -^MIRROR(mirname,"DejournalProcessor")
				for i=1:1:30 s running=$$IsDejournalProcessorRunning(mirname) q:running||($G(^MIRROR(mirname,"Status","MGR"))="Exit")  h 1
				if 'running {
					Lock +^MIRROR(mirname,"DejournalProcessor")
					s ^MIRROR(mirname,"DejournalStarted")=-1
					kill ^MIRROR(mirname,"DejournalFile")
					Lock -^MIRROR(mirname,"DejournalProcessor")
					d $zu(9,"","("_mirname_") StartDejournalProcessor dejournal job failed to start",1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
		}
	} catch errv {
		k ^MIRROR(mirname,"DejournalFile")
		s ^MIRROR(mirname,"DejournalStarted")=-1
		L -^MIRROR(mirname,"DejournalProcessor")
		s errtext=errv.Name_" at "_errv.Location
		d $zu(9,"","StartDejournalProcessor error "_errtext,1 /* broadcast and log message*/,1  /* Warning */)
	}
	quit ^MIRROR(mirname,"DejournalStarted")	   
}
StopDejournalProcessor(mirname,checkmore) {
	/* Stop DejournalProcessor daemon, the 'checkmore' is set when the caller wants
	   to see if there are files left for daemon to process, if it is then return 0
	   to indicate the daemon is not down yet, the caller can continue to find more
	   file to dejournal. But if there is no more file to be processed then we wait
	   for the daemon to finish its curent file.
	   For mirror master daemon shuting down this call must follow DejournalFree() so
	   the dejournal daemon can quit.
	   Return 0 - daemon is not stopped when checkmore is set.
	          1 - daemon is down. */
	if $G(^MIRROR(mirname,"DejournalStarted"),-1)<0 Quit 1
	Lock +^MIRROR(mirname,"DejournalProcessor")
	if checkmore,$d(^MIRROR(mirname,"DejournalFile"))>=10,$G(^MIRROR(mirname,"DejournalProcessor")) {
		Lock -^MIRROR(mirname,"DejournalProcessor")
		Quit 0
	}
	Kill ^MIRROR(mirname,"DejournalFile")
	Set ^MIRROR(mirname,"DejournalStarted")=-1
	Lock -^MIRROR(mirname,"DejournalProcessor")
	if 'checkmore {
		q:($G(^MIRROR(mirname,"Status","MGR"))="Exit") 1
		s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
		if miridx>0 {
			s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
			if shrid>=0 {
				do $ZU(78,53,shrid,16,1) ;stop reader job
				do $zu(78,53,shrid,0,1)
			}
		}
	}
	While $$IsDejournalProcessorRunning(mirname) {
		q:($G(^MIRROR(mirname,"Status","MGR"))="Exit")
		h 0.5
	}
	if 'checkmore,miridx>0,shrid>=0 {
		do $ZU(78,53,shrid,16,0) ;clear jshrdstop job
		do $zu(78,53,shrid,0,0)
	}
	Quit 1
}
IsDejournalProcessorRunning(mirname) {
	/* Check if DejournalProcessor is still running.
	   Return non-zero if it is running. */
	Lock +^MIRROR(mirname,"DejournalProcessor")
	s pid=+$G(^MIRROR(mirname,"DejournalProcessor"))
	Lock -^MIRROR(mirname,"DejournalProcessor")
	quit pid
}
AddFileToDejournalProcessor(mirname,filecnt,jrnfile) {
	/* This is called to add a journal file to be dejournaled by DejournalProcessor daemon.
	   It is called when ^MIRROR(mirname,"DejournalStarted")is 1. It returns the current
	   value of ^MIRROR(mirname,"DejournalStarted") in case we found the DejournalProcessor
	   daemon dies due to error occurred in DejournalProcessor daemon. */
	Lock +^MIRROR(mirname,"DejournalProcessor")
	if '+$G(^MIRROR(mirname,"DejournalProcessor")) {
		s ^MIRROR(mirname,"DejournalStarted")=-1
		k ^MIRROR(mirname,"DejournalFile")
		Lock -^MIRROR(mirname,"DejournalProcessor")
		Quit -1
	}
	if filecnt'=($G(^MIRROR(mirname,"DejournalFile"))+1),filecnt'=$G(^MIRROR(mirname,"DejournalFile")) {
		Lock -^MIRROR(mirname,"DejournalProcessor")
		d $zu(9,"","AddFileToDejournalProcessor: the file ("_filecnt_") to be added not following previous file ("_$G(^MIRROR(mirname,"DejournalFile"))_"), stopping DejournalProcessor.",1 /* broadcast and log message*/,1  /* Warning */)
		Do StopDejournalProcessor(mirname,0)
		Quit -1
	}
	s ^MIRROR(mirname,"DejournalFile")=filecnt
	s ^MIRROR(mirname,"DejournalFile",filecnt)="0,"_jrnfile
	Lock -^MIRROR(mirname,"DejournalProcessor")
	Quit 1
}
CheckStartDejournalProcessor(mirname,lastfilecnt=0,lastfilevalidend=0) {
	/* Check if we can start the DejournalProcessor daemon.
       If starting dejournal position is earlier than the last journal file then we can start it. */
    if '+$G(^SYS("MIRRORSET",mirname,"Member")) Quit $G(^MIRROR(mirname,"DejournalStarted"),-1)
startdejrn ;
	s dejrnstarted=$G(^MIRROR(mirname,"DejournalStarted"),-1)
	if dejrnstarted<0 {
		s x=$$GetStartingDejrnPos(mirname)
		if '+x {
			s ^MIRROR(mirname,"DejournalStarted")=0
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: dejrnchkcnt is 0, dejournaling not required")
		} elseif +$G(^MIRROR(mirname,"DejournalBlock"))=1 {
			s ^MIRROR(mirname,"DejournalStarted")=0
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: Dejournal is stopped, DejournalProcessor won't be started")
		} else {
			if lastfilecnt {
				s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(lastfilecnt,mirname)
				s fcnt=$s(+rc>0:lastfilecnt,1:0)
			} else {
				s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
				s fcnt=+rc
		    }
			if fcnt>0 {
				s:lastfilevalidend=0&&($$getMirJrnEnd($p(rc,",",2))'>0) fcnt=fcnt-1
				if fcnt>=(+x) {
					s rc=$$StartDejournalProcessor(mirname,fcnt,+x,$p(x,"^",2))
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: StartDejournalProcessor returned "_rc)
				}
			}
		}
	} elseif dejrnstarted>0 {
		if lastfilecnt {
			s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(lastfilecnt,mirname)
			s fcnt=$s(+rc>0:lastfilecnt,1:0)
		} else {
			s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
			s fcnt=+rc
	    }
		s:lastfilevalidend=0&&($$getMirJrnEnd($p(rc,",",2))'>0) fcnt=fcnt-1
		if fcnt>$G(^MIRROR(mirname,"DejournalFile")) {
			Lock +^MIRROR(mirname,"DejournalProcessor")
			if '+$G(^MIRROR(mirname,"DejournalProcessor")) {
				s ^MIRROR(mirname,"DejournalStarted")=-1
				k ^MIRROR(mirname,"DejournalFile")
				Lock -^MIRROR(mirname,"DejournalProcessor")
				d $zu(9,"","CheckStartDejournalProcessor: DejournalProcessor daemon not running, restart it.",1 /* broadcast and log message*/,1  /* Warning */)
				goto startdejrn
			}
			s failed=0
			for i=$G(^MIRROR(mirname,"DejournalFile"))+1:1:fcnt {
				if i=fcnt {
					s jrnfile=$p(rc,",",2)
				} else {
					s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
					if +jrnfile<=0 {
						d $zu(9,"","CheckStartDejournalProcessor: Failed to find file count "_i_" in log file.",1 /* broadcast and log message*/,1  /* Warning */)
						s failed=1
						quit
					}
					s jrnfile=$p(jrnfile,"^",2)
				}
				s ^MIRROR(mirname,"DejournalFile",i)="0,"_jrnfile
			}
			s ^MIRROR(mirname,"DejournalFile")=fcnt
			Lock -^MIRROR(mirname,"DejournalProcessor")
			i failed {
				Do StopDejournalProcessor(mirname,0)
				goto startdejrn
			}
		}
    }
    quit $G(^MIRROR(mirname,"DejournalStarted"),-1) 
}
DejournalProcessor(mirname) PUBLic {
	L +^MIRROR(mirname,"DejournalProcessor")
	if $G(^MIRROR(mirname,"DejournalProcessor"),0) {
		L -^MIRROR(mirname,"DejournalProcessor")
		d $zu(9,"","Dejournal Processor for "_mirname_" already running by PID "_$G(^MIRROR(mirname,"DejournalProcessor")),1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	if $G(^MIRROR(mirname,"DejournalStarted"),-1)'>0 {
		L -^MIRROR(mirname,"DejournalProcessor")
		d $zu(9,"","Dejournal Processor for "_mirname_" is not started by master daemon.",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s ^MIRROR(mirname,"DejournalProcessor")=+$j
	L -^MIRROR(mirname,"DejournalProcessor")
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor started")
	s PurgeFile=$System.Mirror.IsAsyncMember()&&$System.Mirror.AsyncMemberType()&&'$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1
	s skip=0
	if miridx>0 {
	   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		  d $zu(9,"","DejournalProcessor - Failed to locate sharid for primary id #"_miridx,1 /* broadcast and log message*/,1  /* Warning */)
		  L +^MIRROR(mirname,"DejournalProcessor")
		  k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
		  L -^MIRROR(mirname,"DejournalProcessor")
		  Quit
	   } else {
		   s prefstrategy=$G(^MIRROR(":config:","PrefetchCatchupStrategy"),-10000)
		   do $ZU(78,90,shrid,prefstrategy)
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor set prefetch chunk size for sharid #"_shrid_" to "_(-prefstrategy))
	   }
	}
	s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
	if ('rc) {
		d $zu(9,"","DejournalProcessor: ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		L +^MIRROR(mirname,"DejournalProcessor")
		k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
		L -^MIRROR(mirname,"DejournalProcessor")
		Quit
	}
	if filter'="" {
		s FilterObj=$classmethod(filter,"%New")
		if '$isobject(FilterObj) {
			d $zu(9,"","DejournalProcessor: ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
			L +^MIRROR(mirname,"DejournalProcessor")
			k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
			L -^MIRROR(mirname,"DejournalProcessor")
			Quit
		}
		s FilterObj.InCatchupDB = 0
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor: ("_mirname_") is running filter class "_filter)
	}
	s PrevDejrn=0
	try {
		for {
			s jrnfcnt=$o(^MIRROR(mirname,"DejournalFile",""),1,data)
			if jrnfcnt="" {
				L +^MIRROR(mirname,"DejournalProcessor")
				if $G(^MIRROR(mirname,"DejournalStarted"),-1)>0 {
					if $d(^MIRROR(mirname,"DejournalFile"))<10 h 1
					L -^MIRROR(mirname,"DejournalProcessor")
					continue
				}
				k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor") 
				L -^MIRROR(mirname,"DejournalProcessor")
				quit
			}
			if skip k ^MIRROR(mirname,"DejournalFile",jrnfcnt) continue
			if +PrevDejrn=1 {
				s prevjrnfile=$p(PrevDejrn,",",2),prevfcnt=$p(PrevDejrn,",",3),prevoff=$p(PrevDejrn,",",4)
				s prevalidend=$$getMirJrnEnd(prevjrnfile)
				if jrnfcnt=(prevfcnt+1)||(prevfcnt=jrnfcnt) {
					if prevalidend<=0 {
						d $zu(9,"","DejournalProcessor: Previous file "_prevjrnfile_" without valid end. Count="_prevfcnt_" Offset="_prevoff_". Abort!!!",1 /* broadcast and log message*/,1  /* Warning */)
						s skip=1 k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
						continue
					}
					s jrnfcnt=prevfcnt
					s data=prevoff_","_prevjrnfile
				} else {
					d $zu(9,"","DejournalProcessor: Next file ("_jrnfcnt_") does not follow previous file ("_prevfcnt_"). Abort!!!",1 /* broadcast and log message*/,1  /* Warning */)
					s skip=1 k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
					continue
				}
			} elseif +PrevDejrn=2 {
				s prevfcnt=$p(PrevDejrn,",",3)
				if jrnfcnt=prevfcnt {
					k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
					continue
				}
				if jrnfcnt'=(prevfcnt+1) {
					d $zu(9,"","DejournalProcessor: Next file ("_jrnfcnt_") does not follow previous file ("_prevfcnt_"). Abort!!!",1 /* broadcast and log message*/,1  /* Warning */)
					s skip=1 k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
					continue
				}
			}
			s jrnfile=$p(data,",",2),startoff=+data
			d $zu(9,"","DejournalProcessor: Applying journal data for mirror """_mirname_""" starting at "_startoff_" in file #"_jrnfcnt_ "("_jrnfile_")",0,0  /* Informational message */)
			if filter'="" {
				s rc=FilterObj.DejournalProcessFile(miridx,startoff,jrnfile,jrnfcnt)
			} else {
				s rc=$SYSTEM.Mirror.DejournalProcessFile(miridx,startoff,jrnfile,jrnfcnt)
			}
			if +rc<=0 {
				d $zu(9,"","("_mirname_") DejournalProcessor error ("_rc_") dejournaling from file #"_jrnfcnt_" ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
				s skip=1
			} else {
				Try {
					s info=$zu(78,53,shrid,64)
					s NoSync=+info
				} catch {
					s NoSync=0
				}
				s validend=$$getMirJrnEnd(jrnfile)
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor: DejournalProcessFile returned "_rc_" NoSync="_$G(info,"")_" validend="_validend)
				if validend=0 {
					s PrevDejrn="1,"_jrnfile_","_$p(rc,",",2)_","_$s(NoSync:$p(info,",",2),1:$p(rc,",",3))
				} elseif validend>0 {
					s PrevDejrn="2,"_jrnfile_","_$p(rc,",",2,3)
					if validend'=$p(rc,",",3) {
						s $p(PrevDejrn,",",1)=1
						s $p(PrevDejrn,",",4)=$s(NoSync:$p(info,",",2),1:$p(rc,",",3))
					} elseif $G(PurgeFile) {
						s ^MIRROR(mirname,"PendingPurgeList",jrnfcnt)=""
					}
				} elseif validend=-1 {
					d $zu(9,"","DejournalProcessor: Failed to open journal file #"_jrnfcnt_ "("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
					s skip=1
				}
			}
			k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
		}
	} catch errv {
		L +^MIRROR(mirname,"DejournalProcessor")
		k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
		L -^MIRROR(mirname,"DejournalProcessor")
		s errtext=errv.Name_" at "_errv.Location
		d $zu(9,"","DejournalProcessor error "_errtext,1 /* broadcast and log message*/,1  /* Warning */)
	}
}
SetLastFileValidFlag(mirname) PUBLIC {
	/* Set $SYSTEM.Mirror.LastFileValidFlag() = 0/1
	   Called after we retrieve the missing journal files (if any) to
	   check the valid/not valid status of the last file we have. The
	   valid/not valid flag controls whether we can become the primary or
	   not during startup. If this is clear we can become the backup but
	   not a primary.
    */
	do $SYSTEM.Mirror.LastFileValidFlag(0)  ; start with not valid
	s $zt="err"
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   ; This is an error reading the log file (rc<0)
	   d $zu(9,"","("_mirname_") SetLastFileValidFlag failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if rc=0 {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if 'systemcnt {
			; if there aren't any files and we're the only mirror
			; member then flag the last file as valid as otherwise
			; we won't become the primary (we'll become a backup 
			; since the last file isn't valid...)
		    ; [JAO] Review this with Simon
		}
		do $SYSTEM.Mirror.LastFileValidFlag(1)  ; its valid
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","LastFileValidFlagSet: Failed to read last file from journal file log")
		quit 1  ;its ok if we don't have any files
	}
	s jrnfilecnt=+rc
	s jrnfile=$P(rc,",",2)
 	s rc=$$getMirJrnEnd(jrnfile)
	if rc<0 {
	   ; error finding, opening or reading file
	   d $zu(9,"","("_mirname_") SetLastFileValidFlag failed checking valid end of file #"_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if rc {
		s expectedlastvalidfile=$G(^MIRROR(mirname,"lastvalidjrnfile"))
		if jrnfilecnt'=+expectedlastvalidfile {
			d $zu(9,"","("_mirname_") SetLastFileValidFlag found file #"_jrnfilecnt_" as the last file when """_expectedlastvalidfile_""" was expected.",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","LastFileValidFlagSet: "_jrnfile_" has a valid end of "_rc)
		do $SYSTEM.Mirror.LastFileValidFlag(1)  ; its valid
	}
	quit 1  ;success, even though last file isn't valid
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","SetLastFileValidFlag unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0	
}
RetryApplyJournalFiles(mirname) PUBLIC {
	/* this is the entry point added to the retry list when 
	   ApplyJournalFiles fails. This entry point will retry
	   the ApplyJournalFiles but if that fails it will also
	   re-evaluate what journal file we require in case that has
	   changed as well (eg. someone refreshed the databases from
	   a backup). 
	*/
	s rc=$$ApplyJournalFiles(mirname)
	if rc=1 {
		quit 1  ;succeeded!
	} elseif rc'=0 {
		s rc=$$RetryValidateMirrorJournalFiles(mirname)
		if rc=1 quit 1
		if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		quit 0
	}
	s rc=$$UpdateMirrorJournalCheckPoint(mirname)
    if 'rc {
	   if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
	   quit 0   ;failed, keep retrying
	}
	s rc=$$ApplyJournalFiles(mirname)
	if rc=1 {
		quit 1  ;succeeded!
	} elseif rc'=0 {
		s rc=$$RetryValidateMirrorJournalFiles(mirname)
		if rc=1 quit 1
		if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		quit 0
	}
	if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
	quit 0  ;still failed, oh well.
}
ApplyJournalFiles(mirname) PUBLIC {
	/* Apply any journaling data we have, which has not yet been applied,
	   to the mirrored databases.
	   Returns -1 = failed, retry starting with ValidateJournalFiles (JO2359)
	            0 = failed, retry ApplyJournalFiles
	            1 = ok - all journal data we have has been applied.
	                ^MIRROR(mirname,"dejrnchkpnt")=<mir jrn cnt>^<jrnpos>
	                ^MIRROR(mirname,"transroll")=<mir jrn cnt>^<jrnpos>
	    ^MIRROR(mirname,"lastvalidjrnfile")=<mir jrn cnt>^<journal file name> 
	    			is the file where we can stop. We know this is a valid
	    			journal file because the code that sets this node is careful
	    			not to set it if the file doesn't have a valid end.
	*/
	s $zt="err"
	s startfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
	if '+startfilecnt quit 1
	s startoff=+$P(startfilecnt,"^",2)
	s startfilecnt=+startfilecnt
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","ApplyJournalFiles failed failed to read mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s reportingNode=cls.isAsyncMember()
	s cls=""
	if reportingNode {
		if +$G(^MIRROR(mirname,"DejournalBlock"))=1 {
			 if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles skipped - DejournalBlock flag is set on reporting member")
			 quit 1
		}
		d $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
	}
	;
	if $G(^MIRROR(mirname,"Status","MGR"))="Exit" Quit 0
	s PurgeFile=reportingNode&&$System.Mirror.AsyncMemberType()&&'$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if miridx>0 {
	   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		   if $$InitDejournal(miridx,mirname) {
		      d $zu(9,"","ApplyJournalFiles re-initialized dejournal memory",0,0  /* Informational message */)
		   } else {
			  d $zu(9,"","ApplyJournalFiles failed to initialize dejournal memory - halting",1 /* broadcast and log message*/,3  /* Fatal */)
			  halt
		   }
		   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
		   ; returns shrid which is 0->n or -1 if there's a problem 
		   if shrid<0 {
			   d $zu(9,"","ApplyJournalFiles - Failed to locate sharid for primary id #"_miridx_ " - halting",1 /* broadcast and log message*/,3  /* Fatal */)
			   halt
		   }
       }
	   s prefstrategy=$G(^MIRROR(":config:","PrefetchCatchupStrategy"),-10000)
	   do $ZU(78,90,shrid,prefstrategy)
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles set prefetch chunk size for sharid #"_shrid_" to "_(-prefstrategy))
	   Try {
		   s info=$zu(78,53,shrid,64)
		   if +info {
			   s newstartoff = $p(info,",",2) s newstartfilecnt = +$p(info,",",3)
			   if newstartfilecnt > startfilecnt || (newstartfilecnt=startfilecnt && (newstartoff>startoff)) {
				   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles: start position changed from "_startoff_"/"_startfilecnt_" to "_newstartoff_"/"_newstartfilecnt)
				   s startfilecnt = newstartfilecnt
				   s startoff = newstartoff
			   }
		   }
       } Catch {}
    } else {
	   d $zu(9,"","ApplyJournalFiles - Failed to locate miridx for mirror /"_mirname_ "/ - halting",1 /* broadcast and log message*/,3  /* Fatal */)
	   halt
	}
	s info=$G(^MIRROR(mirname,"lastvalidjrnfile"))  ;<mirjrncnt>^<filename>
	if info'="" {
	   s lastjrnfile=$P(info,"^",2)
	   s lastjrnfilecnt=+info
	} else {
		; If we don't have a lastvalidjrnfile it could be because
		; our start file is the current journal file on the active
		; primary. This is true if the dejrncnkpnt is the last file
		; we have.
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc<=0 {
		   d $zu(9,"","("_mirname_") ApplyJournalFiles failed to look up last valid file in journal log",1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
		}
		if +rc'=startfilecnt {
		   d $zu(9,"","("_mirname_") ApplyJournalFiles failed because last valid journal file not recorded",1 /* broadcast and log message*/,1  /* Warning */)
		   quit -1  ;restart with validate journal files (JO2359)
		}
		s lastjrnfile=$P(rc,",",2)
		s lastjrnfilecnt=+rc
		; Since we didn't get this file from "lastvalidjrnfile" we need to double
		; check that its ok to restore it. This must be the current file on the
		; active primary or its an error.
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if systemcnt>0 {
			s status=""
			for id=1:1:systemcnt {
		   	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	       	   if info'="" {
		          s name=$lg(info,1)
	              s mtype=+$lg(info,8)
	              if mtype=1 {
		              s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,1) ;get min/max jrninfo
		              s status=$LG(rc)
		              quit
	              }
	              s rc=$$GetStatus^MIRRORCTL(mirname,id)
	              s status=$LG(rc)  
		          if ('reportingNode) ! (status="PRIMARY") {
			          ; for failover nodes we want to get the info about the
			          ; other nodes, for reporting nodes we want to contact
			          ; the current primary. If this is an async member talking
			          ; to another async (relay), then systemcnt is 1 and there
			          ; is only 1 other node.
			          quit
		          }
		       }
	        }
	        if reportingNode {
		       if mtype=0,status'="PRIMARY" {
				   d $zu(9,"","("_mirname_") ApplyJournalFiles failed to locate primary to validate "_lastjrnfile_" is the current journal file",1 /* broadcast and log message*/,1  /* Warning */)
				   quit 0
		       }
		       if mtype'=0 {
			       if status'="OK" {
					   d $zu(9,"","("_mirname_") ApplyJournalFiles failed to locate relay server to validate "_lastjrnfile_" is the current journal file, status="_status,1 /* broadcast and log message*/,1  /* Warning */)
					   quit 0
			       }
			       s rc=$LG(rc,2)
		       }
	        }
	        s jrnfilecnt=$LG(rc,2)  ;current journal file on the primary
	        if jrnfilecnt'=lastjrnfilecnt {
			   d $zu(9,"","("_mirname_") ApplyJournalFiles cannot restore our last journal file #"_lastjrnfilecnt_" ("_lastjrnfile_") because it is not the primary's current journal file (#"_jrnfilecnt_")",1 /* broadcast and log message*/,1  /* Warning */)
			   quit -1  ;retry with validate journal files (JO2359)
	        }
		}
	}
	;
	; if the starting file count is the same as the last valid
	; filecnt then get the end of the last valid journal file and see
	; whether our starting offset is at the end or not. If it is, then
	; we're up-to-date and there's nothing to do.
	;
	if startfilecnt=lastjrnfilecnt {
	   ; Open the journal file to find its end rather than using JrnHdrMIREND 
	   ; because we want the actual end we have on this system. If JrnHdrMIREND is
	   ; set, and we have that in our file, that's what $$$JRNPREV() will return.
	   ; Otherwise JRNPREV() returns the last address we have. Compare the end
	   ; of this file to the startpoint to see if it needs to be restored.
       s fd=$zu(78,5,lastjrnfile,0)
       if fd<0 {
          d $zu(9,"","("_mirname_") ApplyJournalFiles failed to open journal file "_lastjrnfile_" to locate its end",1 /* broadcast and log message*/,1  /* Warning */)
          s rc=$$UpdateMirrorJournalCheckPoint(mirname)
          if '+rc {
	          d $zu(9,"","ApplyJournalFiles retry: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
	          quit 0
          }
          s dejrnfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
          s startoff=+$P(dejrnfilecnt,"^",2)
          s dejrnfilecnt=+dejrnfilecnt
          if (startfilecnt'<dejrnfilecnt) {
	          quit 0
          }
          d $zu(9,"","ApplyJournalFiles retried with starting journal #"_dejrnfilecnt_" from old #"_startfilecnt,0,0  /* Informational message */)
          s startfilecnt=dejrnfilecnt
          goto skip
       }
	   do $zu(78,6,fd)
	   s jrnend=$zu(78,18,0)
	   s jrnendx=jrnend
	   if $$IsRelayClient^MIRRORCOMM(mirname) s jrnendx=$zu(78,94,jrnend)
	   do $zu(78,7,fd)
	   ;
	   if startoff<jrnendx {
	      d $zu(9,"","Applying journal data for mirror """_mirname_""" starting at "_startoff_" in file #"_lastjrnfilecnt_" ("_lastjrnfile_").",0,0  /* Informational message */)
	   } else {
	      if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Databases up to date. No journal restore required")
	   }
	   s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
	   if ('rc) {
		   d $zu(9,"","ApplyJournalFiles ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		   Quit 0
	   }
	   if filter'="" {
		   s FilterObj=$classmethod(filter,"%New")
		   if '$isobject(FilterObj) {
			   d $zu(9,"","ApplyJournalFiles ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
			   Quit 0
		   }
		   s FilterObj.InCatchupDB = 0
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles ("_mirname_") is running filter class "_filter)
		   s rc=FilterObj.DejournalProcessFile(miridx,startoff,lastjrnfile,lastjrnfilecnt)
	   } else {
		   s rc=$SYSTEM.Mirror.DejournalProcessFile(miridx,startoff,lastjrnfile,lastjrnfilecnt)
	   }
       if +rc<=0 {
          d $zu(9,"","("_mirname_") ApplyJournalFiles error ("_rc_") dejournaling from file: "_lastjrnfile,1 /* broadcast and log message*/,1  /* Warning */)
	      quit 0
	   } elseif PurgeFile {
		   if $$getMirJrnEnd(lastjrnfile)>0 {
			   s ^MIRROR(mirname,"PendingPurgeList",lastjrnfilecnt)=""
		   }
	   }
	   goto updatechkpnt
	}
skip ;
	if startfilecnt>lastjrnfilecnt {
		; the datatabases are up to date as of a journal file we don't have.
		; Its unclear why we're in this state but probably the databases were
		; restored from backup/copied from another system and they were 'ahead'
		; of the journal files on this node. Regardless of the reason, 
		; get the missing journal files.
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ApplyJournalFiles retrieving journal files "_(lastjrnfilecnt+1)_" through "_startfilecnt)
		for filecnt=lastjrnfilecnt+1:1:startfilecnt {
		  s startretrievepos=0
		  if startfilecnt=filecnt {
			  s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
			  if +rc {
				  s rc=$P(rc,",",2)
				  s rc=$zu(78,5,rc,0) ;lastjrnfile is the havejrncnt/dejrncnhkcnt/maxjrncnt file
				  if rc'<0 {
					  do $zu(78,6,rc)
					  s startretrievepos=$zu(78,18,0)
					  if $$IsRelayClient^MIRRORCOMM(mirname) s startretrievepos=$zu(78,94,startretrievepos)
					  do $zu(78,7,rc)
				  }
			  }
		  }
		  s rc=$$RetrieveJournalFile(mirname,filecnt,startretrievepos,1,1) 
		  if 'rc {
		     d $zu(9,"","("_mirname_") ApplyJournalFiles failed to retrieve 'missing' journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     quit  ;stop getting journal files
		  }
		}
		if 'rc quit 0  ;failed
	    s lastjrnfilecnt=startfilecnt
	}
	; There's more than one journal file which needs to be restored. For
	; the 1st one we start at startoff. 	
	s rc=1
	s retry=0
	for filecnt=startfilecnt:1:lastjrnfilecnt {
	   s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	   if +jrnfile {
		  s jrnfile=$P(jrnfile,",",2)
	   } else {
		  ; We don't have the journal file required to update the
		  ; mirrored databases. Generally this should only happen when a
		  ; mirror is 1st built. Try to retrieve this file from any of the
		  ; mirror members.
		  s startretrievepos=0
		  if startoff {
			  s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
			  if +rc {
				  s rc=$P(rc,",",2)
				  s rc=$zu(78,5,rc,0) ;lastjrnfile is the havejrncnt/dejrncnhkcnt/maxjrncnt file
				  if rc'<0 {
					  do $zu(78,6,rc)
					  s startretrievepos=$zu(78,18,0)
					  if $$IsRelayClient^MIRRORCOMM(mirname) s startretrievepos=$zu(78,94,startretrievepos)
					  do $zu(78,7,rc)
				  }
			  }
		  }
		  if '$$RetrieveJournalFile(mirname,filecnt,startretrievepos,1,1) {
		     d $zu(9,"","("_mirname_") Failed to retrieve journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     s jrnfile=""
		     quit
		  }
	  	  s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	   	  if +jrnfile {
		     s jrnfile=$P(jrnfile,",",2)
		  } else {
		     d $zu(9,"","("_mirname_") Failed to lookup journal file #"_filecnt_" after retrieving",1 /* broadcast and log message*/,1  /* Warning */)
		     s jrnfile=""
		     quit
		  }
	   }
	   if jrnfile="" s rc=0 quit ; some error occured, exit the for loop and return failure
	   s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
	   if ('rc) {
		   d $zu(9,"","ApplyJournalFiles ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		   s rc = 0 Quit
	   }
	   d $zu(9,"","Applying journal data for mirror """_mirname_""" starting at "_startoff_" in file #"_filecnt_ "("_jrnfile_")",0,0  /* Informational message */)
	   if filter'="" {
		   s FilterObj=$classmethod(filter,"%New")
		   if '$isobject(FilterObj) {
			   d $zu(9,"","ApplyJournalFiles ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
			   s rc = 0 quit
		   }
		   s FilterObj.InCatchupDB = 0
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles ("_mirname_") is running filter class "_filter)
		   s rc=FilterObj.DejournalProcessFile(miridx,startoff,jrnfile,filecnt)
	   } else {
		   s rc=$SYSTEM.Mirror.DejournalProcessFile(miridx,startoff,jrnfile,filecnt)
	   }
       if +rc<=0 {
          d $zu(9,"","("_mirname_") ApplyJournalFiles error ("_rc_") dejournaling from file #"_filecnt_" ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
          s rcx=$$UpdateMirrorJournalCheckPoint(mirname)
          if '+rcx {
	          d $zu(9,"","ApplyJournalFiles: UpdateMirrorJournalCheckPoint failed: "_$p(rcx,",",2),1 /* broadcast and log message*/,1  /* Warning */)
          }
          s text=$P(rc,",",2)  ;0,<message text>
          if ('retry) && (filecnt=startfilecnt) {
			  if ($ZCVT(text,"L")["failed to open journal file") {
				  s dejrnfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
				  s startoff=+$P(dejrnfilecnt,"^",2)
				  s dejrnfilecnt=+dejrnfilecnt
				  if (startfilecnt'<dejrnfilecnt) {
					  s rc=0		; indicate failure
					  quit
				  }
				  d $zu(9,"","ApplyJournalFiles retried with starting journal #"_dejrnfilecnt_" from old #"_filecnt,0,0  /* Informational message */)
				  s filecnt=dejrnfilecnt-1
				  s retry=1
				  continue
			  }
          }
	      quit
	   } elseif PurgeFile {
		   if $$getMirJrnEnd(jrnfile)>0 {
			   s ^MIRROR(mirname,"PendingPurgeList",filecnt)=""
		   }
       }
       s startoff=0  ;start @ the beginning of the next file
	}
	if +rc>0 {
updatechkpnt ;
	   s dejrnfilecnt=+$P(rc,",",2)
	   s dejrnfilepos=+$P(rc,",",3)	
	   if '$$IsRelayClient^MIRRORCOMM(mirname),shrid>=0 {
		   s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(dejrnfilecnt,mirname)
		   if +jrnfile {
			   s jrnfile=$P(jrnfile,",",2)
			   try {
				   s rc=$SYSTEM.Mirror.DejournalProcessFileSync(jrnfile,shrid,dejrnfilepos)
			   } catch { s rc = "0,"_$ZE }
			   if 'rc d $zu(9,"","ApplyJournalFiles failed to syn dejournaling, error:"_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		   } else {
			   d $zu(9,"","("_mirname_") DejournalSync Failed to lookup journal file #"_dejrnfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
		   }
	   }
	   If '$SYSTEM.Mirror.ActiveBackupFlag() do ResolveDBRollbackState(mirname)
	   ; Now we need to update dejrnchkpnt and transroll
	   s rc=$$UpdateMirrorJournalCheckPoint(mirname)
	   if '+rc {
		   d $zu(9,"","ApplyJournalFiles: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	   }
	   s dbchkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))
	   s dbfilecnt=+dbchkpnt
	   s dbfilepos=+$P(dbchkpnt,"^",2)
	   if dejrnfilecnt,dbfilecnt>dejrnfilecnt {
		   s msg="Dejournal checkpoint for "_mirname_" from the databases ("_dbchkpnt_") indicates"
		   s msg=msg_" there are more journal files to restore beyond #"_dejrnfilecnt
		   s msg=msg_$C(10,13)_"Some journal file appear to be missing - ApplyJournalFiles failed."
		   d $zu(9,"",msg,1 /* broadcast and log message*/,2  /* Severe error */)
		   quit 0
	   } elseif dbfilecnt=dejrnfilecnt,dbfilepos>dejrnfilepos {
		   s msg="Dejournal checkpoint for "_mirname_" from the journal file ("_dejrnfilecnt_","_dejrnfilepos_")"
		   s msg=msg_" is less than the last checkpoint in the databases ("_dbchkpnt_")."_$c(13,10)
		   s msg=msg_"It appears that file #"_lastjrnfilecnt_" ("_lastjrnfile_") has been truncated"
		   s msg=msg_" - ApplyJournalFiles failed."
		   d $zu(9,"",msg,1 /* broadcast and log message*/,2  /* Severe error */)
		   quit 0
	   }
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ApplyJournalFiles succeeded, checkpoint = "_dejrnfilecnt_","_dejrnfilepos)
	   quit 1
	}
	d $zu(9,"","("_mirname_") ApplyJournalFiles failed",1 /* broadcast and log message*/,1  /* Warning */)	
	quit 0
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
UpdateMirrorJournalCheckPoint(mirname) PUBLIC {
	s rc=$$GetMirrorDejournalInformation(mirname)
	if '+rc quit "0,Reset of dejrnchkpnt failed"
	s chkpntfilecnt=+^MIRROR(mirname,"dejrnchkpnt")
	s rc=$$GetTransactionRollbackPoint(mirname,chkpntfilecnt)
	if '+rc quit "0,Reset of transroll failed"
	quit 1
}
ResolveDBRollbackState(mirname) {
	/* This is called from ApplyJournalFiles after restoring
	   the journal files to see whether we can clear the
	   rollback state in the databases so they can be activated. We
	   go through the set of databases which are marked as rollback
	   pending and if they are currently active on the primary then
	   we clear the rollback point stored in the database so that they
	   can become 'active' on the backup. If the other node is not up
	   or if the db's are not active, they remain rollback pending.
	*/
	s $zt="err"
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) quit   ;should never happen 
    for id=1:1:systemcnt {
	    s r=$G(^MIRROR(mirname,"Status","Member",id,"Role"))
	    if (r="PRIMARY") quit
	}
	if (r'="PRIMARY") {
		; assume its system #1
		s id=1
	}
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id),"")
	if info="" {
		d $zu(9,"","ResolveDBRollbackState missing information for member #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s name=$lg(info,1)
	s mtype=+$lg(info,8)
	if mtype'=0 {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Transaction rollback not modified for restored databases, "_name_" is a relay member")
	   quit
	}
	;
    s rc=$$GetStatus^MIRRORCTL(mirname,id)
    s status=$LG(rc)  
	if status'="PRIMARY" {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Transaction rollback remains pending for restored databases, "_name_" reports it is not the primary ("_status_")")
	   quit
	}
	; now get the list of databases
    s dirlist=$$GetDBList^MIRRORCTL(mirname,id,"",1)
    s rc=$LG(dirlist)
    if rc'="OK" {
	    d $zu(9,"","ResolveDBRollbackState failed to read current datbase list from primary. Databases remain inactive",1 /* broadcast and log message*/,1  /* Warning */)
	    quit
    }
    s len=$LL(dirlist)
    k primarydblist
	for i=2:1:len {
		s dir=$LG(dirlist,i)
		s sfn=+dir
 		s primarydblist($P(dir,"^",2))=sfn_"^"_$p(dir,"^",3)
    }
	k ourdblist
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.ourdblist,1)
	if '$LG(rc) {
		d $zu(9,"","ResolveDBRollbackState, GetMirrorDBList returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s index=$o(ourdblist(""),1,info)
	while index'="" {
	   s dbpath=$P(info,"^",1)
	   s dbmirname=$P(info,"^",8)
	   s dbname=$P(info,"^",2)
	   s dblastfilecntrestored=$P(info,"^",11)
	   ;
	   if (dblastfilecntrestored && (dbmirname=mirname)) {
	      s dbname=":mirror:"_dbmirname_":"_dbname
 	      s remsfn=$G(primarydblist(dbname))
	      if remsfn="" {
	         d $zu(9,"","Rollback point for "_dbpath_" not reset - db missing on the primary",1 /* broadcast and log message*/,1  /* Warning */)
	      } else {
		      if $p(remsfn,"^",2)="" {
			      s rc=$$GetDBStatus^MIRRORCTL(mirname,id,+remsfn)
			      if $LG(rc)'="OK" {
				      d $zu(9,"","Rollback point for "_dbpath_" not reset - failed to retrieve status",1 /* broadcast and log message*/,1  /* Warning */)
				      s state=$LB("Skip")
				  } else {
					  s state=$LG(rc,2)
				  }
		      } else {
			      s state= $LB($s($p(remsfn,"^",2):"Active",1:"Inactive"))
		      }
		      if $LG(state)="Active" {
					 s sfn=+$ZU(49,dbpath)
					 if (sfn = $ZU(40,0,41)) {
						 do $ZU(17,dbpath)  ;try to mount it
						 s sfn=+$ZU(49,dbpath)
					 }
					 if (sfn<0) || (sfn = $ZU(40,0,41)) {
					     d $zu(9,"","Failed to mount "_dbpath_" to clear rollback point ("_dblastfilecntrestored_")",1 /* broadcast and log message*/,1  /* Warning */)
					 } else {
						 s rc=$SYSTEM.Mirror.DejournalClearTRollInfo(sfn)
						 if 'rc {
							 d $zu(9,"","Failed to clear rollback point ("_dblastfilecntrestored_") for "_dbpath,1 /* broadcast and log message*/,1  /* Warning */)
						 }
					 }
			  } elseif $LG(state)'="Skip" {
		 		     d $zu(9,"","Rollback point for "_dbpath_" not reset - it is not active on the primary",1 /* broadcast and log message*/,1  /* Warning */)
			  }
	       }
	   }
	   s index=$o(ourdblist(index),1,info)
    }
	quit
err ;
	s $zt=""
	d $zu(9,"","ResolveDBRollbackState("""_mirname_""") unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit		
}
TransactionRollbackComplete(mirname) {
	/* Called on the primary after Mirror^ECPRecovery succeeds to
	   clear the miblastfilecntrestored flag on all of the 'up to date'
	   databases to indicate that transaction rollback is complete 
	*/
	if $SYSTEM.Mirror.GetInfo()'["PRIMARY" quit
	s dejrnchkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))
	if dejrnchkpnt="" quit  ;didn't do any journal restore
	s lastjrncnt=+dejrnchkpnt
	k dblist
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
	if '$LG(rc) {
		d $zu(9,"","TransactionRollbackComplete, GetMirrorDBList returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s path=$o(dblist(""),1,info)
	while path'="" {
	   s dbpath=$P(info,"^",1)
	   s dbmirname=$P(info,"^",8)
	   s dbjrncnt=$P(info,"^",3)
	   s dbname=$P(info,"^",2)
	   if (dbmirname=mirname) && (dbjrncnt=lastjrncnt) {
		  s sfn=+$ZU(49,path)
		  if (sfn<0) || (sfn = $ZU(40,0,41)) {
		     d $zu(9,"","Invalid sfn ("_sfn_") for "_path_". Failed to mark rollback completed as of "_lastjrncnt_" in "_dbpath,1 /* broadcast and log message*/,1  /* Warning */)
		  } else {
		     s rc=$SYSTEM.Mirror.DejournalClearTRollInfo(sfn)
		     if 'rc {
		        d $zu(9,"","Failed to mark rollback completed as of "_lastjrncnt_" in "_dbpath,1 /* broadcast and log message*/,1  /* Warning */)
		     }
		  }
	   }	
	   s path=$o(dblist(path),1,info)
	}   
}
RetrieveJournalFile(mirname,jrnfilecnt,startoff,checklog=1,UpdateStatus=0) PUBLIC {
	/* Find a mirror member who has this journal file and get it from them.
	   If the file isn't marked with a valid end, we should be able to set the
	   valid end after we retrieve it.
	   WARNING: journal file names which inlude the local path cannot be
	            cached across calls to this function as the journal file
	            may get moved to the alternate directory if there is insufficient
	            space to retrieve it. After calling this function the filename
	            needs to be looked up in the mirror journal file log using
	            the mirjrnfilecnt.
	   Returns: 1 = success, we now have the file
	            0 = failure
	*/
	if $SYSTEM.Mirror.GetInfo()'["DEFINED" {
		d $zu(9,"","Failed to retrieve journal file #"_jrnfilecnt_" because this system is not a mirror member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if 'systemcnt {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Can't retrieve journal files - no other mirror members")
		quit 0
	}
	s $zt="err"
	s status=""
	s ValidEndRequired=0,Startid=1
	if systemcnt>1&&(+$G(^SYS("MIRRORSET")))&&('$$IsRelayClient^MIRRORCOMM(mirname)) {
		s primaryid=$$GetCurrentPrimaryID(mirname)
		if primaryid<0 {
			Set ValidEndRequired=1
		} else {
			s (Startid,systemcnt)=primaryid
		}
	}
    for id=Startid:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
	      s rc=$$GetMissingJournalFiles^MIRRORCTL(mirname,id,jrnfilecnt,startoff,jrnfilecnt,0,ValidEndRequired)
	      s status=$LG(rc)
	      if status="OK" {
	          if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Retrieved journal file #"_jrnfilecnt_" from "_name)
		      quit  ; we succeeded
	      }
	      s err=$I(err),err(err)=$lb(name,$LG(rc,2))
       }
    }
    if status'="OK" {
	    s errcnt=+$G(err)
	    for i=1:1:errcnt {
		    s rc=err(i)
	        d $zu(9,"","("_mirname_") Failed to retrieve journal file #"_jrnfilecnt_" from "_$LG(rc)_": "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
	    }
	    quit 0
    }
    if 'checklog goto doneOK
    ; double check that we can read the file by validating the journal file cnt
	s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfilecnt,mirname)
	if '+jrnfile {
		d $zu(9,"","("_mirname_") Failed to find journal file #"_jrnfilecnt_" in log after retrieving it",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s jrnfile=$P(jrnfile,",",2)
	s jrninfo=$zu(78,22,jrnfile,99)
	if +jrninfo<1 {
		d $zu(9,"","("_mirname_") Failed to read header of retrieved file # "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s fd=$P(jrninfo,",",13+1)
    if fd'=jrnfilecnt {
	    d $zu(9,"","("_mirname_") Filecount ("_fd_") in retrieved file "_jrnfile_" doesn't match expected value: "_jrnfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
	    if '$ZU(140,6,jrnfile,"BAD"_jrnfile) {
	        d $zu(9,"","("_mirname_") Renamed /"_jrnfile_"/ to /BAD"_jrnfile,0,0  /* Informational message */)
	    } else {
		    if $ZU(150,5,jrnfile) {
			    d $zu(9,"","("_mirname_") Deleted "_jrnfile,0,0  /* Informational message */)
		    } else {
			    d $zu(9,"","("_mirname_") FAILED to delete "_jrnfile,0,0  /* Informational message */)
		    } 
	    }
    }
doneOK
	if UpdateStatus,$SYSTEM.Mirror.IsMember()=1,$SYSTEM.Mirror.GetStatus(mirname)="TRANSITION" {
		s rc=$$GetStatus^MIRRORCTL(mirname,id)
		if $LG(rc)="PRIMARY" d $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
	}
    quit 1  ; success
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
getMirJrnEnd(jrnfile) PUBLIC {
	/* Returns the "mirror journal end" of the file if its set and if
	   the file contains data through that spot. If the mirror journal
	   end isn't set, or if the journal file is smaller than the 
	   mirror journal end, we return 0. If the file doesn't exist, we return -1
	   If the file exists but we fail to open it, we return -2
	   Call this instead of looking up the JrnHdrMIREND directly as the valid
	   end from the header should only be used if its also present on disk.	*/
	s info=$zu(78,22,jrnfile,99)
	if info<1 quit -1  ; doesn't exist
	s validend=+$P(info,",",16+1)
	if 'validend quit 0  ;end isn't valid
	; open the file and make sure the validend is a valid
	; record in the file
    s fd=$zu(78,5,jrnfile,0)
    if fd<0 {
	   d $zu(9,"","getMirJrnEnd failed to open "_jrnfile_" to validate the end ("_validend_")",1 /* broadcast and log message*/,1  /* Warning */)
	   quit -2   
    }
    do $zu(78,6,fd)
    s endpos=+$zu(78,18,0)
    do $zu(78,7,fd)
    if endpos=validend quit validend
    ; 'validend' isn't in the file, return 0
	quit 0
}
MountMirroredDBs(caller,mirname="") PUBLIC {
	; In addition to getting called when MIRRORMGR starts this can
	; be called by STU after it loads the Mirror config before calling STU^JRNRESTO
	s dir=$O(^SYS("UCI",""))
	while dir'="" {
		s mirrorbit=+$ZU(40,8,28),mirnowritebit=$zu(40,8,30)
 		s info=$zu(49,dir)
 		s sfn=+info
 		s dbattrib=$s(sfn<-1:0,1:+$p(info,",",17))
 		s dbstatus=$s(sfn<-1:0,1:+$p(info,",",18))
		if sfn<0||(sfn=$zu(40,0,41)) {
			if $zb(dbattrib,mirrorbit,1) {
			   if mirname]"" {
				   s dbmirname=$p($SYSTEM.Mirror.DBGetInfoByName(0,dir),"^",8)
				   if mirname'=dbmirname goto next
			   }
remount		   do $ZU(17,dir)
			   s info=+$ZU(49,dir)
			   if (info<0)!(info=$zu(40,0,41)) {
				  d $zu(9,"",caller_": Failed to mount mirrored database: "_dir,1 /* broadcast and log message*/,1  /* Warning */)
			   } else {
				  if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"",caller_": Mounted mirrored database: "_dir)
			   }
			}
		} elseif caller="Startup"&&$zb(dbstatus,mirnowritebit,1) {
			if mirname]"" {
			   s dbmirname=$p($SYSTEM.Mirror.DBGetInfoByName(0,dir),"^",8)
			   if mirname'=dbmirname goto next
			}
			s info=$zu(3,dir)
			goto remount
		}
next 	s dir=$O(^SYS("UCI",dir))
	}
}
NotifyAsyncMembers(mirname,id,delete) PUBLIC {
	q:##class(EMS.Instance).IsManaged("Config.Mirrors")
	s primary=$SYSTEM.Mirror.IsPrimary()
	s membername=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
	s i=$o(^SYS("MIRRORSET",mirname,"Member",$s(primary:0,1:101-1)),1,info)
	while (i'="") {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",i))
		if (+$LG(info,10))&&$s(delete:id=""||(id'=$LG(info)),1:id'=i) {
			if $G(^MIRROR(mirname,"Status","Member",i,"Version"))>3&&primary {
				s rc=$$NotifyMirrorChange^MIRRORCTL(mirname,i,membername)
			} elseif i'<101&&(id'="") {
				s msg=$s(delete:id,1:id_":"_$LB($G(^SYS("MIRRORSET",mirname,"Member",id))))
				s rc=$$NewFailOverMember^MIRRORCTL(mirname,i,msg)
			}
			if ($LG(rc)'="OK") {
				d $zu(9,"","NotifyAsyncMembers: Failed to notify "_$LG(info)_" for mirror configuration change. Error="_$LG(rc)_":"_$LG(rc,2),1 /* broadcast and log message*/,2  /* Severe error */)
			}
		}
		s i=$o(^SYS("MIRRORSET",mirname,"Member",i),1,info)
	}
}
getLocalAgentInfo(mirname,addr,basedir,sysguid) {
	s x=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.Mirrors("_mirname_") to read virtual IP information - AddVirtualAddress failed",1 /* broadcast and log message*/,1  /* Warning */)	
		quit $LB("0,Could not read virtual IP information")
	}
	if (mirname]""),(x.Name'=mirname) {
		d $zu(9,"","Requested mirror name ("_mirname_") does not match our configured mirror name ("_x.Name_")",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Mirror name mismatch")
	}
	;Need our system name to find the interface for this system
	s x=##class(Config.MirrorMember).Open()
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.MirrorMember to read local system information",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	set systemName=x.SystemName
	if systemName="" {
		d $zu(9,"","Failed to read our mirror system name",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	s x=""
	s x=##class(Config.MapMirrors).Open(mirname,systemName)  ;open our configuration
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.MapMembers("_mirname_","_systemName_") to read virtual interface information",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read virtual interface information")
	}
	set addr=x.AgentAddress_"|"_x.AgentPort
	if x.AgentAddress '= x.MirrorAddress {
		set addr=addr_","_x.MirrorAddress_"|"_x.AgentPort
	}
	if (x.AgentAddress '= x.ECPAddress) && (x.MirrorAddress '= x.ECPAddress) {
		set addr=addr_","_x.ECPAddress_"|"_x.AgentPort
	}
	set basedir=x.InstanceDirectory
	set sysguid=x.GUID
	quit $LB(1)
}
getVIPandIface(mirname,addrIn,vipOut,ifOut) {
	set mirname=$g(mirname),addrIn=$g(addrIn)
	k vipOut,ifOut
	s vipOut="",ifOut=""
	s x=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.Mirrors("_mirname_") to read virtual IP information - AddVirtualAddress failed",1 /* broadcast and log message*/,1  /* Warning */)	
		quit $LB("0,Could not read virtual IP information")
	}
	if (mirname]""),(x.Name'=mirname) {
		d $zu(9,"","Requested mirror name ("_mirname_") does not match our configured mirror name ("_x.Name_")",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Mirror name mismatch")
	}
	set:addrIn="" addrIn=x.VirtualAddress
	if addrIn="" {
		quit $LB(1)	
	}
	;Need our system name to find the interface for this system
	s x=##class(Config.MirrorMember).Open()
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.MirrorMember to read local system information",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	set systemName=x.SystemName
	if systemName="" {
		d $zu(9,"","Failed to read our mirror system name",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	set iface=x.VirtualAddressInterface
	if iface="" {
		d $zu(9,"","Interface configuration is required but missing",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Virtual interface configuration is unreadable")
	}
	set vipOut=addrIn
	set ifOut=iface
	quit $LB(1)
}
AddVirtualAddress(mirname,Addr,FromAgent=0) PUBLIC {
	s $zt="err"
	set mirname=$g(mirname),Addr=$g(Addr)
	set rc=$$getVIPandIface(mirname,Addr,.mirVIP,.mirIface)
	if '$lg(rc) quit rc
	if mirVIP="" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","No mirror Virtual IP configured - exiting AddVirtualAddress")
		quit $LB(1)	
	}
	if mirIface="NoMatchedSubnet" {
		d $zu(9,"","Virtual IP is not added because no interface support VIP '"_mirVIP_"'.",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB(1)	
	}
	s rc=##class(SYS.MirrorConfiguration).ValidateVirtualAddress(mirVIP,0,mirIface)
	if '(''rc) {
		quit $LB("0,"_$SYSTEM.Status.GetErrorText(rc))
	}
	If ($zversion(1)=3)&&('FromAgent) {
		set rc=$$getLocalAgentInfo(mirname,.addrlist,.basedir,.targguid)
		if '$lg(rc) quit rc
		set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,1,Addr)
		set status=$LG(rc)
		if status="OK" quit $LB($lg(rc,2))
		quit $LB("0,"_$LG(rc,2))
	} else {
		if $System.INetInfo.CheckAddressExist(mirVIP) {
			d $zu(9,"","Virtual IP ("_mirVIP_") is still assigned to another system.",1 /* broadcast and log message*/,1  /* Warning */)
			quit $LB("0,Virtual IP ("_mirVIP_") is still assigned to another system.")		
		}
	}
	;s rc=$SYSTEM.INetInfo.AddIPToInterface(mirIface,mirVIP)
	s rc=##class(SYS.Mirror).AddVirtualIPAddress(mirIface,mirVIP)
	if 'rc {
		d $zu(9,"","Failed to add Virtual IP ("_mirVIP_") to interface "_mirIface,1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,AddVirtualAddress Failed - could not assign IP to interface")	
	}
    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Added virtual IP address "_mirVIP_" to interface "_mirIface)
    if ($zversion(1)=1)&&($L($p(mirVIP,"/"),":")>2) {
	    s reached=0
	    for i=1:1:3 {
		    h 2
		    s x=$zf(-1,"mc sys$system:tcpip$ifconfig "_mirIface_" inet6  alias "_$p(mirVIP,"/"),"nla0:")
	    	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","AddVirtualAddress: ifconfig add alias "_mirVIP_" to interface "_mirIface_" returned="_x_"  for "_i)
	    	if $zf(-1,"mc sys$system:tcpip$ping -t 1 -c 3 "_$p(mirVIP,"/"),"nla0:")#2 {
		    	s reached=1
		    	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","AddVirtualAddress: Ping found the VIP")
		    	quit
	    	}
	    }
	    if 'reached d $zu(9,"","AddVirtualAddress: ping "_mirVIP_" in "_mirIface_" failed after adding alias. You should run 'ifconfig "_mirIface_" inet6  alias "_$p(mirVIP,"/")_"' to fix it.",1 /* broadcast and log message*/,1  /* Warning */)
    }
	q $LB(1)
err set $zt="" q $LB("0,"_$ZE)
}
DeleteVirtualAddress(mirname,Addr,FromAgent=0,Iface="") PUBLIC {
	s $zt="err"
	set mirname=$g(mirname),Addr=$g(Addr)
	If ($zversion(1)=3)&&('FromAgent) {
		set rc=$$getLocalAgentInfo(mirname,.addrlist,.basedir,.targguid)
		if '$lg(rc) quit rc
		set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0,Addr,Iface)
		set status=$LG(rc)
		if status="OK" quit $LB($lg(rc,2))
		quit $LB("0,"_$LG(rc,2))
	}
	set rc=$$getVIPandIface(mirname,Addr,.mirVIP,.mirIface)
	if '$lg(rc) quit rc
	if mirVIP="" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","No mirror Virtual IP configured - exiting DeleteVirtualAddress")
		quit $LB(1)	
	}
	if mirIface="NoMatchedSubnet" {
		d $zu(9,"","Virtual IP is not deleted because no interface support VIP '"_mirVIP_"'.",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB(1)	
	}
	if Iface'="" s mirIface=Iface
	;s rc=$SYSTEM.INetInfo.DeleteIPFromInterface(mirIface,mirVIP)
	s rc=##class(SYS.Mirror).DeleteVirtualIPAddress(mirIface,mirVIP)
	if 'rc {
		d $zu(9,"","Failed to remove Virtual IP ("_mirVIP_") from interface "_mirIface,0,0  /* Informational message */)
		quit $LB("0,DeleteVirtualAddress Failed - could not remove IP from interface")	
	}
    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Deleted virtual IP address "_mirVIP_" from interface "_mirIface)
	q $LB(1)
err set $zt="" q $LB("0,"_$ZE)
}
releaseVIPonAllMembers(mirname) {
	set $zt="err"
	;First, check if this mirror set has a virtual IP in the first place...
	set rc=$$getVIPandIface(mirname,,.mirVIP,.mirIface)
	if '$lg(rc) quit rc
	if mirVIP="" {  ;Nothing to do...
		quit $LB(1)	
	}
	set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
	set rc=rs.Execute(mirname)
	if 'rc {
		d $zu(9,"","Failed to retrieve members of MapMirrors."_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not release virtual IP on other systems")	
	}
	while rs.Next() {
		set name=rs.Data("Name")
		quit:name="" 
		if rs.Data("MemberType")'=0 continue
		kill params
		set x=##class(Config.MapMirrors).Get(mirname,name,.params)
		if x {
			set agentip=$g(params("AgentAddress"))
			set basedir=$g(params("InstanceDirectory"))
			set agentport=$g(params("AgentPort"))
			set targguid=$G(params("GUID"))
			s addrlist=agentip_"|"_agentport
			if agentip'=params("MirrorAddress") {
				s addrlist=addrlist_","_params("MirrorAddress")_"|"_agentport
			}
			if (agentip'=params("ECPAddress")) && (params("MirrorAddress")'=params("ECPAddress"))  {
				s addrlist=addrlist_","_params("ECPAddress")_"|"_agentport
			}
			set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0)
			set status=$LG(rc)
			if status="OK"&&+$p($lg(rc,2),",") {  ;the status will return OK if the other system was contactable - the second peice will contain the actual error (if any)...
				if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Delete VIP on member """_name_""" succeeded.")	
			}
		}
	}
	s $ZT=""
	quit $LB(1)  ;done
err set $zt="" quit $LB("0,"_$ZE)
}
PrimaryDiscovery(mirname) PUBLIC {
	set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
	set rc=rs.Execute(mirname)
	if 'rc {
		d $zu(9,"","PrimaryDiscover: Failed to retrieve members of MapMirrors."_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0	
	}
	s ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
	while rs.Next() {
		if rs.Data("ConnectsTo")'=""||(ourname=rs.Data("Name")) continue
		s addrlist=rs.Data("AgentAddress")_"|"_rs.Data("AgentPort")
		if rs.Data("AgentAddress") '= rs.Data("MirrorAddress") {
			set addrlist=addrlist_","_rs.Data("MirrorAddress")_"|"_rs.Data("AgentPort")
		}
		if (rs.Data("AgentAddress") '= rs.Data("ECPAddress")) && 
				(rs.Data("MirrorAddress") '= rs.Data("ECPAddress")) {
			set addrlist=addrlist_","_rs.Data("ECPAddress")_"|"_rs.Data("AgentPort")
		}
		s member($C(rs.Data("MemberType")+$A("A"))_rs.Data("Name"))=$LB(rs.Data("MemberType"),addrlist,rs.Data("InstanceDirectory"),rs.Data("GUID"))
	}
	s rs=""
	s m=$O(member(""),1,info)
	s found=0
	while m'="" {
		s mtype=$LG(info),agentip=$LG(info,2),basedir=$LG(info,3)
		s targguid=$LG(info,4)
		if mtype=0 {
checkstatus	;
			s rc=$$GetStatusByAddr^MIRRORCTL(mirname,agentip,targguid,basedir)
			if $LG(rc)="PRIMARY" {
				do SynchConfigWithPrimary^MIRRORCOMM(mirname,"",agentip,targguid,basedir)
				s ^MIRROR(mirname,"PrimaryMember")=0
				s pname=$e(m,2,*)
				f i=1:1:$G(^SYS("MIRRORSET",mirname,"Member"),0) {
					if pname=$LG($G(^SYS("MIRRORSET",mirname,"Member",i))) {
						s ^MIRROR(mirname,"PrimaryMember")=i
					}
				}
				k ^MIRROR(mirname,"PendingDNUpdates")
				s found=1
				quit
			}
			if $LG(rc)="SSLERR"||($LG(rc,2)["SSL ID") {
				d $zu(9,"","PrimaryDiscovery: Member '"_$e(m,2,*)_"' error: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				s sslfail(m)=$LB(agentip,basedir,targguid)
			} elseif $LG(rc)="LOCALSSLERR" {
				s rc=$$AddPendingDNUpdates^MIRRORCOMM(mirname,$e(m,2,*),agentip,targguid,basedir)
				if '+$LG(rc) {
					d $zu(9,"","PrimaryDiscovery: (LOCALSSLERR) Failed to add pending DN updates list for member """_$e(m,2,*)_""" reason: "_$lg(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
		} else {
			s rc=$$TEST^MIRRORCTL(mirname,agentip,targguid,basedir,1)
			if $LG(rc) goto checkstatus
		}
		q:$G(^MIRROR(mirname,"Status","MGR"))="Exit"
		s m=$O(member(m),1,info)
	}
	i 'found,$d(sslfail),'##class(EMS.Instance).IsManaged("Config.Mirrors") {
		s ourinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
		s m=$O(sslfail(""),1,info)
		while m'="" {
			s agentip=$LG(info),basedir=$LG(info,2),targguid=$LG(info,3)
			s rc=$$SetApprovalByAddr^MIRRORCTL(mirname,agentip,targguid,basedir,ourinfo)
			s m=$O(sslfail(m),1,info)
		}
	}
	quit found
}
 /*	IsOtherNodeDown(takeoverflag)
    When takeoverflag is 1 the local node will start to become the
    primary if IsOtherNodeDown() returns "isDown" (1). When takoverflag
    is zero then IsOtherNodeDown is either being called @ startup where
    we're just trying to figure out whether the routine exists or not,
    or IsOtherNodeDown is being called in some retry code which doesn't
    want to continue until we know the other node is down. In this case
    IsOtherNodeDown() will be called again, with takeoverflag=1, before
    the node becomes the primary.
    The old form of IsOtherNodeDown^ZMIRROR() didn't take a parameter.
    The new form takes the arg parameter so the subroutine can know
    whether it is being called during mirror failover where if it returns
    1 the current node will try to become the primary or during mirror
    startup (arg=0) where we're just checking to see that the entry
    point exists. Here we have to trap the parameter error so that
    both forms continue to work.
 */
IsOtherNodeDown(arg) {
	s arg=+arg  ;should be 0 or 1
	try {
		s isDown=$$IsOtherNodeDown^ZMIRROR(arg)
	} catch exception {
	    if "<PARAMETER>"[exception.Name {
		    ; Must be the older form - try it w/no parameter
		    try {
			    s isDown=$$IsOtherNodeDown^ZMIRROR()
		    } catch exception {
				d $zu(9,"",exception.Name_" calling $$IsOtherNodeDown^ZMIRROR(). Assuming node is up",1 /* broadcast and log message*/,1  /* Warning */)
				s isDown=0  ;assume other node is up
		    }
	    } else {
			d $zu(9,"",exception.Name_" calling $$IsOtherNodeDown^ZMIRROR(1). Assuming node is up",1 /* broadcast and log message*/,1  /* Warning */)
			s isDown=0  ;assume other node is up
	    }
	}
	quit isDown
}    
MonitorVIPAddress(mirname) PUBLIC {
	s $zt="err"
	if $SYSTEM.Mirror.GetInfo()'["PRIMARY"	{
		k ^||FirstVIPMonitor
		quit 1
	}
	if $G(^||FirstVIPMonitor) k ^||FirstVIPMonitor quit 0
	s cls=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(cls) {
		d $zu(9,"","MonitorVIPAddress error: Failed to open Config.Mirrors("_mirname_") to read virtual IP information",1 /* broadcast and log message*/,1  /* Warning */)	
	    quit 0
	}
	s vipAddr=cls.VirtualAddress  ;"" if there isn't one
	s cls=""
	if vipAddr="" {
		quit 0
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","MonitorVIPAddress: failed to read mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s interface=cls.VirtualAddressInterface
	s cls=""
	if interface="NoMatchedSubnet" quit 0
	s rc=$SYSTEM.INetInfo.CheckAddressExist(vipAddr)
	if rc=1 {
		quit 0
	}
    s ok=$$AddVirtualAddress(mirname)
    if '$lg(ok) {
		s rc=$SYSTEM.INetInfo.CheckAddressExist(vipAddr)
		if rc=1 {
			; Generate a warning message to let someone know that something went wrong
			; (eg. a ping failed) but that its ok now
			d $zu(9,"","MonitorVIPAddress: Succesfully reached VIP address "_vipAddr_" after outage",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}	    
        d $zu(9,"","MonitorVIPAddress error: Failed to reestablish VIP address "_vipAddr_" (reason: "_$p($lg(ok),",",2,999)_")",1 /* broadcast and log message*/,2  /* Severe error */)
	    quit 0
    }
    ; We succeeded in adding the address, make sure ping works
	s rc=$SYSTEM.INetInfo.CheckAddressExist(vipAddr)
	if rc=1 {
		d $zu(9,"","MonitorVIPAddress: Succesfully reestablished VIP address "_vipAddr,1 /* broadcast and log message*/,1  /* Warning */)
	} else {
        d $zu(9,"","MonitorVIPAddress error: Ping failed for reestablished VIP address "_vipAddr,1 /* broadcast and log message*/,2  /* Severe error */)
	}
	quit 0  ;failure means this stays queued
err ;
	s $zt=""
	d $zu(9,"","MonitorVIPAddress caught unexpected error: "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
	quit 0 ;leave queued (maybe we shouldn't in this case?)
}
 /*	RetryGetStatus()
    This is queued to the retry list when we want to
    wait for the $$GetStatus() result of a mirror member
    go change.
    Returns:  1 - Current status is different than oldStatus or
                  we failed to read the status
              0 - Current status is the same as oldStatus
 */
RetryGetStatus(mirname,id,oldStatus) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    quit 1  ; treat this as success - node doesn't exist any more
    }
    s rc=$$GetStatus^MIRRORCTL(mirname,id)
    s status=$LG(rc)  
	if status=oldStatus {
		quit 0  ;status hasn't changed, keep waiting
	}
	if status["ERR" {
		quit 0  ;ignore ERR, its not a useful status
	}
	quit 1  ;status has changed or we had some trouble	
}
LockMirroredDB(mirname) public {
	k ^||LockedDB
	s mirrorbit=+$ZU(40,8,28),rc=1
	s dejrnchkcnt=+$G(^MIRROR(mirname,"dejrnchkpnt"))
	s dejrnchkoff=+$P($G(^MIRROR(mirname,"dejrnchkpnt")),"^",2)
	s dir=$O(^SYS("UCI",""))
	while dir'="" {
 		s info=$zu(49,dir)
 		s sfn=+info
		if sfn>=0&&(sfn'=$zu(40,0,41))&&$zb(+$p(info,",",17),mirrorbit,1) {
			s dbinfo=$SYSTEM.Mirror.DBGetInfoByName(0,dir)
			s dbmirname=$p(dbinfo,"^",8),dbjrncnt=$p(dbinfo,"^",3)
			if mirname=dbmirname,dejrnchkcnt=0||(dejrnchkcnt<=dbjrncnt) {
				if ('$zb(+$p(info,",",18),($zu(40,8,11)+$zu(40,8,35)+$zu(40,8,30)+$zu(40,8,29)+$zu(40,8,32)+$zu(40,8,36)),1)) {
					Lock +^%ISC.CatchupDB(sfn):5
					if '$T {
						d $zu(9,"","("_mirname_") Mirrored DB: "_dir_" (sfn#:"_sfn_") is already locked.",0,0  /* Informational message */)
						s rc=0
						quit
					}
					s ^||LockedDB(sfn)=""
				}
			}
		}
		s dir=$O(^SYS("UCI",dir))
	}
	if 'rc {
		d UnlockMirroredDB()
	}
	quit rc
}
UnlockMirroredDB() {
	s sfn=$o(^||LockedDB(""))
	while sfn'="" {
		Lock -^%ISC.CatchupDB(sfn)
		s sfn=$o(^||LockedDB(sfn))
	}
	k ^||LockedDB
}
ClearLastFileValidEnd(mirname) {
	s $zt="err"
	do $SYSTEM.Mirror.LastFileValidFlag(0)
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if +rc<=0 q
	s jrnfcnt=+rc,jrnfile=$p(rc,",",2)
	s rc=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,0,1)
	i 'rc {
		d $zu(9,"","ClearLastFileValidEnd: Failed to clear valid end of "_jrnfile_" ("_jrnfcnt_")",1 /* broadcast and log message*/,1  /* Warning */)
		q
	}
	if $d(^MIRROR(mirname,"lastvalidjrnfile"),last),jrnfcnt=+last {
		if jrnfcnt=1 k ^MIRROR(mirname,"lastvalidjrnfile") q
		s jrnfcnt=jrnfcnt-1
		s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfcnt,mirname)
		if '+jrnfile k ^MIRROR(mirname,"lastvalidjrnfile") q
		s jrnfile=$P(jrnfile,",",2)
		s ^MIRROR(mirname,"lastvalidjrnfile")=jrnfcnt_"^"_jrnfile
	}
err q
}
Updatelastjvalidjrnfile(mirname) {
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<=0 {
	   d $zu(9,"","("_mirname_") Updatelastjvalidjrnfile failed to look up last valid file in journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s lastjrnfile=$P(rc,",",2)
	s lastjrnfilecnt=+rc
	s dejrnchkcnt=+$G(^MIRROR(mirname,"dejrnchkpnt"))
	s dejrnchkoff=+$P($G(^MIRROR(mirname,"dejrnchkpnt")),"^",2)
	s curfcnt=+$G(^MIRROR(mirname,"lastvalidjrnfile"))
	if $SYSTEM.Mirror.LastFileValidFlag() {
		if $$getMirJrnEnd(lastjrnfile)<=0 {
			d $zu(9,"","Updatelastjvalidjrnfile: last journal file "_lastjrnfile_"("_lastjrnfilecnt_") did not have valid end",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		if curfcnt<lastjrnfilecnt {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Updatelastjvalidjrnfile: LastFileValidFlag is set and updated lastvalidjrnfile with "_lastjrnfilecnt_"^"_lastjrnfile)
			s ^MIRROR(mirname,"lastvalidjrnfile")=lastjrnfilecnt_"^"_lastjrnfile
		} elseif curfcnt>lastjrnfilecnt {
			d $zu(9,"","Updatelastjvalidjrnfile: last journal file #"_lastjrnfilecnt_" is less than current lastvalidjrnfile #"_curfcnt,1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		} else {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Updatelastjvalidjrnfile: LastFileValidFlag is set and lastvalidjrnfile match "_lastjrnfilecnt_"^"_lastjrnfile)
		}
		quit 1
	}
	s found=0
	if curfcnt {
		s endfcnt=curfcnt
	} else {
		s endfcnt=dejrnchkcnt-1
	}
	for jrnfcnt=lastjrnfilecnt:-1:endfcnt {
		s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfcnt,mirname)
		if '+jrnfile {
			d $zu(9,"","Updatelastjvalidjrnfile: journal file #"_jrnfcnt_" does not exist in mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
		s jrnfile=$P(jrnfile,",",2)
		s rc=$$getMirJrnEnd(jrnfile)
		if rc>0 {
			s found=1
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Updatelastjvalidjrnfile: LastFileValidFlag is NOT set and updated lastvalidjrnfile with "_jrnfcnt_"^"_jrnfile)
			s ^MIRROR(mirname,"lastvalidjrnfile")=jrnfcnt_"^"_jrnfile
			quit
		}
		if rc<0 {
			d $zu(9,"","Updatelastjvalidjrnfile: journal file "_jrnfile_"("_jrnfcnt_") does not exist",1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
	}
	quit found
}
ResolveFrozenPrimary(mirname,getstatusrc) {
	set $zt="err"
	set info=$system.Mirror.GetInfo()	
	if ($system.Mirror.IsMember()'=1) || (info["BACKUP") || (info["PRIMARY") { 
		d $zu(9,"","ResolveFrozenPrimary called in unexpected state",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	set id=1  ;the other node
	set info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" {
		d $zu(9,"","Missing information for mirror member #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	if $get(getstatusrc)="" {
		set getstatusrc=$$GetStatus^MIRRORCTL(mirname,id)
	}
	set status=$LG(getstatusrc)
	if status="PRIMARY" {
		set primarycurjrncnt=+$LG(getstatusrc,2)
		set primarytroubleflag=+$LG(getstatusrc,3)
		set primaryfailovermode=$LG(getstatusrc,4)
	} elseif status="HUNG" {		
		set primarycurjrncnt=+$LG(getstatusrc,2)
		set primarytroubleflag=+$LG(getstatusrc,4)
		set primaryfailovermode=$LG(getstatusrc,5)
	} elseif (status="ERR") || (status="TIMEOUT") {
		quit 0 ; retry on error or timeout
	} else {
		quit 1 ; nothing to resolve
	}
	if ('primarytroubleflag) || ((primarytroubleflag=1) && (primaryfailovermode'=1)) {
		quit 1 ; nothing to resolve
	}
	set lastjrncnt=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +lastjrncnt=-1 {
		quit 0 ; error opening journal.log - retry later
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Backup found current last journal file "_lastjrncnt)
	set restart=1
	set lastjrncnt=+lastjrncnt
	if (lastjrncnt>primarycurjrncnt) {
		set force=1
		d $zu(9,"","Current journal file is "_lastjrncnt_". Forcing down frozen old primary on file #"_primarycurjrncnt,0,0  /* Informational message */)
		set status=$$ForceNodeDown^MIRRORCTL(mirname,id,1)
		if $LG(status)'="OK" {
			d $zu(9,"","Failed to force down frozen primary. Reason: "_$LG(status,2),1 /* broadcast and log message*/,1  /* Warning */)
			quit -1 ; error
		}
		set waittime=120
	} else {
		set force=0
		do $SYSTEM.Mirror.ActiveBackupFlag(0)
		if $SYSTEM.Mirror.LastFileValidFlag() { 
			do ClearLastFileValidEnd(mirname)
		}
		if primarytroubleflag=2 {
			d $zu(9,"","Clearing permanent trouble state on primary",0,0  /* Informational message */)
			set rc=$$ResetTrouble^MIRRORCTL(mirname,id)
			if $LG(rc)'="OK" {
				d $zu(9,"","Failed to clear permanent trouble: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				quit -1
			}
		}
		if primaryfailovermode=1 {
			d $zu(9,"","Switching frozen primary to Agent Controlled failover mode via agent",0,0  /* Informational message */)
			do $SYSTEM.Mirror.FailoverRule(2)
			set rc=$$SetAgentContactMode^MIRRORCTL(mirname,id,primarycurjrncnt)
			if $LG(rc)'="OK" {
				d $zu(9,"","Failed to switch frozen primary to Agent Controlled failover mode: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				quit -1
			}
		}
		set waittime=30
	}
	do {
		hang 1
		set getstatusrc=$$GetStatus^MIRRORCTL(mirname,id)
		set status=$LG(getstatusrc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
		set waittime=waittime-1
	} while (waittime>0) && 
	        ((status="HUNG") || (status="ERR") || 
	         (force && (status="PRIMARY")))
	d $zu(9,"","Frozen primary now reports status: "_status,0,0  /* Informational message */)
	quit:force 2
	quit 3
err
	set $zt=""
	d $zu(9,"","Unexpected error resolving frozen primary: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit:$get(restart) -1
	quit 0
}
UpdateDNPost(args) PUBLIC {
	d post($LG(args),"",0,"UPDATEDN:"_$LG(args,2)_":"_$LG(args,3))
	q
}
ValidateFailoverPartner(mirname) PUBLIC {
	if '$G(^SYS("MIRRORSET",mirname,"Member"),0) quit 1
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if info="" quit 1
	s localinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
	if localinfo="" {
		d $zu(9,"","ValidateFailoverPartner: Could not find local member information.",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s name=$LG(info)
	s addrlist=$$BuildAgentAddrlist^MIRRORCTL(info)
	s basedir=$LG(info,6)
	s targguid=$LG(info,2)
	s rc=$$ValidatePartner^MIRRORCTL(mirname,addrlist,targguid,basedir,$LG(localinfo),$LG(localinfo,2))
	if $LG(rc)="OK" {
		s ListedDN=$LG(rc,3)
		If $LG(rc,2),+$LG(rc,5),(ListedDN'=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),7)) {
			d $zu(9,"","ValidateFailoverPartner error: DN of local system not matched with DN in Mirror member """_name_""".",1 /* broadcast and log message*/,1  /* Warning */)
			s rc=$$SetApproval^MIRRORCTL(mirname,1,$G(^SYS("MIRRORSET",mirname,"Member",0)))
			quit 0
		}
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ValidateFailoverPartner: Validation succeed.")
		quit 1
	}
	if $LG(rc)="UNKNCMD" {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ValidateFailoverPartner: Remote does not recognize VALIDATEPARTNER request")
		Quit 1
	}
	if $LG(rc)="LOCALSSLERR" {
		s rc=$$AddPendingDNUpdates^MIRRORCOMM(mirname,name,addrlist,targguid,basedir)
		if '+$LG(rc) {
			d $zu(9,"","ValidateFailoverPartner: (LOCALSSLERR) Failed to add pending DN updates list for member """_name_""" reason: "_$lg(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		}
		quit 0
	}
	if $LG(rc)="ERR" {
		d $zu(9,"","ValidateFailoverPartner: Failed: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0
	}
	if $LG(rc)="TIMEOUT" {
		d $zu(9,"","ValidateFailoverPartner: Failed to contact other failover member - waiting for other node to become available",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	d $zu(9,"","ValidateFailoverPartner: Unknown return code "_$LG(rc),1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
BackupDaemonExit(mirname,timeout) {
	Lock +^SYS("MIRRORSET",mirname,"BackupClient"):timeout s rc=$T
	i rc Lock -^SYS("MIRRORSET",mirname,"BackupClient")
	quit rc
}