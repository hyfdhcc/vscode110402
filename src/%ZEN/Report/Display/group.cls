Include %ZEN.ReportUtil

/// The &lt;group&gt; tag indicates that its content should be displayed for each
/// child contained within the XML containing tag given by <group>'s name attribute.
/// When developing a stylesheet for XML data generated by the ReportDefinition XData
/// block, one should nest the &lt;group&gt; tags in the same order within each XData block,
/// with the same names.
Class %ZEN.Report.Display.group Extends (childrenNode, tableOutput) [ Inheritance = right, System = 4 ]
{

Property field As %ZEN.Datatype.string(XMLPROJECTION = "NONE");

Property group As %ZEN.Datatype.string(XMLPROJECTION = "NONE");

Property removeEmpty As %ZEN.Datatype.boolean(XMLPROJECTION = "NONE") [ InitialExpression = 0 ];

/// If pagebreak is true, a pagebreak is added
/// between records within the group.
Property pagebreak As %ZEN.Datatype.boolean [ InitialExpression = "0" ];

/// Specifies the thickness of the line to drawn between records within the group.  If
/// <property>line</property>=0, no line is drawn.
Property line As %ZEN.Datatype.length [ InitialExpression = 0 ];

/// Specifies the tag to match within the XML data.  The <group>'s contents are displayed
/// for each element that matches the name.
Property name As %ZEN.Datatype.name [ Required ];

/// Use to separate rendered items
Property separator As %ZEN.Datatype.string(VALUELIST = ",none,line") [ InitialExpression = "none" ];

/// comma separated list of xpaths by which the group will be sorted
Property orderby As %ZEN.Datatype.string;

/// specify type of data used in group sort orderby - text, number or qname
Property dataType As %ZEN.Datatype.string(VALUELIST = ",text,number,qname", XMLNAME = "data-type") [ InitialExpression = "text" ];

/// top-level group being used to construct small multiple
Property smallMultiple As %ZEN.Datatype.boolean(XMLNAME = "small-multiple");

/// name of small multiple, must be specified to have more than one on a report page
Property smallMultipleName As %ZEN.Datatype.string(XMLNAME = "small-multiple-name") [ InitialExpression = "small-multiple" ];

/// display group used by XSL:for-each loop to provide multiple page sequences 
Property primaryGroup As %ZEN.Datatype.boolean [ InitialExpression = 0 ];

/// Test each itteration of the group with the defined ifxpath condition
Property testEachifxpath As %ZEN.Datatype.string;

/// property "pagebreakBefore", if true, applies page break logic before "xsl:aply-templates".
/// Move pagebreak to before each entry in the group 
Property pagebreakBefore As %ZEN.Datatype.boolean [ InitialExpression = 0 ];

/// Added new property "breakCheck", if defined, contains the condition used to determine when a page break should execute.
/// Condition that will allow pagebreak to be executed 
Property breakCheck As %ZEN.Datatype.string;

Method %DrawToXSLFO(ByRef context As %String, ByRef XSL As %GlobalCharacterStream, delay As %GlobalCharacterStream, ByRef incell As %Boolean) As %Status
{
	Set sc=$$$OK
	Set pagebreak = +..pagebreak
	Set line = (..line'=0)
	$$$groupNumInc
	Set mode = "group"_$$$groupNum
	d ..%IncLevel(.context, .XSL, .delay)
	d ..tagChildren()
	d ..%BeginDrawFo(.context,.XSL,.delay)				
		if ..smallMultiple {
		Do XSL.WriteLine("<xsl:variable name='"_..smallMultipleName_"' >")
	}
	If ..primaryGroup {
		Do XSL.WriteLine("<xsl:apply-templates select='.' mode='"_mode_"' >")
		Do ..%ApplyLevelParameters(.context,.XSL,.delay)
		Do XSL.WriteLine("<xsl:with-param  name='prevmatch' select='position()'/>")
	} Else {
		If (..testEachifxpath = "") {
			Do XSL.WriteLine("<xsl:apply-templates select='"_..qualify(..name)_"' mode='"_mode_"' >")
			Do ..%ApplyLevelParameters(.context,.XSL,.delay)
			Do XSL.WriteLine("<xsl:with-param  name='prevmatch' select='position()'/>")			
		} Else {
			Do XSL.WriteLine("<xsl:variable name='prevmatch' select='position()'/>")
			Do XSL.WriteLine("<xsl:for-each select='"_..qualify(..name)_"'>")
			Do XSL.WriteLine("<xsl:if test='"_..testEachifxpath_"'>")
			If ((..pagebreakBefore)&&(pagebreak)) {
				If (..breakCheck '= "") {
					Do XSL.WriteLine("<xsl:if test='"_..breakCheck_"'>")
				}
				Do XSL.WriteLine("  <fo:block break-after='page'/>")
				If (..breakCheck '= "") {
					Do XSL.WriteLine("</xsl:if>")
				}
			}
			Do XSL.WriteLine("<xsl:apply-templates select='.' mode='"_mode_"' >")
			Do ..%ApplyLevelParameters(.context,.XSL,.delay)
			Do XSL.WriteLine("<xsl:with-param  name='prevmatch' select='position()'/>")			
		}
		
		
	}
	Do ..%DrawSort(.context,.XSL,.delay,..orderby,..dataType)
	Do XSL.WriteLine("</xsl:apply-templates>")

	if ..smallMultiple {
		Do XSL.WriteLine("</xsl:variable>")
	}

	Set XSLFO2=##class(%GlobalCharacterStream).%New()
	Set delay2=##class(%GlobalCharacterStream).%New()
	Set i = ..children.Next("")
	While (i'="") {
		Set child = ..children.GetAt(i)
		d ..updateFromTemplate(.child)		
		Set child.parent=$$$THIS
		Set child.xpath=..parent.xpath_"/"_..name
		Set:child.class="" child.class=..class
		If child.%IsA("%ZEN.Report.Display.item"),child.suppressEmpty {
			Do XSLFO2.WriteLine("<xsl:if test=""string("_child.field_")"">")
		}

		Set sc = child.%DrawToXSLFO(.context,.XSLFO2,.delay2) 
		If ..separator="line" Do XSLFO2.WriteLine(" <fo:block/>")		
		Quit:$$$ISERR(sc)
		If child.%IsA("%ZEN.Report.Display.item"),child.suppressEmpty {
			Do XSLFO2.WriteLine("</xsl:if>")
		}
		Set i= ..children.Next(i)
	}
	Do XSLFO2.Rewind(),delay2.Rewind()
	Do delay.WriteLine("<xsl:template match='"_..qualify(..name)_"' mode='"_mode_"'>")
	Do ..%DeclareLevelParameters(.context,.delay,.delay2)
	Do delay.WriteLine("<xsl:param name='prevmatch' select='position()'/>") //JSL4323
	if ..smallMultiple {
		Do delay.WriteLine("<zr:small-multiple>")
	}
	Do:line delay.WriteLine("<fo:block><fo:leader leader-pattern='rule' leader-length='100%' rule-thickness='"_..line_"'/></fo:block>")
	//Do delay.WriteLine(XSLFO2.Read())
	Do delay.CopyFrom(XSLFO2)
	If ('..primaryGroup) {
		If (..testEachifxpath '= "") {
			If ((pagebreak)&&('..pagebreakBefore)) {
				Do XSL.WriteLine("<xsl:if test='position() != last()'>")
				Do XSL.WriteLine("  <fo:block break-after='page'/>")
				Do XSL.WriteLine("</xsl:if>")
			} 
		} Else {

			If (pagebreak) {
				Do delay.WriteLine("<xsl:if test='position() != last()'>")
				Do delay.WriteLine("  <fo:block break-after='page'/>")
				Do delay.WriteLine("</xsl:if>")
			}
		}
	}
	if ..smallMultiple {
		Do delay.WriteLine("</zr:small-multiple>")
	}
	Do delay.WriteLine("</xsl:template>")
	//Do delay.WriteLine(delay2.Read())
	Do delay.CopyFrom(delay2)
	If (('..primaryGroup)&&(..testEachifxpath '= "")) {
		Do XSL.WriteLine("</xsl:if>")
		Do XSL.WriteLine("</xsl:for-each>")
	}
	do ..%EndLevel(.context,.XSL,.delay)
	d ..%EndDrawFo(.context,.XSL,.delay)		
	Quit sc
}

Method %DrawToHTML(ByRef context As %String, ByRef XSL As %GlobalCharacterStream, delay As %GlobalCharacterStream, ByRef incell As %Boolean) As %Status
{
	Set sc=$$$OK
	Set pagebreak = +..pagebreak
	Set line = (..line'=0)
	$$$groupNumInc
	Set mode = "group"_$$$groupNum
	
	if ..smallMultiple {
		Set ..withinSmallmultiple=1
	}
	; tagChildren() will put withinSmallmultiple setting throughout descendants
	d ..%IncLevel(.context, .XSL, .delay)
	d ..tagChildren()
	d ..%BeginDrawHtml(.context,.XSL,.delay)	
	if ..smallMultiple {
		Do XSL.WriteLine("<xsl:variable name='"_..smallMultipleName_"' >")
	}
	Do XSL.WriteLine("<!-- group name="_..qualify(..name)_" -->")
	Do XSL.WriteLine("<xsl:apply-templates select='"_..qualify(..name)_"' mode='"_mode_"' >")
	Do ..%DrawSort(.context,.XSL,.delay,..orderby,..dataType)
	Do ..%ApplyLevelParameters(.context,.XSL,.delay)
	Do XSL.WriteLine("<xsl:with-param  name='prevmatch' select='position()'/>")	
	Do XSL.WriteLine("</xsl:apply-templates>")
	if ..smallMultiple {
		Do XSL.WriteLine("</xsl:variable>")
	}
	Set XSL2=##class(%GlobalCharacterStream).%New()
	Set delay2=##class(%GlobalCharacterStream).%New()
	Set i = ..children.Next("")
	While (i'="") {
		Set child = ..children.GetAt(i)
		d ..updateFromTemplate(.child)		
		Set child.parent=$$$THIS
		Set child.xpath=..parent.xpath_"/"_..name
		Set:child.class="" child.class=..class
		If child.%IsA("%ZEN.Report.Display.item"),child.suppressEmpty {
			Do XSL2.WriteLine("<xsl:if test=""string("_child.field_")"">")
		}

		Set sc = child.%DrawToHTML(.context,.XSL2,.delay2) 
		
		Quit:$$$ISERR(sc)
		If ..separator="line" Do XSL2.WriteLine(" <br/>")		
		If child.%IsA("%ZEN.Report.Display.item"),child.suppressEmpty {
			Do XSL2.WriteLine("</xsl:if>")
		}

		Set i= ..children.Next(i)
	}
	Do XSL2.Rewind(),delay2.Rewind()
	Do XSL.WriteLine("<!-- group match name="_..qualify(..name)_" -->")
	Do delay.WriteLine("<xsl:template match='"_..qualify(..name)_"' mode='"_mode_"'>")
	Do ..%DeclareLevelParameters(.context,.delay,.delay2)
	Do delay.WriteLine("<xsl:param name='prevmatch' select='position()'/>") //JSL4323
	if ..smallMultiple {
		Do delay.WriteLine("<zr:small-multiple>")
	}
	Do:line delay.WriteLine("<br/><div style='border-top:"_..line_" solid black'/>")
	//Do delay.WriteLine(XSL2.Read())
	Do delay.CopyFrom(XSL2)
	If pagebreak {
		Do delay.WriteLine("<xsl:if test='position() != last()'>")
		Do delay.WriteLine("<div style='page-break-after:always'>")
		Do delay.WriteLine("<br style='height:0; line-height:0'/>")
		Do delay.WriteLine("</div>")
		Do delay.WriteLine("</xsl:if>")
	}
	if ..smallMultiple {
		Do delay.WriteLine("</zr:small-multiple>")
	}
	Do delay.WriteLine("</xsl:template>")
	Do delay.CopyFrom(delay2)
	do ..%EndLevel(.context,.XSL,.delay)
	d ..%EndDrawHtml(.context,.XSL,.delay)	
	Quit sc
}

Method %xDrawToAnnotatedXML(ByRef context As %String, ByRef XSL As %GlobalCharacterStream, delay As %GlobalCharacterStream) As %Status
{
	// JSL4311 deactivate this method callback, use default in node
	Set sc=$$$OK
	$$$groupNumInc
	Set mode = "group"_$$$groupNum
	
	d ..%IncLevel(.context, .XSL, .delay)
	d ..tagChildren()
	d ..%BeginDrawHtml(.context,.XSL,.delay)	
	Do XSL.WriteLine("<!-- group name="_..qualify(..name)_" -->")
	Do XSL.WriteLine("<xsl:element name='"_..qualify(..name)_"'>")
	Do XSL.WriteLine("<xsl:apply-templates select='"_..qualify(..name)_"' mode='"_mode_"' >")
	Do ..%DrawSort(.context,.XSL,.delay,..orderby)
	Do ..%ApplyLevelParameters(.context,.XSL,.delay)
	Do XSL.WriteLine("<xsl:with-param  name='prevmatch' select='position()'/>")	
	Do XSL.WriteLine("</xsl:apply-templates>")
	Do XSL.WriteLine("</xsl:element>")
	Set XSL2=##class(%GlobalCharacterStream).%New()
	Set delay2=##class(%GlobalCharacterStream).%New()
	Set i = ..children.Next("")
	While (i'="") {
		Set child = ..children.GetAt(i)
		d ..updateFromTemplate(.child)		
		Set child.parent=$$$THIS
		Set child.xpath=..parent.xpath_"/"_..name
		Set:child.class="" child.class=..class
		Set sc = child.%DrawToAnnotatedXML(.context,.XSL2,.delay2) 
		Quit:$$$ISERR(sc)
		Set i= ..children.Next(i)
	}
	Do XSL2.Rewind(),delay2.Rewind()
	Do XSL.WriteLine("<!-- group match name="_..qualify(..name)_" -->")
	Do delay.WriteLine("<xsl:template match='"_..qualify(..name)_"' mode='"_mode_"'>")
	Do ..%DeclareLevelParameters(.context,.delay,.delay2)
	Do delay.WriteLine("<xsl:param name='prevmatch' select='position()'/>") //JSL4323	
	//Do delay.WriteLine(XSL2.Read())
	Do delay.CopyFrom(XSL2)
	Do delay.WriteLine("</xsl:template>")
	Do delay.CopyFrom(delay2)
	do ..%EndLevel(.context,.XSL,.delay)
	d ..%EndDrawHtml(.context,.XSL,.delay)	
	Quit sc
}

}
