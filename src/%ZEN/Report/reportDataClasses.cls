Class %ZEN.Report.reportDataClasses Extends %RegisteredObject [ System = 4 ]
{

/// package.classname for ZEN Report
Property ZenReport As %String;

/// package where data classes generated by generateDataClasses will be stored
Property DataPackage As %String;

/// package where generated Web Service will be generated
Property WebServicePackage As %String;

/// SOAP Namespace for the WebService
Property Namespace As %String [ InitialExpression = "http://tempuri.org" ];

/// Namespaces of referenced classes will be used in the WSDL.
Property UseClassNamespaces As %Boolean [ InitialExpression = 1 ];

/// internal properties
Property ZenReportName As %String [ Internal ];

Method generateWebService() As %Status
{
	Set Status=$$$OK
	do {
		Set Status=..generateDataClasses()
		if $$$ISERR(Status) quit
		Set Status=..generateWebServiceShell(..ZenReportName)
	} while 0
	q Status
}

Method generateWebServiceShell(pReportName As %String)
{
	 	Set Status=$$$OK
	 	Set className=..WebServicePackage_"."_pReportName
	 	do {
			Set classdef=##class(%Dictionary.ClassDefinition).%OpenId(className)
			if classdef'="" {
				write !,"Deleting"_className
				Set Status=##class(%Dictionary.ClassDefinition).%DeleteId(className)
				if $$$ISERR(Status) Quit
			} 
			Set classdef=##class(%Dictionary.ClassDefinition).%New(className)
			Set classdef.Super="%SOAP.WebService"
			Set classdef.ProcedureBlock=1
			Set Status=..SaveClass(classdef)
			if $$$ISERR(Status) Quit
			set Status=..CreateParameter(className,"SERVICENAME",pReportName)
			if $$$ISERR(Status) q
			set Status=..CreateParameter(className,"NAMESPACE",..Namespace)
			if $$$ISERR(Status) q
			set Status=..CreateParameter(className,"USECLASSNAMESPACES",..UseClassNamespaces)
			if $$$ISERR(Status) q
			Set Status=..SaveAndCompileClass(classdef)
			if $$$ISERR(Status) Quit
			#dim Method as %Dictionary.MethodDefinition
			set Method=##class(%Dictionary.MethodDefinition).%New(className_":Get"_pReportName)
			set Method.ClassMethod=0
			set Method.ReturnType = ..DataPackage_"."_pReportName			
			set Method.WebMethod=1
			#dim stream As %Stream.TmpCharacter;
			Set stream = Method.Implementation
			Do stream.WriteLine(" Set report=##class("_..ZenReport_").%New()")
			Do stream.WriteLine(" Set tmpdir=##class(%File).NormalizeDirectory(^%SYS(""TempDir""))")
			Do stream.WriteLine(" Set filename = tmpdir_##class(%FileBinaryStream).NewFileName(""xml"",^%SYS(""TempDir""))")
			Do stream.WriteLine(" Set status = report.GenerateReport(filename,0)")
			Do stream.WriteLine(" If $system.Status.IsError(status) do $System.Status.DisplayError(status)")
 			Do stream.WriteLine(" // Create an instance of %XML.Reader")
    		Do stream.WriteLine(" Set reader = ##class(%XML.Reader).%New()")
			Do stream.WriteLine(" ")
    		Do stream.WriteLine(" // Begin processing of the file")
    		Do stream.WriteLine(" Set status = reader.OpenFile(filename)")
    		Do stream.WriteLine(" If $system.Status.IsError(status) do $System.Status.DisplayError(status)")
			Do stream.WriteLine(" ")
    		Do stream.WriteLine(" // Associate a class name with the XML element name")
    		Do stream.WriteLine(" Do reader.Correlate("""_pReportName_""","""_..DataPackage_"."_pReportName_""")")
    		Do stream.WriteLine(" ")
    		Do stream.WriteLine(" // Read objects from xml file")
			Do stream.WriteLine("  Set object=""""")
    		Do stream.WriteLine(" While (reader.Next(.object,.status)) {")
    		Do stream.WriteLine("     Quit ; only one object in ZEN Report")
    		Do stream.WriteLine(" }")
    		Do stream.WriteLine(" ")
    		Do stream.WriteLine(" // If error found during processing, show it")
    		Do stream.WriteLine(" If $system.Status.IsError(status) do $System.Status.DisplayError(status)")
			Do stream.WriteLine(" quit object")
			Set Status=Method.%Save()
			if $$$ISERR(Status) q
	} while (0) 
	Set Status=..SaveAndCompileClass(classdef)
	quit Status
}

/// generate data classes that correspond to the ZEN Report's exported string
Method generateDataClasses() As %Status
{
	 #dim tCompiledClass as %Dictionary.CompiledClass
	set tCompiledClass = ##class(%Dictionary.CompiledClass).IDKEYOpen(..ZenReport,,.tSC)
	if $isobject(tCompiledClass) {
		if (tCompiledClass.Abstract) {
			Quit $$$OK
		}
 
			#; find XDATA block named ReportDefinition
		; set tIndex = tCompiledClass.XDatas.FindObjectId(%class.Name_"||ReportDefinition")
		if ##class(%Dictionary.CompiledXData).IDKEYExists(tCompiledClass.Name,"ReportDefinition",.tReportDefId) {
			#; get XDATA as stream
			Set tXData = ##class(%Dictionary.CompiledXData).%OpenId(tReportDefId,,.tSC)
				#; ignore tSC for now, if the open failed it is because the compiled class is corrupt
			Do tXData.Data.Rewind()
	
			If (tXData.Data.Size > 0) {
	
				#; render the stream into report object (with children)
				Set tReader = ##class(%XML.Reader).%New()
				Set tSC = tReader.OpenStream(tXData.Data) If $$$ISERR(tSC) Quit tSC
				Do tReader.Correlate("report","%ZEN.Report.report")
	
				#; there should only be one report defined
				Do tReader.Next(.tReport,.tSC)
				If $$$ISERR(tSC) Quit tSC
				If '$IsObject(tReport) Quit $$$ERROR($$$GeneralError,"No <report> element defined in ReportDefinition block.")
				Set ..ZenReportName=tReport.name
				set tSC = ..writeDataClasses(tCompiledClass,tReport)
			}
		}
		Else {
			#; if XData did not create a report, return an error.
			set tSC = $$$ERROR($$$GeneralError,"No ReportDefinition block defined in "_pClassName_".")
		}
	}
	quit tSC
}

ClassMethod CreateParameter(className As %String, Name As %String, Default As %String) As %Status [ Internal ]
{
	s Status=$$$OK
	do {
		Set parameter=##class(%Dictionary.ParameterDefinition).%New(className_":"_Name)
		Set parameter.Default=Default
		Set Status=parameter.%Save()
	} while (0)
	q Status
}

Method writeDataClasses(pCompiledClass As %Dictionary.CompiledClass, pReport As %ZEN.Report.report) As %Status [ Internal ]
{
	do {
		set className=..DataPackage_"."_pReport.name
		Set Status=..CreateAdapterClass(className,.classdef)
		if '$$$ISOK(Status) quit
		Set Status=..SaveAndCompileClass(classdef)
		if '$$$ISOK(Status) quit
		if ##class(%Dictionary.CompiledParameter).IDKEYExists(pCompiledClass.Name,"REPORTXMLNAMESPACE",.tParameter) {
			set tReportNamespace = ##class(%Dictionary.CompiledParameter).%OpenId(tParameter).Default
		}
		else { set tReportNamespace = "" }
		If tReportNamespace'="" {
			set Status=..CreateParameter(className,"NAMESPACE",tReportNamespace)
			if '$$$ISOK(Status) quit
		} Else {
	
		}
		Set Status=..CreateParameter(className,"XMLNAME",pReport.name)
		if '$$$ISOK(Status) quit
		Set Status=..CreateParameter(className,"XMLSEQUENCE",1)
		if '$$$ISOK(Status) quit
		set tCount = pReport.children.Count()
		for tPtr = 1:1:tCount {
			set tNode = pReport.children.GetAt(tPtr)
			if (tNode.%IsA("%ZEN.Report.element")) {
					#; May seem foolish to do this inside the loop but eventually we will use metadata to retrieve the node type. Default to %String for now.
				Set sequenceNumber=$i(sequenceNumber)
				Set Status=..CreateProperty(classdef,tNode.name,"ELEMENT",sequenceNumber)

			} elseif (tNode.%IsA("%ZEN.Report.attribute")) {
			}
			else {
				if tNode.%IsA("%ZEN.Report.group") {
					set tGroup($increment(tGroup)) = tNode
					Set sequenceNumber=$i(sequenceNumber)
					Set Status=..CreateChildProperty(classdef,pReport.name,tNode.name,..DataPackage,sequenceNumber)
					If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)
				}
			}
		}
	 	#; aggregates must come after elements since they follow them in XML
		for tPtr = 1:1:tCount {
			set tNode = pReport.children.GetAt(tPtr)
			if (tNode.%IsA("%ZEN.Report.aggregate")) {
					#; May seem foolish to do this inside the loop but eventually we will use metadata to retrieve the node type. Default to %String for now.
				Set sequenceNumber=$i(sequenceNumber)
				Set Status=..CreateProperty(classdef,tNode.name,"ELEMENT",sequenceNumber)
			}
		}

		for tPtr = 1:1:tCount {
			set tNode = pReport.children.GetAt(tPtr)
			if (tNode.%IsA("%ZEN.Report.attribute")) {
				Set sequenceNumber=$i(sequenceNumber)
				Set Status=..CreateProperty(classdef,tNode.name,"ATTRIBUTE",sequenceNumber)
			}
		}

		for tPtr=1:1:tGroup {
			Do ..writeGroupDataClasses(pReport.name,tGroup(tPtr))
		}
		Set Status=..SaveClass(classdef)
		if '$$$ISOK(Status) quit
		Set Status=..CompileClass(classdef)
	} while (0)
	If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)
	Quit Status
}

Method writeGroupDataClasses(parentName As %String, pGroup As %ZEN.Report.group) As %Status [ Internal ]
{
	do {
		set className=..DataPackage_"."_pGroup.name
		Set Status=..CreateAdapterClass(className,.classdef)
		If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)
		Set Status=..SaveAndCompileClass(classdef)
		If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)
		Set Status=..CreateParameter(className,"XMLNAME",pGroup.name)
		Set Status=..CreateParameter(className,"XMLSEQUENCE",1)
	
		set tCount = pGroup.children.Count()
		Set tPtr=0
		set tGroup=0
		for tPtr = 1:1:tCount {
			set tNode = pGroup.children.GetAt(tPtr)
			if (tNode.%IsA("%ZEN.Report.element")) {
				#; May seem foolish to do this inside the loop but eventually we will use metadata to retrieve the node type. Default to %String for now.
				Set sequenceNumber=$i(sequenceNumber)
				Set Status=..CreateProperty(classdef,tNode.name,"ELEMENT",sequenceNumber)
			} elseif (tNode.%IsA("%ZEN.Report.attribute")) {
			}
			else {
				if tNode.%IsA("%ZEN.Report.group") {
					set tGroup($increment(tGroup)) = tNode
					Set sequenceNumber=$i(sequenceNumber)
					Set Status=..CreateChildProperty(classdef,pGroup.name,tNode.name,..DataPackage,sequenceNumber)
					If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)
				}
			}
		}
		#; aggregates must come after elements since they follow them in XML
		for tPtr = 1:1:tCount {
			set tNode = pGroup.children.GetAt(tPtr)
			if (tNode.%IsA("%ZEN.Report.aggregate")) {
					#; May seem foolish to do this inside the loop but eventually we will use metadata to retrieve the node type. Default to %String for now.
				Set sequenceNumber=$i(sequenceNumber)
				Set Status=..CreateProperty(classdef,tNode.name,"ELEMENT",sequenceNumber)
			}
		}
	
		for tPtr = 1:1:tCount {
			set tNode = pGroup.children.GetAt(tPtr)
			if (tNode.%IsA("%ZEN.Report.attribute")) {
				Set sequenceNumber=$i(sequenceNumber)
				Set Status=..CreateProperty(classdef,tNode.name,"ATTRIBUTE",sequenceNumber)
			}
		}

		Set sequenceNumber=$i(sequenceNumber)
		Set Status=..CreateParentProperty(classdef,parentName,pGroup.name,..DataPackage,sequenceNumber)
		If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)

		for tPtr=1:1:tGroup {
			Set Status=..writeGroupDataClasses(pGroup.name,tGroup(tPtr))
			if '$$$ISOK(Status) quit
		}
		if '$$$ISOK(Status) quit
		Set Status=..SaveClass(classdef)
		if '$$$ISOK(Status) quit
		Set Status=..CompileClass(classdef)
	} while(0)
	If $system.Status.IsError(Status) do $System.Status.DisplayError(Status)
	quit Status
}

ClassMethod CreateChildProperty(classdef As %Dictionary.ClassDefinition, parentName As %String, childName As %String, pkg As %String, sequenceNumber As %Integer) [ Internal ]
{
	s Status=$$$OK
	do {
		
		Set property=##class(%Dictionary.PropertyDefinition).%New()
		Set property.Name=childName
		Set property.Cardinality="many"
		Set property.Inverse=parentName
		Set property.Type=pkg_"."_childName
		Set property.Relationship=1
		set property.SequenceNumber=sequenceNumber
		if ..IsSQLWord(property.Name) set property.SqlFieldName="_"_property.Name
		Set Status=property.Parameters.SetAt("ELEMENT","XMLPROJECTION")
		Set Status=property.Parameters.SetAt(childName,"XMLNAME")
		If $$$ISERR(Status) q 
		Set Status=classdef.Properties.Insert(property)
		If $$$ISERR(Status) q 		
		set Status=..SaveAndCompileClass(classdef)
	} while (0)
	q Status
}

ClassMethod CreateProperty(classdef As %Dictionary.ClassDefinition, propName As %String, xmlProjection As %String, sequenceNumber As %Integer) [ Internal ]
{
	s Status=$$$OK
	do {
		Set property=##class(%Dictionary.PropertyDefinition).%New()
		Set property.Name=##class(%SOAP.WebBase).NormalizeName(propName)
		Set property.SequenceNumber=sequenceNumber
		if ..IsSQLWord(property.Name) set property.SqlFieldName="_"_property.Name
		Set property.Type="%String"
		Set Status=property.Parameters.SetAt("","MAXLEN")
		Set Status=property.Parameters.SetAt(xmlProjection,"XMLPROJECTION")
		If $$$ISERR(Status) q 
		Set Status=property.Parameters.SetAt(propName,"XMLNAME")
		If $$$ISERR(Status) q 
		Set Status=classdef.Properties.Insert(property)
		If $$$ISERR(Status) q 		

	} while (0)
	q Status
}

ClassMethod CreateParentProperty(classdef As %Dictionary.ClassDefinition, parentName As %String, childName As %String, pkg As %String, sequenceNumber As %Integer) [ Internal ]
{
	s Status=$$$OK
	do {
		Set property=##class(%Dictionary.PropertyDefinition).%New()
		Set property.Name=parentName
		Set property.SequenceNumber=sequenceNumber
		if ..IsSQLWord(property.Name) set property.SqlFieldName="_"_property.Name		
		Set property.Cardinality="one"
		Set property.Inverse=childName
		Set property.Type=pkg_"."_parentName
		Set property.Relationship=1
		Set Status=property.Parameters.SetAt("NONE","XMLPROJECTION")
		If $$$ISERR(Status) q 
		Set Status=classdef.Properties.Insert(property)
		If $$$ISERR(Status) q 		
		set Status=..SaveAndCompileClass(classdef)
	} while (0)
	q Status
}

Method CreateAdapterClass(className As %String, ByRef classdef As %Dictionary.ClassDefinition) As %Status
{
	 	Set Status=$$$OK
	 	do {
			Set classdef=##class(%Dictionary.ClassDefinition).%OpenId(className)
			if classdef'="" {
				write !,"Deleting"_className
				Set Status=##class(%Dictionary.ClassDefinition).%DeleteId(className)
				if $$$ISERR(Status) Quit
			} 
			Set classdef=##class(%Dictionary.ClassDefinition).%New(className)
			Set classdef.Super="%Persistent,%XML.Adaptor"
			Set classdef.ClassType = "persistent"
			Set classdef.ProcedureBlock=1
	 	} while (0) 
		quit Status
}

ClassMethod SaveClass(classdef As %Dictionary.ClassDefinition) As %Status [ Internal ]
{
	do {
		Set Status=classdef.%Save()
		If $$$ISERR(Status) quit 
	} while (0)
	quit Status
}

ClassMethod CompileClass(classdef As %Dictionary.ClassDefinition) As %Status [ Internal ]
{
	do {
		Set Status=##class(%SYSTEM.OBJ).Compile(classdef.Name,"k")	
		If $$$ISERR(Status) quit 
	} while (0)
	quit Status
}

ClassMethod SaveAndCompileClass(classdef As %Dictionary.ClassDefinition) As %Status [ Internal ]
{
	do {
		Set Status=classdef.%Save()
		If $$$ISERR(Status) quit 
		Set Status=##class(%SYSTEM.OBJ).Compile(classdef.Name,"k")	
		If $$$ISERR(Status) quit 
	} while (0)
	quit Status
}

ClassMethod IsSQLWord(name As %String) As %Boolean [ Internal ]
{
	If (name = "") {
		Quit ""
	}
	
	// check SQL meta info
	Quit $System.SQL.IsReservedWord(name)
}

}
