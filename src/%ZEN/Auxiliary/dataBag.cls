/// 
/// This class provides a way to assemble data that can be
/// 
/// conveniently passed between the web client and the server.
/// 
/// A <class>dataBag</class> object contains a set of name-value pairs.
/// 
/// This is used internally by the MVC classes.
Class %ZEN.Auxiliary.dataBag Extends %ZEN.Component.object [ System = 3 ]
{

/// 
/// List of property names contained within this dataBag.
Property propertyList As %ZEN.Datatype.csv(XMLPROJECTION = "NONE") [ Private ];

/// 
/// List of property labels (if different than property name) contained within this dataBag.
Property labelList As %ZEN.Datatype.csv(XMLPROJECTION = "NONE") [ Private ];

/// 
/// List of types of the properties contained within this dataBag.
Property propertyTypes As %ZEN.Datatype.csv(XMLPROJECTION = "NONE") [ Private ];

/// 
/// Array of data values within the dataBag, indexed by series and property name.
Property %data As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional ];

/// 
/// Array of data types within the dataBag, indexed by property name.
Property %types As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional ];

/// 
/// Array of labels within the dataBag, indexed by property name.
Property %labels As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional ];

/// 
/// Array of serialized data values going to and coming from the client.
Property clientData As %ZEN.Datatype.list(XMLPROJECTION = "NONE", ZENSETTING = 0);

/// 
/// Number of data series held within the dataBag.
Property seriesCount As %ZEN.Datatype.integer(MINVAL = 1, XMLPROJECTION = "NONE", ZENSETTING = 0) [ InitialExpression = 1 ];

/// 
/// List of data series names contained within this dataBag.
Property seriesNames As %ZEN.Datatype.csv(XMLPROJECTION = "NONE") [ Private ];

/// 
/// Set the property list for the dataBag.
/// 
/// This deletes the contents of the dataBag.
Method %SetPropertyList(pPropList As %String, pPropTypes As %String = "", pLabelList As %String = "") [ Internal ]
{

	Do ..%Clear()

	Set ..propertyList = pPropList

	Set ..propertyTypes = pPropTypes

	Set ..labelList = pLabelList
}

/// 
/// Internal method.
Method %GetPropertyList() As %String [ CodeMode = expression, Internal ]
{
..propertyList
}

/// 
/// Internal method.
Method %GetPropertyTypes() As %String [ CodeMode = expression, Internal ]
{
..propertyTypes
}

/// 
/// Internal method.
Method %GetLabelList() As %String [ CodeMode = expression, Internal ]
{
..labelList
}

/// 
/// Delete data currently in the dataBag.
Method %Clear()
{
	Kill ..%data,..%types,..%labels
}

/// 
/// Get the value of a property within the dataBag.<br>
/// 
/// Note that this can return a literal value,
/// 
/// an object value (oref), or $$$ZENMISSING if the given
/// 
/// property is not in the model.
Method %GetValue(pProperty As %String, pSeries As %Integer = 1) As %String [ CodeMode = expression ]
{
$S(pProperty'="":$G(..%data(pSeries,pProperty),$$$ZENMISSING),1:"")
}

/// 
/// Get the type of a property within the dataBag.<br>
Method %GetType(pProperty As %String) As %String [ CodeMode = expression ]
{
$S(pProperty'="":$G(..%types(pProperty)),1:"")
}

/// 
/// Get the label for a property within the dataBag.<br>
Method %GetLabel(pProperty As %String) As %String [ CodeMode = expression ]
{
$S(pProperty'="":$G(..%labels(pProperty),pProperty),1:"")
}

/// 
/// Set the value of a property within the dataBag.
Method %SetValue(pProperty As %String, pValue As %String)
{

	#; force client change

	Do ..%ForceClientRender()

	Set:pProperty'="" ..%data(1,pProperty) = pValue
}

/// 
/// Copy the contents of this dataBag into a local array.
Method %GetArray(Output pArray)
{

	Kill pArray

	Merge pArray = ..%data
}

/// 
/// Fill the contents of this dataBag from the given DataModel
Method %CopyFromModel(pModel As %ZEN.DataModel.DataModel) As %Status
{

	Set tSC = $$$OK

	Set $ZT = "Trap"



	Do {

		Set tSC = $zobjmethod(pModel,"%CopyDataFromModel",.tData)

		If $$$ISERR(tSC) Quit



		#; get series info

		Set ..seriesCount = pModel.%seriesCount

		

		Set tNames = ""

		Set n = $O(pModel.%seriesNames(""))

		While (n '= "") {

			Set tNames = tNames _ $S(tNames="":"",1:",") _ $TR($G(pModel.%seriesNames(n)),","," ")

			Set n = $O(pModel.%seriesNames(n))

		}

		Set ..seriesNames = tNames



		#; copy data into bag

		Kill ..%data

		Merge ..%data = tData

	} While(0)

Done

	Quit tSC

Trap

	Set $ZT=""

	Set tSC = $$$ERROR($$$CacheError,"%CopyFromModel: " _ $ZE)

	Goto Done
}

/// 
/// Copy the contents of this dataBag into the given DataModel.
Method %CopyToModel(pModel As %ZEN.DataModel.DataModel) As %Status
{

	Set tSC = $$$OK

	Set $ZT = "Trap"

	Do {

		Set pModel.%seriesCount=..seriesCount

		For sno=1:1:..seriesCount {

			Set pModel.%seriesNames(sno)=$Piece(..seriesNames,",",sno)	

		}

		Merge tData = ..%data

		Set tSC = $zobjmethod(pModel,"%CopyDataToModel",.tData)

		If $$$ISERR(tSC) Quit

	} While(0)

Done

	Quit tSC

Trap

	Set $ZT=""

	Set tSC = $$$ERROR($$$CacheError,"%CopyToModel: " _ $ZE)

	Goto Done
}

/// 
/// Make sure client data is prepared.
Method %OnObjectSynch() As %Status
{
	Quit ..%SerializeData()
}

/// 
/// Deserialize additional values from the client.
Method %OnZENDeserialize() As %Status
{

	Set tSC = $$$OK

	Set $ZT = "Trap"



	#; convert client properties to server representation

	#; using meta-data within propertyList

	If (..propertyList '= "") {

		For n = 1:1:$L(..propertyList,",") {

			Set tProp = $P(..propertyList,",",n)

			Set tType = $P(..propertyTypes,",",n)

			Set tLabel = $P(..labelList,",",n)

			Set:tType'="" ..%types(tProp) = tType

			Set:tLabel'="" ..%labels(tProp) = tLabel

		}

	}



	#; data for all series are concatenated into one list

	If (..propertyList '= "") {

		Set tPropCount = $L(..propertyList,",")

		For s = 1:1:..seriesCount {

			Set tOff = (s-1) * tPropCount

			For n = 1:1:tPropCount {

				Set tProp = $P(..propertyList,",",n)

				Set ..%data(s,tProp) = $P(..clientData,$C(5),tOff + n)

			}

		}

	}

Done

	Quit tSC

Trap

	Set $ZT=""

	Set tSC = $$$ERROR($$$CacheError,"%OnZENDeserialize: " _ $ZE)

	Goto Done
}

/// 
/// Called just before we serve property values to the client.
Method %OnDrawObjectProperties() As %Status
{

	#; convert data to serialized array for client

	Quit ..%SerializeData()
}

/// 
/// Convert internal arrays to a serialized strings for use on the client.
Method %SerializeData(pDelim As %String = {$C(5)}) As %Status
{

	Set tSC = $$$OK

	Set $ZT = "Trap"



	#; put values in the order they appear in the list of properties.

	Set tData = ""

	Set tOff = 0

	Set tCount = 0

	For s = 1:1:..seriesCount {

		If (..propertyList '= "") {

			For n = 1:1:$L(..propertyList,",") {

				Set tProp = $P(..propertyList,",",n)

				Set tType = $P(..propertyTypes,",",n)

				Set tLabel = $P(..labelList,",",n)

				Set tValue = $G(..%data(s,tProp))

				If (tValue = $$$ZENMISSING) {

					Set tValue = ""

				}

				Set tData = tData_$S((tOff+n)=1:"",1:pDelim)_tValue

				Set tCount = tCount + 1

			}

		}

		Set tOff = tOff + ..seriesCount

	}



	If ((tData="")&&(tCount>0)) {

		// make sure we don't serialize single "" to null

		Set tData = pDelim

	}



	Set ..clientData = tData

Done

	Quit tSC

Trap

	Set $ZT=""

	Set tSC = $$$ERROR($$$CacheError,"%SerializeData: " _ $ZE)

	Goto Done
}

/// 
/// Clear contents of this dataBag.
ClientMethod clear() [ Language = javascript ]
{

	for (var n = 0; n < this.clientData.length; n++) {

		this.clientData[n] = '';

	}
}

/// 
/// Return the data value associated with a given property name.
/// 
/// If there is no property with the name, <var>property</var>, return null.
ClientMethod getValue(property, series) [ Language = javascript ]
{

	series = (null == series) ? 0 : series;

	var data = null;

	var index = this.getPropertyIndex(property);

	if (index>=0) {

		var idx = index + (series * this.getPropertyCount());

		data = this.clientData[idx];

	}

	return data;
}

/// 
/// Return the data value at the given ordinal position.
/// 
/// If <var>n</var> is out of range, return null.<br>
/// 
/// <var>series</var> is 0-based.
ClientMethod getValueByPosition(n, series) [ Language = javascript ]
{

	series = (null == series) ? 0 : series;

	var idx = n + (series * this.getPropertyCount());

	return this.clientData[idx];
}

/// 
/// This is a specialized variant of <method>getValueByPosition</method> that
/// 
/// return the data in this bag as an array of arrays (used
/// 
/// by charts).
ClientMethod getValuesAsArrays() [ Language = javascript ]
{

	var data = new Array(this.seriesCount);

	var pc = this.getPropertyCount();

	var idx = 0;

	for (var i = 0; i < this.seriesCount; i++) {

		data[i] = new Array(pc);

		for (var j = 0; j < pc; j++) {

			data[i][j] = this.clientData[idx++];

		}

	}

	return data;
}

/// 
/// Return the values in this dataBag as a zenProxy object.
/// 
/// If there is more than one data series, <var>series</var>
/// 
/// specifies which one to use.<br/>
/// 
/// Return null if there are no properties in the dataBag.
ClientMethod getValuesAsObject(series) [ Language = javascript ]
{

	if (''==this.propertyList) { return null; }

	var obj = new zenProxy();

	var props = this.propertyList.split(',');

	for (var n = 0; n < props.length; n++) {

		if (props[n] && props[n]!='') {

			var prop = props[n].split(':')[0];

			obj[prop] = this.getValue(prop, series);

		}

	}

	return obj;
}

/// 
/// Internal method.<br>
/// 
/// Find index number of given property name.
ClientMethod getPropertyIndex(property) [ Internal, Language = javascript ]
{

	if (''==this.propertyList || ''==property) { return -1; }



	if (null == this._propertyIndex) {

		// build index

		this._propertyIndex = new Object();

		var props = this.propertyList.split(',');

		for (var n=0; n < props.length; n++) {

			this._propertyIndex[props[n].split(':')[0]] = n;

		}

	}



	return this._propertyIndex[property];
}

/// 
/// Set the data value for the given property.<br>
/// 
/// <var>series</var> is 0-based.
ClientMethod setValue(property, value, series) [ Language = javascript ]
{

	// find index of property within list

	var index = this.getPropertyIndex(property);

	if (index>=0) {

		series = (null == series) ? 0 : series;

		this.clientData[index + (series * this.getPropertyCount())] = value;

	}
}

/// 
/// Set the data value at the given ordinal position.<br>
/// 
/// <var>series</var> is 0-based.
ClientMethod setValueByPosition(value, n, series) [ Language = javascript ]
{

	if (n>=0) {

		series = (null == series) ? 0 : series;

		var idx = n + (series * this.getPropertyCount());

		this.clientData[idx] = value;

	}
}

/// 
/// dataSet API
/// 
/// Return the number of items in the specified dimension.<br>
/// 
/// (<var>dim</var> is 1,2, or 3).
/// 
/// The size of the first dimension is defined by the number of properties in the dataBag.<br>
/// 
/// The size of the second dimension is defined by number of data series in the dataBag.
/// 
/// The dataBag does not support a third dimension.
ClientMethod getDimSize(dim) [ Language = javascript ]
{

	switch(dim) {

	case 1:

		return this.getPropertyCount();

	case 2:

		return this.getSeriesCount();

	}

	return 0;
}

/// 
/// Return the number of data series within this dataBag.
ClientMethod getSeriesCount() [ Language = javascript ]
{
	return this.seriesCount;
}

/// 
/// Return the number of properties within this dataBag.
ClientMethod getPropertyCount() [ Language = javascript ]
{
	// WAL072 -- don't divide by 0
	return ((this.clientData) && (this.seriesCount != 0)) ? (Math.floor(this.clientData.length / this.seriesCount)) : 0;
}

/// 
/// Return the name of a property within this dataBag given its ordinal
/// 
/// (0-based) position.
ClientMethod getPropertyName(n) [ Language = javascript ]
{

	if (''==this.propertyList) { return ''; }

	var props = this.propertyList.split(',');

	return (null == props[n]) ? '' : props[n].split(':')[0];
}

/// 
/// Return the type code of a property within this dataBag given its ordinal
/// 
/// (0-based) position.
ClientMethod getPropertyType(n) [ Language = javascript ]
{

	if ('' == this.propertyTypes) { return ''; }

	var props = this.propertyTypes.split(',');

	return (null == props[n]) ? '' : props[n].split(':')[0];
}

/// 
/// Return the label of a property within this dataBag given its ordinal
/// 
/// (0-based) position.
ClientMethod getPropertyLabel(n) [ Language = javascript ]
{

	if ('' == this.labelList) { return ''; }

	var labels = this.labelList.split(',');

	var lbl = (null == labels[n]) ? '' : labels[n].split(':')[0];

	return ('' == lbl) ? this.getPropertyName(n) : lbl;
}

/// 
/// Return the label of a dataSeries within this dataBag given its ordinal
/// 
/// (0-based) position.
ClientMethod getSeriesLabel(n) [ Language = javascript ]
{

	if ('' == this.seriesNames) { return ('Series ' + (n+1)); }

	var labels = this.seriesNames.split(',');

	var lbl = (null == labels[n]) ? '' : labels[n].split(':')[0];

	return ('' == lbl) ? ('Series ' + (n+1)) : lbl;
}

/// 
/// Set the value of a named property.
ClientMethod setProperty(property, value, value2) [ Language = javascript ]
{

	switch(property) {

	case 'propertyList':

		if (this._propertyIndex) {

			delete this._propertyIndex;

		}

		this.propertyList = value;

		break;

	case 'propertyTypes':

		this.propertyTypes = value;

		break;

	default:

		// dispatch

		return this.invokeSuper('setProperty',arguments);

	}

	return true;
}

}
