Include (%occInclude, %occUtility, %DeepSee)

/// %DeepSee.WizardUtils implements utility methods used by various DeepSee Wizards.
Class %DeepSee.WizardUtils [ Abstract, System = 4 ]
{

/// Generate a DeepSee Cube definition class from a compiled persistent class.
/// <br>
/// <table border=1>
/// <tr><td>pSourceClass</td><td>The name of the class from which a cube definition is to be generated.</td></tr>
/// <tr><td>pCubeName</td><td>The name of the cube to be generated.</td></tr>
/// <tr><td>pCubeClass</td><td>The name of the cube definition class to be generated.</td></tr>
/// <tr><td>pAutoDelete</td><td>If passed as a non-zero value then the generator will automatically delete the cube definition class if it already exists.</td></tr>
/// </table>
/// </p>
/// <p>
/// This method returns a status value indicating success or failure. If this method fails then the cube class definition is not created.
/// </p>
ClassMethod %GenerateCubeDefinition(pSourceClass As %Library.String(MAXLEN="") = "", pCubeName As %Library.String(MAXLEN=""), pCubeClass As %Library.String(MAXLEN="") = "", pAutoDelete As %Library.Integer = 0)
{
	set tCurrentRoles=$Roles
	$$$AddAllRoleTemporary
	try {
		set tflag = 0
		set tSourceClass = ##class(%Dictionary.CompiledClass).%OpenId(pSourceClass,3)
		if '$Isobject(tSourceClass) { throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$ClassDoesNotExist,pSourceClass)) }
		if ($tlevel) && ('$$$TransSuspended) { $$$SuspendTrans set tflag=1 }
		set tClass = ##class(%Dictionary.ClassDefinition).%OpenId(pCubeClass)
		if $Isobject(tClass) {
			if 'pAutoDelete { set tClass = "" throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError,"Class name, '"_pCubeClass_"' already exists")) }
			else {
				set tStatus = $system.OBJ.Delete(pCubeClass,"-D")
				if $$$ISERR(tStatus) { throw ##class(%Exception.StatusException).CreateFromStatus(tStatus) }
			}
		}
		set tClass = ##class(%Dictionary.ClassDefinition).%New()
		set tClass.Name = pCubeClass
			// Establish the class
		set tStatus = tClass.%Save()
		if $$$ISERR(tStatus) { throw ##class(%Exception.StatusException).CreateFromStatus(tStatus) }
		set tClass = ##class(%Dictionary.ClassDefinition).%OpenId(pCubeClass,4,.tStatus)
		if $$$ISERR(tStatus) { throw ##class(%Exception.StatusException).CreateFromStatus(tStatus) }
			// And continue with the work
			// Set up the basic class keywords
		set tClass.ProcedureBlock = 1
		set tClass.Super = "%DeepSee.CubeDefinition"
		set tClass.DependsOn = pSourceClass
		set tSequence = 0
			// Set up the Cube Definition here as XDATA
		set tCubeDef = ##class(%Dictionary.XDataDefinition).%New()
		set tCubeDef.parent = tClass
		set tCubeDef.Name = "Cube"
		set tCubeDef.XMLNamespace = "http://www.intersystems.com/deepsee"
		do tCubeDef.Data.WriteLine("<cube name=""" _ pCubeName _ """")
		do tCubeDef.Data.WriteLine("caption=""" _ pCubeName _"- Generated by Utility""")
		do tCubeDef.Data.WriteLine("description=""Generated by Utility""")
		do tCubeDef.Data.WriteLine("defaultListing=""Listing""")
		do tCubeDef.Data.WriteLine("nullReplacement=""Missing Value""")
		do tCubeDef.Data.WriteLine("sourceClass=""" _ pSourceClass _ """>")
		set tMeasures = 0, tDimensions = 0
			/*
					defaultListing="Listing"
					defaultMember="[Product].[All Product]"
					actionClass="HoleFoods.KPIAction"
			*/
		set tStatement = ##class(%SQL.Statement).%New()
		try {
			do tStatement.prepare("select * from " _ tSourceClass.SqlSchemaName _ "." _ tSourceClass.SqlTableName)
			set tSourceMetadata = tStatement.%Metadata
		}
		catch tException {
				// This happens if the class is not queryable. This exception should be reported as a failure to
				// generate the cube because the source class is not in a valid state. Figure out what we want to
				// do here. For now, just throw the exception.
			throw tException
		}
			// Build an index of SQL Column names so we can link back to compiled extent metadata
		set tExtProp = $Order($$$EXTPROP($$$pEXT,pSourceClass,""))
		while tExtProp '= "" {
			set tExtColumnName = $Get($$$EXTPROPsqlcolumnname($$$pEXT,pSourceClass,tExtProp))
			if tExtColumnName '= "" { set tColumnNameIndex($$$ucase(tExtColumnName)) = tExtProp }
			set tExtProp = $Order($$$EXTPROP($$$pEXT,pSourceClass,tExtProp))
		}
		set tColumnKey = ""
		#dim tColumn as %SQL.StatementColumn
		#dim tProperty as %Dictionary.CompiledProperty
		set tColumn = tSourceMetadata.columns.GetNext(.tColumnKey)
		set tFields = ""
		while tColumnKey '= "" {
			set tProperty = tColumn.property
			set tFields = tFields _ "," _ tColumn.colName
			if $Isobject(tProperty) {
					// SqlCategory
					//	String categories
					//		STRING
					//		NAME
					//	Temporal categories
					//		DATE
					//		TIMESTAMP
					//		TIME
					//	Numeric categories
					//		INTEGER
					//		NUMERIC
					//		DOUBLE
				set tTypeClass = ##class(%Dictionary.CompiledClass).%OpenId(tProperty.RuntimeType)
				set tSqlCategory = tTypeClass.SqlCategory
				set tObjectCategory = tTypeClass.ClassType
				
				set tExtentProperty = $Get(tColumnNameIndex($$$ucase(tColumn.colName)))
				if tExtentProperty '= "" {
					if $Get($$$EXTPROPcontainer($$$pEXT,pSourceClass,tExtentProperty)) = "" { set tItemName = tProperty.Name }
					else { set tItemName = tExtentProperty }
				}
				if tObjectCategory = $$$cCLASSCLASSTYPEDATATYPE {
			// STRINGS
					if tSqlCategory = "STRING" {
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<dimension name=""" _ tItemName _ """>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<hierarchy name=""H1"">"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<level name=""" _ tItemName _ """ sourceProperty=""" _ tItemName _ """ />"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "</hierarchy>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "</dimension>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = ""
					}
			// TEMPORAL TYPES
					elseif tSqlCategory = "DATE" {
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<dimension name=""" _ tItemName _ """ type = ""time"" sourceProperty=""" _ tItemName _ """ >"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<hierarchy name=""H1"">"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<level name=""Year" _ tItemName _ """ timeFunction='Year'/>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<level name=""Month" _ tItemName _ """ timeFunction='MonthYear'/>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<level name=""Day" _ tItemName _ """ timeFunction='DayMonthYear'/>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "</hierarchy>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "</dimension>"
						set tDimensions = tDimensions + 1, tDimensions(tDimensions) = ""
					}
					elseif tSqlCategory = "TIME" {
					}
					elseif tSqlCategory = "TIMESTAMP" {
					}
			//	NUMBER TYPES
					elseif tSqlCategory = "INTEGER" {
						set tMeasures = tMeasures + 1, tMeasures(tMeasures) = "<measure name=""" _ tItemName _ """ sourceProperty=""" _ tItemName _ """ />"
					}
					elseif tSqlCategory = "NUMERIC" {
						set tMeasures = tMeasures + 1, tMeasures(tMeasures) = "<measure name=""" _ tItemName _ """ sourceProperty=""" _ tItemName _ """ />"
					}
					elseif tSqlCategory = "DOUBLE" {
						set tMeasures = tMeasures + 1, tMeasures(tMeasures) = "<measure name=""" _ tItemName _ """ sourceProperty=""" _ tItemName _ """ />"
					}
				}
			// OBJECT REFERENCE TYPES
				else {
						// Dimension based on a property whose type class is PERSISTENT or SERIAL
					set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<dimension name=""" _ tItemName _ """>"
					set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<hierarchy name=""H1"">"
					set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "<level name=""" _ tItemName _ """ sourceProperty=""" _ tItemName _ """ />"
					set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "</hierarchy>"
					set tDimensions = tDimensions + 1, tDimensions(tDimensions) = "</dimension>"
					set tDimensions = tDimensions + 1, tDimensions(tDimensions) = ""
				}
			}
			set tColumn = tSourceMetadata.columns.GetNext(.tColumnKey)
		}
		/*
	<index name="MxUnitsSold" properties="MxUnitsSold" type="bitmap"/>
	<index name="MxAmountSold" properties="MxAmountOfSale" type="bitmap"/>
		*/

		do tCubeDef.Data.WriteLine("<listing name=""Listing"" displayName="" Default Listing """)
		do tCubeDef.Data.WriteLine($Char(9)_"fieldList=""" _ tFields _ """ />")
		do tCubeDef.Data.WriteLine("")
		for tPtr = 1:1:tMeasures { do tCubeDef.Data.WriteLine(tMeasures(tPtr)) }
		do tCubeDef.Data.WriteLine("")
		for tPtr = 1:1:tDimensions { do tCubeDef.Data.WriteLine(tDimensions(tPtr)) }
		do tCubeDef.Data.WriteLine("</cube>")
		set versionts = $horolog
		set tClass.TimeCreated = versionts
		set tClass.TimeChanged = versionts
		set tStatus = tClass.%Save()
		if tflag { $$$ResumeTrans }
		set tStatus = $$$OK
	}
	catch tException {
			#; If the user does not have the %All role, add it back.  The $$CheckPriv call may have failed
		$$$AddAllRoleTemporary
		if tflag { $$$ResumeTrans }
		if ($Isobject($Get(tClass))) && (tClass.%Oid() '= "") { do tClass.%Delete(tClass.%Oid()) }
		set tStatus = tException.AsStatus()
	}
	quit tStatus
}

}
