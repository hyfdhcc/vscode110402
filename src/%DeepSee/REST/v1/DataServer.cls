/// This class is responsible for creating the JSON response to the DeepSee REST 
/// data services. For examples and a full list of available services see the documentation
/// for <class>%DeepSee.REST.v1<.class>.
Class %DeepSee.REST.v1.DataServer Extends %DeepSee.REST.REST
{

XData UrlMap
{
<Routes>
   <!-- Send objects in this format: {"MDX":"QUERY"} HTTP method: POST -->
   <Route Url="/MDXExecute" Method="POST" Call="WriteJSONfromMDX"/>
   <Route Url="/PivotExecute" Method="POST" Call="WriteJSONfromPivot"/> 
   <Route Url="/KPIExecute" Method="POST" Call="WriteJSONfromKPI"/> 
   <Route Url="/MDXDrillthrough" Method="POST" Call="WriteJSONfromDrillthrough"/>
   
   <Route Url="/MDXCancelQuery/:queryID" Method="POST" Call="CancelMDXQuery"/>
   <Route Url="/MDXUpdateResults/:queryID" Method="POST" Call="UpdateQueryResults"/>

   <!-- Test method-->
   <Route Url="/TestConnection" Method="GET" Call="Test"/>
   
 </Routes>
}

/// Perform specific validation for the service that will handle the request. This is used
/// as a callback in each service that extends %DeepSee.REST
ClassMethod %ValidateRequest(pUrl As %String, pMethod As %String) As %Status
{
	Set tSC = $$$OK
	Try {
		// +DTB220 - Validate required parameters using information available from the OnPreDispatch callback
		Set tContentObj = %request.Content
		
		If (pUrl["/MDXExecute")||((pUrl["/MDXDrill")) {
			Set tMDX = tContentObj.MDX
			If $G(tMDX)="" {
				Set tSC = $$$ERROR($$$PropertyRequired,"MDX")
				Quit
			}
		}
		ElseIf (pUrl["/PivotExecute") {
			Set tPivot = tContentObj.PIVOT
			If $G(tPivot)="" {
				Set tSC = $$$ERROR($$$PropertyRequired,"PIVOT")
				Quit
			}
		}
		ElseIf (pUrl["/KPIExecute") {
			Set tKPI = tContentObj.KPI
			If $G(tKPI)="" {
				Set tSC = $$$ERROR($$$PropertyRequired,"KPI")
				Quit
			}
		}
		// -DTB220
		
		If (pUrl["MDXDrill") {
			Set tReturnFields = %request.Content.RETURN
			Set tListing = %request.Content.LISTING
			If (tReturnFields'="")&&(tListing'="") {
				Set tSC = $$$ERROR($$$GeneralError,"Drillthrough may only define one of the RETURN and LISTING properties.")
				Quit
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Run any valid MDX (SELECT,DRILLTHROUGH,DRILLFACTS) query and returns the JSON resultset.
ClassMethod WriteJSONfromMDX() As %Status
{
	Set tSC = $$$OK
	Try {
		Set tProvider = ##class(%ZEN.Auxiliary.jsonMDXProvider).%New()
		Set tMDX = %request.Content.MDX

		// +DTB221 - Add filters to the MDX query
		Set tFilters = %request.Content.FILTERS
		If $IsObject(tFilters) {
			Set tRequestFilterSpec = ""
		   	For f=0:1:tFilters.%Size()-1 {
			   	Set tFilter = tFilters.%Get(f)
			   	
			   	Set tRequestFilterSpec = tRequestFilterSpec _ " %FILTER " _ tFilter
		   	}
			Set tMDX = tMDX _ tRequestFilterSpec
		}
		 
		Set tProvider.mdxQuery = tMDX
		// -DTB221
		
        // +DTB226 - Wait for results on the server
		// Assume the client wishes to wait for results if no value is specified
        Set tWait = %request.Content.WAIT
        Set:(tWait="") tWait = 1
        
		If +tWait {
			Set tTimeout = +%request.Content.TIMEOUT
			If (tTimeout<=0) {
				// Get the current session timeout
				Set tTimeout = %session.AppTimeout - $S(%session.AppTimeout>2:2,1:0)	// Send something back jst before the appTimeout is reached
			}
         	Set tSC = ..%WaitForProviderResults(tProvider,tTimeout)
		}
		If $$$ISERR(tSC) Quit
        // -DTB226
        
        Set tSC = tProvider.%DrawJSON()
    } Catch ex {
        Set tSC=ex.AsStatus()
    }

	// DTB220
	If $$$ISERR(tSC) {
		Set tSC = ..%ErrorToJSON(tSC)
	}

    Quit tSC
}

/// Run a listing from either the source or the fact table. Specific 
/// listings or a list of fields may be POSTed to add to the query.
ClassMethod WriteJSONfromDrillthrough()
{
	// Method added by DTB226
	Set tSC = $$$OK
	Try {
		Set tProvider = ##class(%ZEN.Auxiliary.jsonMDXProvider).%New()
		Set tMDX = %request.Content.MDX

		// Add filters to the MDX query
		Set tFilters = %request.Content.FILTERS
		If $IsObject(tFilters) {
			Set tRequestFilterSpec = ""
		   	For f=0:1:tFilters.%Size()-1 {
			   	Set tFilter = tFilters.%Get(f)
			   	
			   	Set tRequestFilterSpec = tRequestFilterSpec _ " %FILTER " _ tFilter
		   	}
			Set tMDX = tMDX _ tRequestFilterSpec
		}
		Set tReturnFields = %request.Content.RETURN
		Set tListing = %request.Content.LISTING
		If tReturnFields'="" {
			Set tMDX = tMDX _ " RETURN " _ tReturnFields
		}
		If tListing'="" {
			// Listings need to have valid MDX IDs
			Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tListing,.tInfo)
			Set tListing = "[" _$$$dsEscapeIdent(tInfo(1))_ "]"
			Set tMDX = tMDX _ " %LISTING " _ tListing
		}
		
		Set tProvider.mdxQuery = tMDX
		
        // Wait for results on the server
		// Assume the client wishes to wait for results if no value is specified
        Set tWait = %request.Content.WAIT
        Set:(tWait="") tWait = 1
        
		If +tWait {
			Set tTimeout = +%request.Content.TIMEOUT
			If (tTimeout<=0) {
				// Get the current session timeout
				Set tTimeout = %session.AppTimeout - $S(%session.AppTimeout>2:2,1:0)	// Send something back jst before the appTimeout is reached
			}
         	Set tSC = ..%WaitForProviderResults(tProvider,tTimeout)
		}
		If $$$ISERR(tSC) Quit
        
        Set tSC = tProvider.%DrawJSON()
    } Catch ex {
        Set tSC=ex.AsStatus()
    }

	If $$$ISERR(tSC) {
		Set tSC = ..%ErrorToJSON(tSC)
	}

    Quit tSC
}

/// Run any stored pivot table and return the associated JSON resultset.
ClassMethod WriteJSONfromPivot() As %Status
{
	Set tSC = $$$OK
	Try {
		Set tProvider = ##class(%ZEN.Auxiliary.jsonMDXProvider).%New()
		Set tPivotName = %request.Content.PIVOT
		
		// DTB239 - Normalize the pivot name and check for existence
		If $E($$$LOWER(tPivotName),*-5,*)=".pivot" {
			Set tPivotID = tPivotName
		}
		Else {
			Set tPivotID = tPivotName _ ".pivot"
		}
		If '##class(%DeepSee.UserLibrary.Utils).%FolderItemExists(tPivotID) {
			Set tSC = $$$ERROR($$$GeneralError,"Pivot table is unavailable:"_tPivotID)
			Quit
		}
		Set tProvider.pivotTable = tPivotName
		
		// DTB239 - Set variables into the provider
		Set tVariables = %request.Content.VARIABLES
		If $$$NULLOREF'=tVariables {
			For var=0:1:tVariables.%Size()-1 {
				Set tVariable = tVariables.%Get(var)
				Do tProvider.pivotVariables.SetAt(tVariable.value,tVariable.name)
			}
		}

		// +DTB221 - Add filters to the provider (pivotTable component)
		Set tFilters = %request.Content.FILTERS
		If $IsObject(tFilters) {
			Set tRequestFilterSpec = ""
			For f=0:1:tFilters.%Size()-1 {
				Set tFilter = tFilters.%Get(f)

				Set tRequestFilterSpec = tRequestFilterSpec _ $S($L(tRequestFilterSpec):" ",1:"") _ "%FILTER " _ tFilter
			}
			Set tProvider.contextFilterSpec = tRequestFilterSpec
		}
		// -DTB221
         
        // +DTB226 - Decide whether to wait for results on the server or send partial 
        // results back immediately. Assume the client wishes to wait for results 
        // if nothing is specified.
        Set tWait = %request.Content.WAIT
        Set:(tWait="") tWait = 1
        
		If +tWait {
			Set tTimeout = +%request.Content.TIMEOUT
			If (tTimeout<=0) {
				// Get the current session timeout
				Set tTimeout = %session.AppTimeout - $S(%session.AppTimeout>2:2,1:0)	// Send something back jst before the appTimeout is reached
			}
         	Set tSC = ..%WaitForProviderResults(tProvider,tTimeout)
		}
		If $$$ISERR(tSC) Quit
        // -DTB226
        
        Set tSC = tProvider.%DrawJSON()
    } Catch ex {
        Set tSC=ex.AsStatus()
    }

	// DTB220
	If $$$ISERR(tSC) {
		Set tSC = ..%ErrorToJSON(tSC)
	}

    Quit tSC
}

/// Run any compiled KPI and return the associated JSON resultset.
ClassMethod WriteJSONfromKPI() As %Status
{
	// Method addded by DTB234
	Set tSC = $$$OK
	Try {
		Set tKpi = %request.Content.KPI
		
		Set tFilterObj = %request.Content.FILTERS
		Set tFilters = ""
		If $IsObject(tFilterObj) {
			For f=0:1:tFilterObj.%Size()-1 {
				Set tFilter = tFilterObj.%Get(f)
				Set tFilters(tFilter.name) = tFilter.value
			}
		}
		
		Set tKpiClassName = ##class(%DeepSee.Utils).%GetKPIClass(tKpi,.tSC)
		If $$$ISERR(tSC) Quit
		
		If (tKpiClassName'="") {
			Set tSC = $classmethod(tKpiClassName,"%GetKPIPropertyInfo",.tKpiProps)
			If $$$ISERR(tSC) Quit
		}
		
		Set tKpiPropIdx = $O(tKpiProps(""),1,tProperty)
		Set tKpiPropList = ""
		While (tKpiPropIdx'="") {
			Set tKpiPropList = tKpiPropList _ $LB(tProperty)
			Set tKpiPropArray(tKpiPropIdx) = $LB(tProperty,$G(tKpiProps(tKpiPropIdx,"caption")),$G(tKpiProps(tKpiPropIdx,"columnNo")))
			Set tKpiPropIdx = $O(tKpiProps(tKpiPropIdx),1,tProperty)
		}

		Set tKpiSC = $classmethod(tKpiClassName,"%GetKPIValueArray",tKpi,.tKpiValues,.tKpiPropList,.tFilters)
		
		Set tSC = ..%CreateObjectFromArray(.tKpiValues,tKpiPropList,.tValueObj)
		If $$$ISERR(tSC) Quit
		
		Set tSC = ..%CreateObjectFromArray(.tKpiPropArray,$LB("name","caption","columnNo"),.tPropObj)
    	If $$$ISERR(tSC)
    	
    	// Use consistent objects for normalized return
    	Set tProvider = ##class(%ZEN.Auxiliary.jsonMDXProvider).%New()
    	Set tInfoObj = tProvider.%ConstructNewDynamicObject()
    	Set tResultObj = tProvider.%ConstructNewDynamicObject()
		
		Set:$IsObject(tPropObj.children) tResultObj.Properties = tPropObj.children
		Set:$IsObject(tValueObj.children) tResultObj.Series = tValueObj.children
		
		Set tInfoObj.Error = tProvider.%StatusToDynamicObject(tKpiSC)
		Set tInfoObj.KpiName = tKpi
		
		Set tKpiObj = tProvider.%ConstructNewDynamicObject()
    	Set tKpiObj.Info = tInfoObj
    	Set tKpiObj.Result = tResultObj
    	
    	Set tSC = tProvider.%ObjectToJSON(tKpiObj)
    } Catch ex {
        Set tSC=ex.AsStatus()
    }

	If $$$ISERR(tSC) {
		Set tSC = ..%ErrorToJSON(tSC)
	}

    Quit tSC
}

/// Cancel a running query using the cubeKey and queryKey provided in a previously returned resultset with ResultsComplete=0.
ClassMethod CancelMDXQuery(pQueryToken) As %Status
{
	// DTB223 - Call API to cancel
	Set pQueryToken = $ZCONVERT($ZCONVERT(pQueryToken,"I","URL") ,"I","UTF8")			// DTB210
	
	Set tCubeKey = $P(pQueryToken,"||",1)
	Set tQueryKey = $P(pQueryToken,"||",2)

	Set tSC = ##class(%DeepSee.ResultSet).%CancelQuery(tCubeKey,tQueryKey)
	Set tSC = ..%ErrorToJSON(tSC)
    
    Quit tSC
}

/// Try to obtain results from a previous query that returned incomplete results.
ClassMethod UpdateQueryResults(pQueryToken) As %Status
{
	Set pQueryToken = $ZCONVERT($ZCONVERT(pQueryToken,"I","URL") ,"I","UTF8")			// DTB210
	Set tSC = $$$OK
	Try {
		
		Set tCubeKey = $P(pQueryToken,"||",1)
		Set tQueryKey = $P(pQueryToken,"||",2)
		
        Set tProvider = ##class(%ZEN.Auxiliary.jsonMDXProvider).%New()
        Set tProvider.cubeKey = tCubeKey
        Set tProvider.queryKey = tQueryKey
        
        Set tSC = tProvider.%DrawJSON()
    } Catch ex {
        Set tSC=ex.AsStatus()
    }

	// DTB220
	If $$$ISERR(tSC) {
		Set tSC = ..%ErrorToJSON(tSC)
	}

    Quit tSC
}

/// Test method to confirm connection in the service type
ClassMethod Test() As %Status
{
    // DTB267 - Send back test status
    Set tTestObj = ##class(%DynamicObject).%New()
    Set tTestObj.Status = "OK"
    Set tTestObj.DispatchClass = $ClassName()
    Set tTestObj.NameSpace = $NameSpace
    Do tTestObj.%ToJSON()
             
    Quit $$$OK
}

}
