Include (%occUtility, %DeepSee)

/// This class contains methods used by the DeepSee Connector code generators.<br/>
/// This class should be consider to be INTERNAL to DeepSee;
/// There are no methods intended for public use.
Class %DeepSee.Connector.Generator Extends %RegisteredObject [ System = 4 ]
{

/// Does the actual work of generating classes needed to implement the Data Connector.
/// Returns property info via <var>pPropInfo</var>.
/// pPropInfo contains:<br/>
/// 	Set pPropInfo(p) = $LB(propName,displayName,propType,propIDKEY,sourceProp)
ClassMethod %GenerateConnector(pConnector As %DeepSee.Connector.connector, pClassName As %String, Output pPropInfo As %List) As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		// analyze properties
		Set tSourcePropCount = 0 // number of unique sourceProperties
		For p = 1:1:pConnector.properties.Count() {
			Set tProp = pConnector.properties.GetAt(p)
			Set tPropName = tProp.name
			Set tPropType = tProp.type
			Set tPropIDKEY = +tProp.idKey
			Set:tPropType="" tPropType = "%String"
			Set tSourceProp = tProp.sourceProperty
			Set tXForm = tProp.transform

			If (tPropName = "") {
				Set tSC = $$$ERROR($$$GeneralError,"No name for property: "_p)
				Quit
			}
			If ('$ZNAME(tPropName,3)) {
				Set tSC = $$$ERROR($$$GeneralError,"Invalid property name: "_tPropName)
				Quit
			}
			If (tPropType = "") {
				Set tSC = $$$ERROR($$$GeneralError,"No type for property: "_tPropName)
				Quit
			}
			If (tPropIDKEY && (tXForm'="")) {
				Set tSC = $$$ERROR($$$GeneralError,"Transformation not allowed for id property: "_tPropName)
				Quit
			}

			Set pPropInfo(p) = $LB(tPropName,tProp.displayName,tPropType,tPropIDKEY,tSourceProp)
			If (tSourceProp'="") {
				// gather the source expressions
				If ('$D(tSourcePropList($$$UPPER(tSourceProp)))) {
					Set tSourcePropCount = tSourcePropCount + 1
					Set tSourcePropList($$$UPPER(tSourceProp)) = tSourcePropCount
					Set tSourcePropIndex(tSourcePropCount) = tSourceProp
				}
			}

			// gather the output properties with sourceProp #, type, and transform code
			If ('$D(tPropIndex(tPropName))) {
				// JMD1056 Use correct source prop index #
				Set tSIndex = $S(tSourceProp'="":$G(tSourcePropList($$$UPPER(tSourceProp))),1:"")
				Set tPropIndex(tPropName) = $LB(tSIndex,tPropType,tXForm)
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Duplicate property name: "_tPropName)
				Quit
			}
		}
		If $$$ISERR(tSC) Quit

		#; generate CustomResult class to supply the transformed data
		Set tRSDefName = pClassName_".ResultSet"

		#; Create a new class definition
		Set tClassDef = ##class(%Dictionary.ClassDefinition).%New(tRSDefName)
		If tClassDef = $$$NULLOREF Set tSC=$$$ERROR($$$CannotCreateObject,"%Dictionary.ClassDefinition") Quit
		Set tClassDef.Super = "%DeepSee.Connector.ResultSet"
        Set tClassDef.IncludeCode = ""
        Set tClassDef.ProcedureBlock = 1
        Set tClassDef.Description = "ResultSet API for Data Connector '"_pClassName_"'.<br/>"_$C(13,10)_
        							"THIS IS A GENERATED CLASS, DO NOT EDIT.<br/>"_$C(13,10)_
        							"Generated by %DeepSee.Connector.Generator."

		#; CONNECTOR param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tRSDefName_":"_"CONNECTOR")
		Set tParmDef.Default = pClassName
		Do tClassDef.Parameters.Insert(tParmDef)

		#; generate properties
		For p = 1:1:pConnector.properties.Count() {
			Set tProp = pConnector.properties.GetAt(p)
			Set tPropName = tProp.name
			Set tPropInfo = tPropIndex(tPropName)
			Set tPropType = $LG(tPropInfo,2)

			Set tProp = ##class(%Dictionary.PropertyDefinition).%New(tRSDefName_"||"_tPropName)
			Set tProp.Name = tPropName
			Set tProp.Type = tPropType
			If (tProp.Type = "%String") {
				Do tProp.Parameters.SetAt(512,"MAXLEN")
			}
			Set tProp.SequenceNumber = $I(tSeq) + 1000
			Do tClassDef.Properties.Insert(tProp)
		}

		#; methods

		#; %Next
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tRSDefName_"||%Next")
		Set tMeth.Name = "%Next"
		Set tMeth.FormalSpec = "&pSC:%Status"
		Set tMeth.ReturnType = "%Integer"
		Set tMeth.PlaceAfter = "%Execute"
		Set tMeth.Description = "Fetch next record."
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tRet = 0")
		Do tMeth.Implementation.WriteLine(" Set pSC = $$$OK")
		Do tMeth.Implementation.WriteLine(" Try {")
		Do tMeth.Implementation.WriteLine("  New %val")

		// fetch, test for end
		Do tMeth.Implementation.WriteLine("  Set tSkip = 0")
		Do tMeth.Implementation.WriteLine("  Do {")
		// use source result set
		Do tMeth.Implementation.WriteLine("   If $IsObject(..%sourceResultSet) {")
		Do tMeth.Implementation.WriteLine("    Set tRet = ..%sourceResultSet.%Next(.pSC)")
		Do tMeth.Implementation.WriteLine("    If $$$ISERR(pSC) Quit")
		Do tMeth.Implementation.WriteLine("    If 'tRet Quit")

		// copy source properties into this instance, apply transforms
		For p = 1:1:pConnector.properties.Count() {
			Set tProp = pConnector.properties.GetAt(p)
			Set tPropName = tProp.name
			Set tPropInfo = tPropIndex(tPropName)
			Set tSourceIdx = $LG(tPropInfo,1)
			Set tXForm = $LG(tPropInfo,3)
			Set tSourceProp = $S(tSourceIdx'="":tSourcePropIndex(tSourceIdx),1:"")

			// special case for %ID
			If ($$$UPPER(tSourceProp) = "%ID") {
				Set tSourceProp = "ID"
			}

			If (tXForm'="") {
				// apply xform
				If (tSourceProp="") {
					Do tMeth.Implementation.WriteLine("    Set %val = """"")
				}
				Else {
					Do tMeth.Implementation.WriteLine("    Set %val = ..%sourceResultSet.%Get("_$$$quote(tSourceProp)_")")
				}
				Do tMeth.Implementation.WriteLine("    Set .."_tPropName_" = $S(%val'="""":"_tXForm_",1:%val)")
			}
			Else {
				If (tSourceProp="") {
					Do tMeth.Implementation.WriteLine("    Set .."_tPropName_" = """"")
				}
				Else {
					Do tMeth.Implementation.WriteLine("    Set .."_tPropName_" = ..%sourceResultSet.%Get("_$$$quote(tSourceProp)_")")
				}
			}
		}
		Do tMeth.Implementation.WriteLine("   }")
		
		// dispatch to wrapper
		Do tMeth.Implementation.WriteLine("   Else {")
		Do tMeth.Implementation.WriteLine("    Set tRet = ..%connector.%OnNextRecord(.pSC)")
		Do tMeth.Implementation.WriteLine("    If $$$ISERR(pSC) Quit")
		Do tMeth.Implementation.WriteLine("    If 'tRet Quit")


		// apply transforms, if present; ignore source property
		For p = 1:1:pConnector.properties.Count() {
			Set tProp = pConnector.properties.GetAt(p)
			Set tPropName = tProp.name
			Set tPropInfo = tPropIndex(tPropName)
			Set tSourceIdx = $LG(tPropInfo,1)
			Set tXForm = $LG(tPropInfo,3)
			Set tSourceProp = $S(tSourceIdx'="":tSourcePropIndex(tSourceIdx),1:"")
			If (tXForm'="") {
				Do tMeth.Implementation.WriteLine("    Set %val = .."_tPropName)
				Do tMeth.Implementation.WriteLine("    Set .."_tPropName_" = $S(%val'="""":"_tXForm_",1:%val)")
			}
		}

		Do tMeth.Implementation.WriteLine("   }")

		// invoke %OnProcessRecord if present
		If ($$$comMemberKeyGet(pClassName,$$$cCLASSmethod,"%OnProcessRecord",$$$cMETHrunnable)) {
			Do tMeth.Implementation.WriteLine("   Set tSkip = 0")
			Do tMeth.Implementation.WriteLine("   Set pSC = ..%connector.%OnProcessRecord(##this,.tSkip)")
			Do tMeth.Implementation.WriteLine("   If $$$ISERR(pSC) Quit")
		}

		// do/while
		Do tMeth.Implementation.WriteLine("  } While(tSkip)")
		Do tMeth.Implementation.WriteLine("  If $$$ISERR(pSC) Quit")

		Do tMeth.Implementation.WriteLine("  Set ..%ROWCOUNT = ..%ROWCOUNT + 1")
		Do tMeth.Implementation.WriteLine(" }")
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set pSC = ex.AsStatus()")
		Do tMeth.Implementation.WriteLine("  Set tRet = 0")
		Do tMeth.Implementation.WriteLine(" }")
		Do tMeth.Implementation.WriteLine(" Quit tRet")
		Do tClassDef.Methods.Insert(tMeth)

		#; save the ResultSet class definition
	    Set tSC = tClassDef.%Save()
	    If $$$ISERR(tSC) Quit

	    #; Now queue the generated class for compilation
	    Do QueueClass^%occCompile(tRSDefName)
	    #; Mark this class for deletion when the cube class is deleted.
	    $$$comClassArraySet(pClassName,$$$cCLASSclasses,tRSDefName_".CLS","")
	    $$$defClassKeySet(tRSDefName,$$$cCLASSgeneratedby,pClassName_".CLS")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

}
