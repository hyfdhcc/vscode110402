Include %DeepSee

/// This class provides an API for executing queries against DeepSee cubes 
/// and viewing the results.<br/>
/// This class extends Zen data model so that it can efficiently
/// work within the Zen MVC framework.
Class %DeepSee.ResultSet Extends %ZEN.DataModel.DataModel [ System = 4 ]
{

/// Debugging flag. If true write out tracing information to the console.
Property %Trace As %Boolean [ InitialExpression = 0 ];

/// Run-time query object that will serve as the source for this result set.
Property %Query As %DeepSee.Query.query [ Internal ];

/// Name of the cube this query is based on.
Property %Cube As %DeepSee.Datatype.string [ Internal ];

/// Canonic (index) name of the cube this query is based on.
Property %CubeKey As %DeepSee.Datatype.string [ Internal ];

/// Query key for the current query.
Property %QueryKey As %DeepSee.Datatype.string [ Internal ];

/// Array of timing and performance statistics for the current query.
Property %Statistics As %DeepSee.Datatype.string [ MultiDimensional ];

/// If true, then use results caching for this query.
Property %UseCache As %Boolean [ InitialExpression = 1 ];

/// If true recompute previously run queries whose data has been updated
/// otherwise return old values.
Property %Recompute As %Boolean [ InitialExpression = 1 ];

/// Holds the number of axes in the current query.
Property %AxisCount As %Integer [ Internal ];

/// Array of named parameters with current values.
/// These are set by the <method>%SetParameterContext</method> method.<br/>
Property %NamedParameters As %Integer [ Internal, MultiDimensional ];

/// This holds the SQL query generated by a DRILLTHROUGH query.
/// Use the <method>%GetListingSQL</method> to get this.
Property %ListingSQL As %String(MAXLEN = 32000) [ Private ];

/// This holds the SQL StatementResult object created by a DRILLTHROUGH query.
/// Use the <method>%GetListingResult</method> to get this.
Property %ListingResult As %SQL.StatementResult [ Private ];

/// List of fields to display for a DRILLTHROUGH query.
/// Use the <method>%GetListingResult</method> to get this.
Property %ListingFields As %List [ Private ];

// WAL107

Property %IsPlugIn As %Integer [ InitialExpression = 0 ];

// WAL107

Property %PlugInListingKey As %String;

// WAL170

Property %PlugInContextName As %String;

// WAL170

Property %PlugInContextProp As %String;

// WAL170

Property %PlugInFilters As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional, Transient ];

Property %PlugInArguments As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional, Transient ];

/// If set, this is the name of a listing within the current cube to use for detail listings.
Property listing As %String(MAXLEN = 255);

/// Number of rows in the current listing query.
Property listingRows As %Integer [ InitialExpression = 0 ];

/// Number of rows within a listing query "page".
Property listingPageSize As %Integer [ InitialExpression = 1000 ];

/// Current "page" of listing query.
Property listingPage As %Integer [ InitialExpression = 1 ];

/// Formatting string to apply to listing results.
Property listingFormatList As %String(MAXLEN = 5000);

/// Convenience method.<br/>
/// Creates a result set, prepares the query <var>pMDX</var>, and executes it.<br/>
/// Returns an instance of the result set.
ClassMethod %ExecuteDirect(pMDX As %String, ByRef pParms, Output pSC As %Status) As %DeepSee.ResultSet
{
	Set pSC = $$$OK
	Set tRS = ""
	Try {
		Set tRS = ..%New()
		Set pSC = tRS.%PrepareMDX(pMDX)
		If $$$ISERR(pSC) Quit

		Set pSC = tRS.%Execute(.pParms)
		If $$$ISERR(pSC) Quit
	}
	Catch(ex) {
		Set pSC = ex.AsStatus()
		Set tRS = ""
	}
	Quit tRS
}

/// Given the text of a DeepSee MDX query, <var>pMDX</var>, 
/// parse it, convert it to a DeepSee run-time query object, and
/// prepare it so that it can then be executed.<br/>
/// <var>pVariables</var> is an optional list of pivot variable names and their current values.
/// These are substituted for any pivot variable references within the query before it is parsed.<br/>
/// <var>pResolvedMDX</var> is the query text after any pivot variable references have been resolved.
Method %PrepareMDX(pMDX As %String, ByRef pVariables, Output pResolvedMDX) As %Status
{
	Set tSC = $$$OK
	Try {
		Set ..%Query = ""
		Set ..%QueryKey = ""
		Set ..%Cube = ""
		Set ..%CubeKey = ""
		Set ..%AxisCount = ""
		Set ..%ListingSQL = ""
		Set ..%ListingResult = ""
		Set ..%ListingFields = ""

		// parse the query
		Set tQuery = ##class(%DeepSee.Query.query).%New()
		Merge tQuery.%NamedParameters = ..%NamedParameters

		// JMD1507: translate pivot variable names to lower case
		Set k = $O(pVariables(""))
		While (k'="") {
			Set tVariables($$$LOWER(k)) = $G(pVariables(k))
			Set k = $O(pVariables(k))
		}

		// JMD1276: resolve any pivot variables within the query
		// these are basically macro substitutions using the named parameter list as values
		Set tMarker = "$variable."
		Set tMDXLower = $$$LOWER(pMDX)
		If (tMDXLower[tMarker) {
			Set tMDX = ""
			Set p=1,next=1
			While (next>0) {
				Set next = $Find(tMDXLower,tMarker,next)
				If (next=0) {
					Set tMDX = tMDX _ $E(pMDX,p,*)
					Quit
				}
				Else {
					Set tMDX = tMDX _ $E(pMDX,p,next-$L(tMarker)-1)
					Set p = next
					While (($E(pMDX,next)'="")&&($ZNAME("X"_$E(pMDX,next)))) {
						Set next = next+1
					}
					Set tVar = $$$LOWER($E(pMDX,p,next-1))
					If (tVar="") {
						Set tMDX = tMDX _ tMarker
					}
					Else {
						Set tValue = $G(tVariables(tVar))
						Set:tValue="" tValue = """"""
						
						// JMD1349: translate "%NOT value" to "value.%NOT"
						If ($E(tValue,1,5) = "%NOT ") {
							Set tValue = $E(tValue,6,*)_".%NOT"
						}
						Set tMDX = tMDX _ tValue
					}
				}
				Set p = next
			}
			Set pMDX = tMDX
		}

		Set pResolvedMDX = pMDX

		Set tSC = ..%ParseMDX(pMDX,tQuery)
		If $$$ISERR(tSC) Quit

		// n.b., this will set %Query
		Set tSC = ..%PrepareObject(tQuery)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// Given a DeepSee run-time query, <var>pQuery</var>, 
/// prepare it so that it can then be executed.
Method %PrepareObject(pQuery As %DeepSee.Query.query) As %Status
{
	Set tSC = $$$OK
	Try {
		Set ..%Query = pQuery
		Set ..%QueryKey = ""
		Set ..%Cube = ""
		Set ..%CubeKey = ""
		Set ..%AxisCount = ""
		Set ..%ListingSQL = ""
		Set ..%ListingResult = ""
		Set ..%ListingFields = ""

		Set ..%Query.useCache = ..%UseCache
		Set ..%Query.recompute = ..%Recompute
		If ((pQuery.queryType="CREATE")||(pQuery.queryType="DROP")) {
			Set ..%Cube = ..%Query.cube
			Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
			Quit
		}

		Set tSC = ..%Query.%Prepare()
		If $$$ISERR(tSC) Quit

		// Note: key is not available until ExecuteParameters is called
		Set ..%QueryKey = ..%Query.%QueryKey
		Set ..%Cube = ..%Query.cube
		Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Given a DeepSee query key, <var>pQueryKey</var>, 
/// (returned by a previous query prepare),
/// restore the state of the query so that it can
/// be executed.<br/>
Method %PrepareKey(pCubeName As %String = "", pQueryKey As %String = "", pPrepareMDX As %Boolean = 0) As %Status
{
	Set tSC = $$$OK
	Try {
		If ((pCubeName="")||(pQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Missing cube or query key in %PrepareKey")
			Quit
		}

		// + WAL266 -- check to see if cache is up to date. If not and if the caller specifies
		//             that we should run %PrepareMDX in this case do so
		Set tSC = ##class(%DeepSee.Query.query).%CheckResultsCache(pCubeName,pQueryKey,.tCacheUpToDate)
		If (pPrepareMDX && 'tCacheUpToDate) {
			Set tQueryText = $G($$$DeepSeeResultsGLVN($$$DeepSeeIndex(pCubeName),pQueryKey))
			If tQueryText'="" {
				Set tSC = ..%PrepareMDX(tQueryText)
				If $$$ISERR(tSC) Quit 	
			}
			Quit
		}
		// - WAL266

		#; See if this query is in the cache
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		If ('$D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}
		Set ..%QueryKey = pQueryKey
		Set ..%Cube = pCubeName
		Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
		Set ..%Query = ##class(%DeepSee.Query.query).%New()
		Merge ..%Query.%NamedParameters = ..%NamedParameters
		Set ..%Query.cube = pCubeName
		Set ..%Query.%QueryKey = pQueryKey
		Set ..%AxisCount = ""
		 
			#; check status
			Set tStatus = ..%GetQueryStatus(pCubeName,pQueryKey)
			If (tStatus < 30) {
				// JMD1156
				//Set tSC = $$$ERROR($$$GeneralError,"ExecuteAxes must be called before PrepareKey")
				//Quit
			}
			Set ..%Query.queryType = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"queryType"))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Specify which listing to use for detail listings.
Method %SetListing(pListing As %String) As %Status
{
	Set ..listing = pListing
	Quit $$$OK
}

/// Take a pre-defined set of named parameters and apply them to MDX
/// queries executed against this result set.<br/>
/// This makes it possible to add defined parameters to a query without 
/// adding them to the query text. This is different than supplying run-time values
/// for parameters when executing the query.<br/>
/// The named parameter context is an array subscripted by UPPER CASE parameter
/// name and parameter attribute (which can be "VALUE","TYPE",or "CAPTION").<br/>
/// For example:<br/>
/// pContext("CITY","VALUE") = "New York"<br/>
/// Call this before preparing a query.
Method %SetParameterContext(ByRef pContext) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill ..%NamedParameters
		Merge ..%NamedParameters = pContext
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Return the DeepSee run-time query object currently in use
/// as the source for this result set.
Method %GetQuery() As %DeepSee.Query.query
{
	Quit ..%Query
}

/// Return the current Query Key for this Result Set.
/// The result set must be prepared before calling this.
Method %GetQueryKey() As %String
{
	Quit ..%QueryKey
}

/// Return the name of the cube this ResultSet is executing against.
/// The result set must be prepared before calling this.
Method %GetCubeName() As %String
{
	Quit ..%Cube
}

/// Output the cube last data update date in the XMLA format
Method %GetLastDataUpdate() As %String
{
	Set tCubeKey = ..%CubeKey
	Set tLastDataUpdate = $G($$$DeepSeeUpdateQueue("cubes",tCubeKey,"lastDataUpdate"))		// DTB422
	If (tLastDataUpdate'="") {
		// format is: "2009-06-19T15:55:31"
		Set tLastDataUpdate = $TR($ZDT(tLastDataUpdate,3)," ","T")
	}
	Quit tLastDataUpdate
}

/// Output the cube last schema update date in the XMLA format
Method %GetLastSchemaUpdate() As %String
{
	Set tCubeKey = ..%CubeKey
	Set tLastSchemaUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeKey,"lastSchemaUpdate"))
	If (tLastSchemaUpdate'="") {
		// format is: "2009-06-19T15:55:31"
		Set tLastSchemaUpdate = $TR($ZDT(tLastSchemaUpdate,3)," ","T")
	}
	Quit tLastSchemaUpdate
}

/// Prepare and execute the listing query for the current MDX statement.
/// Return an SQL ResultSet that can be used to iterate over the listing.
/// If <var>pFieldList</var> is not empty, then it is a $List of fields that
/// should be selected and displayed from the result set.
Method %GetListingResultSet(Output pRS As %SQL.StatementResult, Output pFieldList As %List) As %Status
{
	Set tSC = $$$OK
	Set pRS = ..%ListingResult
	Set pFieldList = ..%ListingFields
	If (pRS="") {
		Set tSC = $$$ERROR($$$GeneralError,"No listing result available")
	}
	Quit tSC
}

/// Return the SQL statement needed to drill into the source table for a DRILLTHROUGH statement.
/// This may return the name of the DataConnector class if that is how the listing is defined.
Method %GetListingSQL() As %String
{
	Quit ..%ListingSQL
}

/// Test if this is a DRILLTHROUGH statement.
Method %IsDrillThrough() As %Boolean
{
	Set tIsDrill = 0
	If ((..%CubeKey'="")&&(..%QueryKey'="")) {
		// JMD1381 check for slave query
		Set tQueryKey = ..%QueryKey
		Set tIsSlave = ($E(tQueryKey,1,6)="SLAVE:")
		If (tIsSlave) {
			Set tQueryKey = $E(tQueryKey,7,*)
		}
		Set tIsDrill = $G($$$DeepSeeResultsGLVN(..%CubeKey,tQueryKey,"queryType")) = "DRILLTHROUGH"
	}
	Quit tIsDrill
}

/// Return the text of the query currently associated with this result set.
/// This text is generated from the query parse tree and represents the canonic form
/// of the query.
Method %GetQueryText() As %String
{
	Set tText = ""
	If ((..%CubeKey'="")&&(..%QueryKey'="")) {
		// JMD1381 check for slave query
		Set tQueryKey = ..%QueryKey
		Set tIsSlave = ($E(tQueryKey,1,6)="SLAVE:")
		If (tIsSlave) {
			Set tQueryKey = $E(tQueryKey,7,*)
		}
		Set tText = $G($$$DeepSeeResultsGLVN(..%CubeKey,tQueryKey,"query",1))
	}
	Quit tText
}

/// Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
/// return the current status of the query.<br/>
/// 0 indicates that nothing has been done; 100 indicates that 
/// query execution is complete and that results are ready; a value
/// in between means that work is ongoing.
ClassMethod %GetQueryStatus(pCubeName As %String, pQueryKey As %String, Output pPercentComplete As %Double, Output pSC As %Status, Output pPendingResults As %Boolean) As %Integer
{
	// JMD900
	Set pPendingResults = 0

	Set pSC = $$$OK
	Set pPercentComplete = ""
	Quit:pCubeName="" 0
	Quit:pQueryKey="" 0
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// JMD1381 check for slave query
	Set tIsSlave = ($E(pQueryKey,1,6)="SLAVE:")
	If (tIsSlave) {
		Set pQueryKey = $E(pQueryKey,7,*)
	}

	// If query has an error, report it
	Set pSC = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error"),$$$OK)
	If $$$ISERR(pSC) {
		Set pPercentComplete = 100		
		Quit 100
	}

	Set tStatus = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"status"))
	If (tStatus = "") {
		// not ready yet OR someone killed the results global (don't log that!)
		If $D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey)) {
			Do ##class(%DeepSee.Utils).%WriteToLog("ResultSet","GetQueryStatus no status found")
		}
		Quit 0
	}
	Set tStatus = +tStatus
	Set tCellTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"cellTaskGroup"))
	Set tAxesTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axesTaskGroup"))

	// JMD1156
	If ((tStatus < 30)&&(tAxesTaskGroup'="")) {
		If ($G($$$DeepSeeTaskGroupGLVN(tAxesTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
		}
		If '##class(%DeepSee.TaskMaster).%IsActive() {
			Set pSC = $$$ERROR($$$GeneralError,"No background agents available to process query")
			Quit 0
		}
		
		// find approx total number of items in all axes
		Set tMbrCount = 0
		Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axis",""),1,tAxisKey)
		While (tAxisNo'="") {
			Set tLastKey = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",""),-1)
			Set tMbrCount = tMbrCount + tLastKey
			Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axis",tAxisNo),1,tAxisKey)
		}
		Set pPercentComplete = tMbrCount
	}
	ElseIf (tCellTaskGroup'="") {
		If ($G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
		}

		If '##class(%DeepSee.TaskMaster).%IsActive() {
			Set pSC = $$$ERROR($$$GeneralError,"No background agents available to process query")
			Quit 0
		}

		Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"count"))
		Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"complete"))
		Set:tCount>0 pPercentComplete = (tComplete/tCount)*100
	}
	ElseIf (tStatus > 50) {
		Set pPercentComplete = 100

		// JMD900: test for pending results
		Set pPendingResults = ''$D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"pending"))
	}	
	Quit tStatus
}

/// Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
/// return the number of result cells that are returned by the query.<br/>
ClassMethod %GetCellCount(pCubeName As %String, pQueryKey As %String, Output pSC As %Status) As %Integer
{
	Set pSC = $$$OK
	Quit:pCubeName="" 0
	Quit:pQueryKey="" 0
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// JMD1381 check for slave query
	Set tIsSlave = ($E(pQueryKey,1,6)="SLAVE:")
	If (tIsSlave) {
		Set pQueryKey = $E(pQueryKey,7,*)
	}

	// If query has an error, report it
	Set pSC = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error"),$$$OK)
	Quit +$G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"cells"))
}

/// Cancel the query, if running, specified by the cube name and query key.
ClassMethod %CancelQuery(pCubeName As %String, pQueryKey As %String) As %Status
{
	Set tSC = $$$OK
	Try {
		If ((pCubeName="")||(pCubeName="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not specified")
			Quit
		}
		Set tCubeName = $$$UPPER(pCubeName)
		Set tStatus = +$G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"status"))
		Set tExecTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"execTaskGroup"))
		Set tCellTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"cellTaskGroup"))
		If (tCubeName'="")&&(pQueryKey'="") {		// DTB167 - Run whenever the global references will be defined
			// DTB168 - Attempt to clear the reserved axes. Do not proceed if this fails!
			Set tSC = ##class(%DeepSee.Query.query).%ReleaseReservedAxes(tCubeName,pQueryKey)
			
			// DTB168 - Preserve the original text. This is used when determining if the query had an error in the last execution
			Set tText = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"query",1))
			
			Do ##class(%DeepSee.TaskMaster).%KillTasksForGroup(tCellTaskGroup)
			Kill $$$DeepSeeResultsGLVN(tCubeName,pQueryKey)
			Kill $$$DeepSeeTasksGLVN
			
			// DTB168 - Replace some values to signal the query has not had a successful execution
			Set $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"error") = $$$ERROR($$$GeneralError,"Query cancelled")
			Set:(tText'="") $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"query",1) = tText
			Set $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"status") = 100		// DTB167 - Query is complete, with an error
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Instance method version of <method>%GetQueryStatus</method>.
Method %GetStatus(Output pPercentComplete As %Double, Output pSC As %Status, Output pPendingResults As %Boolean) As %Integer
{
	Set pSC = $$$OK
	Set pPendingResults = 0
	Set tIsSlave = ($E(..%QueryKey,1,6)="SLAVE:")
	
	If ((..%Query.queryType="CREATE")||(..%Query.queryType="DROP")) {
		Set pPercentComplete = 100
		Quit 100
	}
	// + WAL049 -- don't update ..%QueryKey here
	Quit ..%GetQueryStatus(..%Cube,..%QueryKey,.pPercentComplete,.pSC,.pPendingResults)
	// - WAL049
}

/// Return the set of named parameters values defined by the query.
Method %GetParameterInfo(Output pParms) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill pParms
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%GetParameterInfo(.pParms)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Execute the current prepared query for this ResultSet.<br/>
/// If defined, <var>pParms</var> is an array of parameter values
/// subscripted by parameter name (case-insensitive). These are supplied
/// to the query and override the default values for any parameters
/// defined by the query.
Method %Execute(ByRef pParms) As %Status
{
	Set tSC = $$$OK
	Try {
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			Set tSC = ..%ExecuteSessionCommand()
			Quit
		}

		// JMD1381: wait until we get a valid key
		While (..%QueryKey="") {
			// if query key is present, then assume parameters are already executed
			Set tSC = ..%ExecuteParameters(.pParms)
			If $$$ISERR(tSC) Quit
			Set tIsSlave = ($E(..%QueryKey,1,6)="SLAVE:")
			If (tIsSlave) {
				// wait for master to complete
				Set ..%QueryKey = ""
				Hang 1
			}
			Else {
				Quit
			}
		}
		If $$$ISERR(tSC) Quit		// DTB306 - Quit with an error instead of only quitting the loop
		
		Set tSC = ..%ExecuteAxes()
		If $$$ISERR(tSC) Quit

		Set tSC = ..%ExecuteCells()
		If $$$ISERR(tSC) Quit
		
		If (..%Query.queryType = "DRILLTHROUGH") {
			Set tSC = ..%ExecuteListing()
			If $$$ISERR(tSC) Quit
		}

		// JMD1451: Test for pending results...
		Set tQueryStatus = ..%GetQueryStatus(..%Cube,..%QueryKey,.tPctComplete,.tQSC,.tPending)
		While (tPending) {
			Set tSC = ..%UpdatePendingResults(.tPending)
			If $$$ISERR(tSC) Quit
			Hang:tPending 1
		}
		
		Do ..%RunQueryAuditCode()  	// DTB065
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Perform a complete execution of the ResultSet using
/// background agents.<br/>
/// The query must be prepared before calling this method.<br/>
/// If defined, <var>pParms</var> is an array of parameter values
/// subscripted by parameter name (case-insensitive). These are supplied
/// to the query and override the default values for any parameters
/// defined by the query.<br/>
/// If <var>pWait</var> is true, wait for the query to complete execution before
/// returning.<br/>
/// If <var>pAxesOnly</var> is true, then only execute the axes for the query.
Method %ExecuteAsynch(Output pQueryKey As %String, ByRef pParms, pWait As %Boolean = 0, pAxesOnly As %Boolean = 0, pAxesQuery As %String = "") As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		
		// DTB071: Wait until we get a valid key if pWait is on. 
		Set tIsSlave=0
		While (..%QueryKey="") {
			// if query key is present, then assume parameters are already executed
			Set tSC = ..%ExecuteParameters(.pParms)
			If $$$ISERR(tSC) Quit
			Set tIsSlave = ($E(..%QueryKey,1,6)="SLAVE:")
			If (tIsSlave&&pWait) {
				// wait for master to complete
				Set ..%QueryKey = ""
				Hang 1
			}
			Else {
				Quit
			}
		}
		If $$$ISERR(tSC) Quit // + WAL144 -- actually quit (instead of just quitting the loop) if we got an error executing parameters
		
		// + WAL049 -- Move this out from %GetStatus
		If (tIsSlave&&'pWait) {
			// DTB071 - Release the slave status of this query since the master is finished and results are complete.
			Set ..%QueryKey = $E(..%QueryKey,7,*)
		}
		// - WAL049
		
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			// do not use async
			Set tSC = ..%ExecuteSessionCommand()
			Quit
		}
		ElseIf (..%Query.queryType = "DRILLTHROUGH") {
			If ('tIsSlave) {
				// force wait
				Set tSC = ..%Query.%ExecuteAsynch(1)
				If $$$ISERR(tSC) Quit

				Set tSC = ..%ExecuteListing()
				If $$$ISERR(tSC) Quit
			}
		}
		Else {
			If ('tIsSlave) {
				Set tSC = ..%Query.%ExecuteAsynch(pWait,,pAxesOnly,pAxesQuery)
				If $$$ISERR(tSC) Quit
			}
		}
		
		Set pQueryKey = ..%QueryKey
		
		// DTB065: Run the audit code if this is the full results execution
		If '$G(pAxesOnly) {
			Do ..%RunQueryAuditCode() 
		}	
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Apply the array of parameter values to the currently prepared query.
Method %ExecuteParameters(ByRef pParms) As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%ExecuteParameters(.pParms)
		If $$$ISERR(tSC) Quit
		
		Set ..%QueryKey = ..%Query.%QueryKey 
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	// DTB065: If query execution is complete at this stage, run the audit code on this query
	If (..%GetStatus()= 100) {
		Do ..%RunQueryAuditCode()  	
	}
	Quit tSC
}

/// Materialize the initial (pre-null-filtered) axes for this ResultSet.
Method %ExecuteAxes() As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%ExecuteAxes()
		// + WAL249 -- release reserved axes on status check if query complete
		If ((..%Query.cube'="") && (..%Query.%QueryKey'="")) {
			Do ##class(%DeepSee.Query.query).%ReleaseReservedAxes(..%Query.cube,..%Query.%QueryKey)
		}
		// - WAL249
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Calculate the contents of the result cells for this Result Set.
Method %ExecuteCells() As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"%ExecuteCells: Result set not prepared")
			Quit
		}
		Write:..%Trace "Execute Cells: ",!
		Set tSC = ..%Query.%ExecuteCells(..%Trace)
		// + WAL071 -- release reserved axes before quitting so others can evaluate the query 
		//             even if there was an error
		If (..%Query.parentQueryKey="") {
			Set tCubeIndex = $$$DeepSeeIndex(..%Query.cube)
			Set tQueryKey = ..%Query.%QueryKey
			Set tSC = ##class(%DeepSee.Query.query).%ReleaseReservedAxes(tCubeIndex,tQueryKey)		// DTB168 - Use API
		}
		// - WAL071
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}	
	Quit tSC
}

/// For a DRILLTHROUGH query, find the set of source ids that make up
/// the *first* cell in the results and compute the SQL statement needed
/// to fetch the request fields from the source table (either as 
/// specified in the query's RETURN clause or the default listing for the cube).
Method %ExecuteListing(pStoreFactBits As %Boolean = 0) As %Status [ Internal ]
{
	Set tSC = $$$OK
	// JMD1390
	Set tLock = 0
	Try {
		Set tMaxRows = ..%Query.%MaxListingRows
		Set tAxisCount = ..%GetAxisCount()
		Set tCube = $$$UPPER(..%Cube)
		Set tCubeIndex = ..%CubeKey
		Set tQueryKey = ..%QueryKey
		Set tSlicerQueryKey = ..%QueryKey  // WAL107
		Set tListingTable = ""
					
		// + WAL107 -- if this is a plugin, write the listing out to a different
		//             listing table. This way, if multiple plugin cells require the
		//             same listing we don't have to worry about locking and concurrency,
		//             we just look at the appropriate listing table
		If (..%IsPlugIn) {
			Set tQueryKey = tQueryKey_"PlugIn"_$I(^DeepSee.PlugInNonce)   
			Set ..%PlugInListingKey = tQueryKey		
		}
		// - WAL107
		
		// + WAL170
		Set tListingPlugInName = ..%PlugInContextName
		Set tListingPlugInProp = ..%PlugInContextProp
		Set tListingPlugInClass = ##class(%DeepSee.Utils).%GetKPIClass(tListingPlugInName)
		Set ..%PlugInContextName = ""
		Set ..%PlugInContextProp = ""
		// - WAL170

		// JMD1397 check for listing on compound cube
		// in this case, we have to execute multiple listings and UNION the results
		If (..%Query.%isCompound) {
			Set ..listingRows = 0
			Set tSQL = ""
			For n = 1:1:..%Query.compoundDrillthroughs.Count() {
				Set tMDX = ..%Query.compoundDrillthroughs.GetAt(n)

				// execute this drillthrough and get its listing SQL
				// pivot variables should already be resolved
				Set tRS2 = ##class(%DeepSee.ResultSet).%New()
				
				// + WAL208 -- pass the listing selection from the compound cube
				//             down to each constituent cube
				If (..listing'="") Set tSC = tRS2.%SetListing(..listing)
				If $$$ISERR(tSC) Quit
				// - WAL208
				
				Set tSC = tRS2.%PrepareMDX(tMDX)
				If $$$ISERR(tSC) Quit

				Set tSC = tRS2.%Execute()
				If $$$ISERR(tSC) Quit
				If (tRS2.%ListingSQL'="") {
					Set tSQL = tSQL _ $S(tSQL="":"",1:$C(13,10)_"UNION ALL"_$C(13,10)) _ tRS2.%ListingSQL
					Set ..listingRows = ..listingRows + tRS2.listingRows
				}
			}
			Set ..%ListingSQL = tSQL

			// prepare union listing query
			Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
			Set tStatement.%SelectMode = 1 // odbc-mode

			Set tSC = tStatement.%Prepare(..%ListingSQL)
			If $$$ISERR(tSC) {
				// log this error
			    Set tMsg = "Error in Listing query:"
			    Set tMsg = tMsg _ $C(13,10,9)_ ..%ListingSQL
			    Set tMsg = tMsg _ $C(13,10,9)_ $System.Status.GetErrorText(tSC)
			    Do ##class(%DeepSee.Utils).%WriteToLog("Listing",tMsg)
				Quit
			}
			Set ..%ListingResult = tStatement.%Execute()
			Quit
		}

		// this works as follows:
		// first we get the set of bits that describe the selected facts
		// then we get the source id for each fact and write it to 
		// the listing global
		// the listing global is mapped to a ListingTable (one per cube)
		// we then JOIN the sourceTable against ListingTable (using SQL with a subquery)
		// to get the listing rows.

		// JMD985: determine which facts are from list levels
		Set tFactCount = 0
		Set fn = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",""),1,tFactName)
		While (fn'="") {
			Set tFactCount = tFactCount+1
			If (tFactName'="") {
				Set tList = +$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tFactName,"list"))
				Set:tList tFactIsList(fn)=1
			}
			Set fn = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",fn),1,tFactName)
		}

		// JMD1390 block concurrent build of same listing
		Lock +^DeepSee.Listing(tCubeIndex,tQueryKey):10
		If ('$Test) {
			Set tSC = $$$ERROR($$$GeneralError,"Unable to get lock to create listing")
			Quit
		}
		Set tLock = 1

		// Kill prior listing, if any
		Kill $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey)
		Kill $$$DeepSeeListingBitGLVN(tCubeIndex,tQueryKey)

		Set tSourceType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))
		Set tSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
		If (tSourceClass="") {
			Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no source class: " _ tCube)
			Quit
		}

		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCube))
		If ('$zobjclassmethod(tCubeClass,"%CanDrillThrough")) {
			If (..%Query.%listingSource '= "facts") {
				// JMD906: allow DRILLFACTS in this case
				Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: this cube does not support drill through: " _ tCube)
				Quit
			}
		}

		Set tFactClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tCube, .tSC)
		If $$$ISERR(tSC) Quit

		Set tSourceTable = ""
		If (..%Query.%listingSource = "facts") {
			Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
		}
		Else {
			If (tSourceType = "persistent") {
				Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(tSourceClass)
				If (tSourceTable="") {
					Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no source table: " _ tCube)
					Quit
				}
			}
		}

		// + WAL107 -- tSlicerQueryKey is the original query key used to get listing context
		//             if we are in this listing as the result of a plugin, tQueryKey may be
		//             different from tSlicerQueryKey
		// JMD955: if the slicer filters out everything, then return no values
		Set tNoRecords = 0

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tSlicerQueryKey,"slicer")) // WAL107

		// see if slicer has any actual restrictions in it
		If (tSlicer'="") {
			// Get slicer key
			Set tSlicerKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tSlicerQueryKey,"axis",0)) // WAL107
			If (tSlicerKey'="") {
				Do ##class(%DeepSee.Query.Engine).%GetBranchesForSlicer(tCube, tSlicerKey, .tBranch,,.tReferencedFacts)
				If ('$D(tBranch)) {
					Set tSlicer = ""
					// JMD955: Return no records;
					If $D(tReferencedFacts) {
						Set tNoRecords = 1
					}
				}
			}
		}
		// - WAL107

		// compute "window" from page and page size
		// JMD1318: for first page, get everything-- could be a group by query
		If (..listingPage=1) {
			Set tStartRow = 1
			Set tEndRow = 100000000
			Set tFirstPage = 1
		}
		Else {
			Set tStartRow = ((..listingPage-1) * ..listingPageSize) + 1
			Set tEndRow = tStartRow + ..listingPageSize - 1
			Set tFirstPage = 0
		}

		// AxisCount=0 is a special case: SELECT FROM CUBE
		Set tReturnAll = (tAxisCount = 0)||tNoRecords

		If (('tReturnAll)||(tSlicer'="")) {
			// convert to listing table
			Set tListingClass = $P(tFactClass,".",1,$L(tFactClass,".")-1)_".Listing"
			Set tListingTable = ##class(%DeepSee.Utils).%GetSQLTableName(tListingClass)
			If (tListingTable="") {
				Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no listing table: " _ tCube)
				Quit
			}

			// number of fact properties in cube
			Set tFactCount = +$G($$$DeepSeeMetaGLVN("cubes",tCube,"factCount"))
			// JMD1453
			If (tFactCount="") {
				Set tSC = $$$ERROR($$$GeneralError,"Cube must be recompiled")
				Quit
			}

			// find set of relations for this cube (if any)
			// these will be processed using a join index
			Set r = $O($$$DeepSeeMetaGLVN("cubes",tCube,"rel#",""))
			While (r'="") {
				Set tRelation(r) = ""
				Set r = $O($$$DeepSeeMetaGLVN("cubes",tCube,"rel#",r))
			}

			// get "spec" for set of facts (from cell 1,1)
			// n.b., drillthrough only looks at top left cell
			Set tSpec = $Case(tAxisCount,
				0:..%GetValue(),
				1:..%GetOrdinalValue(1),
				:..%GetOrdinalValue(1,1))

			// JMD836: keys in spec are not in canonic form (e.g. "2|3|4&2")
			// fix them here
			// JMD955: test for bad list (e.g., "No Results")
			If '$ListValid(tSpec) {
				Set tSpec = ""
			}

			For p=1:1:$LL(tSpec) {
				// JMD985: do not canonize list facts
				// remember if there are ORs in the slicer, then tSpec is concatenated
				// for each branch!
				If '$D(tFactIsList((p#(tFactCount+1))-1)) {
					Set xp = $LG(tSpec,p)
					Set:(xp'="")&&($E(xp)'="!") $List(tSpec,p) = ##class(%DeepSee.Query.Engine2).%CanonizeAddr(xp)
				}
			}

			// break spec into pieces (each with one complete set of fact keys)
			// if there are multiple pieces, they are OR'd together
			Set tPieceCount = $LL(tSpec) / (tFactCount+1)
			For p=1:1:tPieceCount {
				Set x = (p-1)*(tFactCount+1)

				// JMD858 Test for empty spec; this means return all rows; (SELECT ALLMBR ON 0...)
				Set tSpec2 = $List(tSpec,x+1,x+tFactCount+1)
				Set tSpecNotEmpty = 0
				For px=1:1:$LL(tSpec2) {
					If ($LG(tSpec2,px)'="") {
						Set tSpecNotEmpty = 1
						Quit
					}
				}
				If (tSpecNotEmpty) {
					Set tSpecPart(p) = tSpec2
				}
				ElseIf (tSlicer'="") {
					// skip this spec
					Set tSpecPart(p) = ""
				}
				Else {
					Set tReturnAll = 1
					Quit
				}
			}

			If (('tReturnAll)||(tSlicer'="")) {
				Set tUseFacts = (..%Query.%listingSource = "facts")

				// loop over fact extent and apply filtering
				Set tCount = 0
				Set tChunk = $O($$$DeepSeeIndexGLVN(tCubeIndex,"$Fact",""),1,data)

				// JMD1318: ignore tMaxRows when fetching bits for first page
				// this makes it possible to run GROUP BY and other queries
				While ((tChunk '= "")&&(tFirstPage||pStoreFactBits||(tCount<tMaxRows))) {

					If ($BitFind(data,1)>0) {
						Kill tFullMask
						For p=1:1:tPieceCount {
							// JMD858: skip missing spec
							If (tSpecPart(p)="") {
								// set spec to extent mask
								Set tFullMask = data
							}
							Else {
								Set tMask = data
								For f = 1:1:tFactCount {
									Set k = $LG(tSpecPart(p),f+1)
									If (k'="") {
										If ($D(tRelation(f))&&($E(k)="@")) { // this is a relation
											Set k=##class(%DeepSee.Query.Engine2).%CanonizeRelationKey(k) // JSL4407
											// JMD1017
											Set khash = $S($L(k)<100:k,1:$ZCRC(k,7))
											If '$D(tMask) {
												Set tMask = $G($$$DeepSeeJoinGLVN(tCubeIndex,f,khash,tChunk))
											}
											Else {
												Set tMask = $BitLogic(tMask&$$$DeepSeeJoinGLVN(tCubeIndex,f,khash,tChunk))
											}
										}
										Else {
											// JMD1160: loop over & first
											For j = 1:1:$L(k,"&") {
												Set k2 = $P(k,"&",j)
												If (k2'="") {
													Kill tTest
													If (k2["|") {
														// OR
														For j2 = 1:1:$L(k2,"|") {
															Set k3 = $P(k2,"|",j2)
															If (k3'="") {
																Set tTest(j2) = tMask
																If ($E(k3)="!") {
																	// strip off marker and negate index
																	Set k3 = $E(k3,2,*)
																	Set tTest(j2) = $BitLogic(tTest(j2)&~$$$DeepSeeIndexGLVN(tCubeIndex,f,k3,tChunk))
																}
																Else {
																	Set tTest(j2) = $BitLogic(tTest(j2)&$$$DeepSeeIndexGLVN(tCubeIndex,f,k3,tChunk))
																}
															}
														}
														// fold branches
														Set tMask = ""
														Set jx = $O(tTest(""))
														If (jx'="") {
															Set tMask = tTest(jx)
															Set jx = $O(tTest(jx))
														}
														While (jx'="") {
															Set tMask = $BitLogic(tMask|tTest(jx))
															Set jx = $O(tTest(jx))
														}
													}
													Else {
														// test for NOT (!)
														If ($E(k2)="!") {
															// strip off marker and negate index
															Set k2 = $E(k2,2,*)
															Set tMask = $BitLogic(tMask&~$$$DeepSeeIndexGLVN(tCubeIndex,f,k2,tChunk))
														}
														Else {
															Set tMask = $BitLogic(tMask&$$$DeepSeeIndexGLVN(tCubeIndex,f,k2,tChunk))
														}
													}
												}
											}
										}
									}
									Set:$D(tMask)&($BitCount(tMask,1)=0) tMask=""
								} // f

								// OR pieces together
								If ('$D(tFullMask)&&$D(tMask)) {
									Set tFullMask = $G(tMask)
								}
								ElseIf ($D(tFullMask)&&$D(tMask)) {
									Set tFullMask = $BitLogic(tFullMask|tMask)
								}
							} // for p
						} // spec'=""


						// mask against extent
						If $D(tFullMask) {
							// JMD858: make tFullMask the lvar
							// (already masked)
							// Set tFullMask = $BitLogic(data&tFullMask)
						
							// BDB243: store bitset output
							Set:pStoreFactBits $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tChunk) = tFullMask
						}

						// emit ids
						Set tOffset = (tChunk-1)*64000
						Set tBit = $BitFind(tFullMask,1)
						While ((tBit > 0)&&(tFirstPage||(tCount<tMaxRows))) {
							Set tFactId = tBit+tOffset-1
							If (tUseFacts) {
								// JMD906: no need to convert ids
								Set tCount = tCount + 1
								If ((tCount>=tStartRow)&&(tCount<=tEndRow)) {
									Set $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,tFactId) = ""
								}
							}
							Else {
								// convert into sourceId via %sourceId reverse index
								Set tSourceId =  $G($$$DeepSeeIndexGLVN(tCubeIndex,"%sourceIdReverse",tFactId))

								If (tSourceId'="") {
									Set tCount = tCount + 1
									If ((tCount>=tStartRow)&&(tCount<=tEndRow)) {
										// insert directly into listing table the old-fashioned way!
										Set $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,tSourceId) = ""
									}
								}
							}
							Set tBit = $BitFind(tFullMask,1,tBit+1)
						}
					}
					Set tChunk = $O($$$DeepSeeIndexGLVN(tCubeIndex,"$Fact",tChunk),1,data)
				} // next chunk
			} // return All
		} // axis count

		// BDB251: make sure $$$DeepSeeListingBitGLVN is populated if tReturnAll=1 && tSlicer=""
		If (tReturnAll && (tSlicer="") && pStoreFactBits && 'tNoRecords) {
			// this is not particularly fast for large datasets, but the bitstring is
			// at least 100% correct and the code only gets executed if pStoreFactBits
			// was explicitly set to 1 by the invoking code
			set tFactId="", tPrevChunk=0, tBits=""
			for {
				set tFactId = $order($$$DeepSeeIndexGLVN(tCubeIndex,"%sourceIdReverse",tFactId))
				quit:tFactId=""
				
				set tChunk = (tFactId\64000)+1, tBitPos = (tFactId#64000)+1
				if (tChunk '= tPrevChunk) {
					set:tPrevChunk $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tPrevChunk) = tBits, tBits=""
					set tPrevChunk = tChunk
				}
				set $bit(tBits,tBitPos)=1
			}
			set:tPrevChunk $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tPrevChunk) = tBits
		}

		Set ..listingRows = $G(tCount,tMaxRows)
		Set:..listingRows>tMaxRows ..listingRows = tMaxRows		// JMD1318

		// ----------------------------------------------
		// now create query

		// tListingSourceClass is set if the cube defines a data connector for its listing
		Set tListingSourceClass = ""
		Set tCustomSQL = ""
		Set tSelectList = ""
		Set ..listingFormatList = ""

		// figure out what SQL or connector to use
		// $LISTING means use default in place
		Set ..%ListingFields = ""
		Set tSourceRowId = "%ID"

		// JMD1061 Use %GetDefaultListing method
		Set tListing = ..listing
		If (tListing="") {
			Set tListing = $classmethod(tCubeClass,"%GetDefaultListing")
		}
		If ((..%Query.%returnList '= "")&&($ZSTRIP($$$UPPER(..%Query.%returnList),"<>W")'="$LISTING")) {
			// explicit listing in query
			Set tSelectList = ..%Query.%returnList
		}
		ElseIf (..%Query.%listingSource = "facts") {
			// query against fact table (not source table)
			Set tSelectList = "%ID"
		}
		ElseIf (tListing'="") {
			// use named listing in cube
			// test if user holds resource for this listing
			
			// DTB082 - Determine whether this listing definition exists, and if so where the metatdata is stored
			// DTB130 - look for listing groups according to the generic cube name. Standard listings are stored in the 
			// cube definition and can be version dependent--continue looking for those according to the version name
			//   listings in the versioned cube name if it exists.
			Set tGenericCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(tCube)
			If $D($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing)) {
				Set tListingExists = 1
				Set tListingMeta="cube"
				Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"resource"))
			} ElseIf $D($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing)){								// DTB130
				Set tListingExists = 1
				Set tListingMeta="group"
				Set tResource = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"resource"))			// DTB130
			} Else {
				// Non-existent listing didn't trigger the error message
				Set tListingExists = 0
			}
			
			If tListingExists&&((tResource="")||($System.Security.Check(tResource,"USE"))) {
				If tListingMeta="cube" {
					Set tSelectList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"fieldList"),tSourceRowId)
					Set tCustomSQL = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"sql"))
					Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"sourceClass"))
					Set ..listingFormatList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"formatList"))
				} Else {
					// DTB082 - Listing is defined in a listing group
					// DTB130 - Switch to generic cube name
					Set tSelectList = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"fieldList"),tSourceRowId)
					Set tCustomSQL = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"sql"))
					Set tListingSourceClass = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"sourceClass"))
					Set ..listingFormatList = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"formatList"))
				}

			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Listing does not exist or you do not hold USE permission for it")
				Quit
			}
		}
		Else {
			// get default for cube
			Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingResource"))
			If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
				Set tSelectList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListing"),tSourceRowId)
				Set tCustomSQL = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSQL"))
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSourceClass"))
				Set ..listingFormatList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingFormat"))
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Listing does not exist or you do not hold USE permission for it")
				Quit
			}
		}

		// if true, restrict listing using an IN clause otherwise use a local subquery
		Set tUseINList = 0

		// use primary data connector for listing if none specified
		If (tListingSourceClass="") {
			Set tSourceType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))
			If (tSourceType="dataconnector") {
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
			}
		}

		If (tListingSourceClass '= "") {
			// data connector
			Set tSupportsIDs=($$$defMemberKeyGet(tListingSourceClass,$$$cCLASSparameter,"SUPPORTSIDLIST",$$$cPARAMdefault)'="")
			If ('tSupportsIDs) {
				Set tSC = $$$ERROR($$$GeneralError,"Data Connector does not support listings")
				Quit
			}

			Set ..%ListingSQL = "{" _ tListingSourceClass _ "}"
			/* JMD1309: there appears to be no need to create a list of fields:
						we can get it from the result set meta data
			If (tSelectList'="") {
				For p2=1:1:$L(tSelectList,",") {
					Set tFld = $ZSTRIP($P(tSelectList,",",p2),"<>W")
					Set:tFld'="" ..%ListingFields = ..%ListingFields_$LB(tFld)
				}
			}
			*/
		}
		ElseIf (tCustomSQL = "") {
			Set tExternalTable=($$$defMemberKeyGet(tSourceClass,$$$cCLASSparameter,"CONNECTION",$$$cPARAMdefault)'="")
			If (tExternalTable) {
				Set tUseINList = 1
				Set tMaxRows = 1000
				// there is a hard limit on external listings
				// to avoid xDBC query problems
			}
			// create SQL query
			// add names to the select list
			// add qualifier to names in select list
			// unless name is already qualified
			Set tSELECT = ""
			For n=1:1:$L(tSelectList,",") {
				Set f = $ZSTRIP($P(tSelectList,",",n),"<>W")
				Set:f'="" tSELECT = tSELECT _ $S(tSELECT="":"",1:",") _ $S(($E(f,1)="("):f,$IsValidNum(+f):f,($$$UPPER(f))["SOURCE.":f,1:"source."_f)
			}

			Set tORDER = ""
			If (..%Query.%returnList '= "") {
				Set tOrderList = ..%Query.%orderList
			}
			ElseIf (..%Query.%listingSource = "facts") {
				Set tOrderList = ..%Query.%orderList
			}
			ElseIf (..listing'="") {
				// use named listing in cube
				If tListingMeta="cube" {
					Set tOrderList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",..listing,"orderBy"))
				} Else {
					// DTB082 - a listing group defines the ORDER BY clause
					Set tOrderList = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",..listing,"orderBy"))
				}

			}
			Else {
				Set tOrderList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingOrder"))
			}

			// add names to order list
			// qualify names if needed
			Set tORDER = ""
			For n=1:1:$L(tOrderList,",") {
				Set f = $ZSTRIP($P(tOrderList,",",n),"<>W")
				Set:f'="" tORDER = tORDER _ $S(tORDER="":"",1:",") _ $S(($E(f,1)="("):f,$IsValidNum(+f):f,($$$UPPER(f))["SOURCE.":f,1:"source."_f)
			}
			Set:tORDER'="" tORDER = " ORDER BY " _ tORDER

			Set tWHERE = ""
			Set tFROM = tSourceTable_" source"
			If (('tReturnAll)||(tSlicer'="")) {
				If (tUseINList) {
					Set tIDCount = 0
					Set tDone = 0

					Set tINLIST = ""
					Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,""))
					While (k'="") {
						Set tIDCount = tIDCount + 1
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ "("_$Replace($$$quote(k),"""","'")_")"
						If (tIDCount>=tMaxRows) {
							Quit
						}
						Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,k))
					}
					If (tINLIST'="") {
						Set tWHERE = " WHERE source."_tSourceRowId_" IN ("_tINLIST_") "
					}
					Else {
						// no records
						Set tWHERE = " WHERE 1=0"
					}
				}
				Else {
					Set tWHERE = " WHERE source."_tSourceRowId_" IN (SELECT _DSsourceId FROM " _ tListingTable _ " WHERE _DSqueryKey = '"_tQueryKey_"')"
				}
			}
			// + WAL170 -- if the listing is run on a cell that gets it's value from a PlugIn, run the plugin so the user
			//             can filter the listing with the plugin logic if desired
			//             This is done by passing back a new "INLIST"
			If (tListingPlugInName'="") {
				Set tListingSource = $S((..%Query.%listingSource = "facts"):"FacTable",1:"SourceTable")
				Set tKPI = $classmethod(tListingPlugInClass,"%New")
				Set tListingFields = tKPI.%OnGetListingFields()
			
				Merge tOldDsContext = %dsCellContext
				Kill %dsCellContext
				Merge %dsCellContext = ..%PlugInFilters
				
				// + WAL262 -- pass along plugIn arguments from axis
				Merge %dsPlugInArguments = ..%PlugInArguments
				// - WAL262
								
				Set tListingPlugInIDList = ""
				Set tdsKPISync = +$G(%dsKPISync)
				Set %dsKPISync = 1
				Set tSC = tKPI.%OnLoadModel()
				If ('tdsKPISync) {
					Set %dsKPISync = tdsKPISync
				}
				Merge %dsCellContext = tOldDsContext
				
				Merge tListingPlugInIDList = tKPI.%data("IDLIST",tListingPlugInProp)
				If $$$ISERR(tSC) {
					Quit	
				}
				Set tINLIST = ""
				Set tIDCount = 0
				If ($O(tListingPlugInIDList(""))'="") {
					Set k = $O(tListingPlugInIDList(""))
					While (k'="") {
						Set tIDCount = tIDCount + 1
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ "("_$Replace($$$quote(k),"""","'")_")"
						If (tIDCount>=tMaxRows) {
							Quit
						}
						Set k = $O(tListingPlugInIDList(k))	
					}
				}
				Set tListingId = tSourceRowId
				If (..%Query.%listingSource = "facts") {
					Set tListingId = "%sourceId"	
				}
				Set:(tINLIST'="") tWHERE = " WHERE source."_tListingId_" IN ("_tINLIST_") "
			}
			// - WAL170
			
			If (tWHERE = "") {
				// special case of returning ALL source rows
				// see if there is a loadRestriction in play
				Set tOnProcessFact = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"onProcessFact"))
				Set tRestrict = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"buildRestriction"))
				
				If (..%Query.%listingSource '= "facts") {
					If tOnProcessFact'="" {
						// DTB119 - If %OnProcessFact was used, limit source IDs using the fact table
						Set tFactTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
						Set tWHERE = " WHERE source."_tSourceRowId_" IN (SELECT %sourceId FROM " _ tFactTable _ ")"
					}
					ElseIf (tRestrict'="") {
						// JMD942
						Set tWHERE = " WHERE " _ tRestrict
					}
				}
			}

			Set tTOP = ""
			If ('tExternalTable) {
				Set tTOP = "TOP "_+tMaxRows_" "
			}

			// JMD1127 replace $$$TEXT[ in SELECT
			//set tSC = ..RewriteQueryTag(.tSELECT, "$$$TEXT", "##class(%DeepSee.UserPortal.Utils).%ResolveText(""$$$""_$tr(""$$$1"",""""""'"")_""/""_$tr(""$$$2"",""""""'""))",,,, 1)
			//quit:$$$ISERR(tSC)
			Set tIKPos = $Find(tSELECT, "$$$TEXT[")
			While (tIKPos) {
				Set tParams = $E(tSELECT, tIKPos, $Find(tSELECT, "]", tIKPos)-2)
				Set tString = $Translate($Piece(tParams,",",1), """'")
				Set tDomain = $Translate($Piece(tParams,",",2), """'")
				If (tDomain'="") {
					Set tString = tString_"/"_tDomain
				}
				Set tString =  ##class(%DeepSee.UserPortal.Utils).%ResolveText("$$$"_tString)
				Set tSELECT = $E(tSELECT,1,tIKPos-9) _ tString _ $E(tSELECT,tIKPos+$length(tParams)+1,*)
				Set tIKPos = $Find(tSELECT, "$$$TEXT[")
			}
			
			// BDB383: replace $$$PMML model references ($$$PMML[defClass,modelname,feature])
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$PMML", "%DeepSee_PMML_Utils.DeepSee_RunModelForListing('"_tCube_"', source.%ID, '$$$1', '$$$2', '$$$3')", $lb(,,"predictedValue"))
			quit:$$$ISERR(tSC)

			// BDB168: support for iKnow summaries (BDB238: more than 1 per query)
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$IKSUMMARY", "%iKnow_DeepSee.CubeUtils_GetSummary('"_tCube_"', '$$$1', source.%ID, $$$2)", $lb(,5), "$$$1 (summary)")
			quit:$$$ISERR(tSC)
			
			// BDB296: support for iKnow measure value popup
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$IKLINK", "'''"_tCube_"'',''$$$1'','''||source.%ID||''''",, "$$$1", "___IKLINK")
			quit:$$$ISERR(tSC)
			
			// JMD955
			If (tNoRecords) {
				Set tWHERE = " WHERE (1=0) "
			}

			Set ..%ListingSQL = "SELECT "_tTOP_tSELECT_" FROM "_tFROM_tWHERE_tORDER
		}
		Else {
			// custom sql statement
			Set tWHERE = ""
			Set tFROM = tSourceTable_" source"

			If (('tReturnAll)||(tSlicer'="")) {
				If (tUseINList) {
					// in this case, impose a hard limit on the size of the IN list!
					Set tINLIST = ""

					Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,""))
					While (k'="") {
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ $Replace($$$quote(k),"""","'")
						Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,k))
					}

					If (tINLIST'="") {
						Set tWHERE = " source."_tSourceRowId_" IN ("_tINLIST_") "
					}
				}
				Else {
					Set tWHERE = " source."_tSourceRowId_" IN (SELECT _DSsourceId FROM " _ tListingTable _ " WHERE _DSqueryKey = '"_tQueryKey_"') "
				}
			}
			Else {
				// +DTB231 - special case of returning ALL source rows
				// see if there is a loadRestriction in play
				Set tOnProcessFact = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"onProcessFact"))
				Set tRestrict = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"buildRestriction"))
				
				If (..%Query.%listingSource '= "facts")&&(tCustomSQL["$$$SOURCE") {
					// This restriction is only needed if the listing is on the source table
					// AND the query is using the source table provided by the $$$SOURCE token
					If tOnProcessFact'="" {
						// If %OnProcessFact was used, limit source IDs using the fact table
						Set tFactTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
						Set tWHERE = " source."_tSourceRowId_" IN (SELECT %sourceId FROM " _ tFactTable _ ") "
					}
					ElseIf (tRestrict'="") {
						// JMD942
						Set tWHERE = tRestrict
					}
					Else {
						Set tWHERE = " (1=1) "
					}
				}
				Else {
					Set tWHERE = " (1=1) "
				}
				// -DTB231
			}

			Set tCustomSQL = $Replace(tCustomSQL,"$$$SOURCE",tFROM)
			Set tCustomSQL = $Replace(tCustomSQL,"$$$RESTRICT",tWHERE)
			
			// JMD1127: replace $$$TEXT[] parameters for listings
			//set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$TEXT", "##class(%DeepSee.UserPortal.Utils).%ResolveText(""$$$""_$tr(""$$$1"",""""""'"")_""/""_$tr(""$$$2"",""""""'""))",,,, 1)
			//quit:$$$ISERR(tSC)
			Set tIKPos = $Find(tCustomSQL, "$$$TEXT[")
			While (tIKPos) {
				Set tParams = $E(tCustomSQL, tIKPos, $Find(tCustomSQL, "]", tIKPos)-2)
				Set tString = $Translate($Piece(tParams,",",1), """'")
				Set tDomain = $Translate($Piece(tParams,",",2), """'")
				If (tDomain'="") {
					Set tString = tString_"/"_tDomain
				}
				Set tString =  ##class(%DeepSee.UserPortal.Utils).%ResolveText("$$$"_tString)
				Set tCustomSQL = $E(tCustomSQL,1,tIKPos-9) _ tString _ $E(tCustomSQL,tIKPos+$length(tParams)+1,*)
				Set tIKPos = $Find(tCustomSQL, "$$$TEXT[")
			}
			
			// BDB383: replace $$$PMML model references ($$$PMML[defClass,modelname,feature])
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$PMML", "%DeepSee_PMML_Utils.DeepSee_RunModelForListing('"_tCube_"', source.%ID, '$$$1', '$$$2', '$$$3')", $lb(,,"predictedValue"))
			quit:$$$ISERR(tSC)
			
			// BDB168: replacing parameters for iKnow Listings (BDB238: more than 1 per query)
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$IKSUMMARY", "%iKnow_DeepSee.CubeUtils_GetSummary('"_tCube_"', '$$$1', source.%ID, $$$2)", $lb(,5), "$$$1 (summary)")
			quit:$$$ISERR(tSC)
			
			// BDB296: support for iKnow measure value popup
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$IKLINK", "'''"_tCube_"'',''$$$1'','''||source.%ID||''''",, "$$$1", "___IKLINK")
			quit:$$$ISERR(tSC)
			
			Set ..%ListingSQL = tCustomSQL
		}

		// prepare result set
		If (tListingSourceClass '= "") {
			Set tConnector = $zobjclassmethod(tListingSourceClass,"%New")
			If ('tConnector.%IsA("%DeepSee.DataConnector")) {
				Set tSC = $$$ERROR($$$GeneralError,"Source class is not a DataConnector: " _ tListingSourceClass)
				Quit
			}

			// pass restriction information to connector
			If (tListingTable'="") {
				Set tSC = tConnector.%SetMode("idlist")
				If $$$ISERR(tSC) Quit

				Set tSC = tConnector.%SetIdList(tListingTable,tQueryKey,tCubeIndex)
				If $$$ISERR(tSC) Quit
			}

			// Run dataconnector in odbc-mode
			Set dcm = $ZU(115,5,1)

			Kill tParms
			Set ..%ListingResult = tConnector.%Execute(.tParms,.tSC)
			Set x = $ZU(115,5,dcm)
			If $$$ISERR(tSC) Quit
		}
		Else {
			// sql

			// invoke callback
			Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCube))
			Set tSC = $zobjclassmethod(tCubeClass,"%OnExecuteListing",..%ListingSQL)
			If $$$ISERR(tSC) Quit

			// prepare listing query
			Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
			Set tStatement.%SelectMode = 1 // odbc-mode

			Set tSC = tStatement.%Prepare(..%ListingSQL)
			If $$$ISERR(tSC) {
				// log this error
			    Set tMsg = "Error in Listing query:"
			    Set tMsg = tMsg _ $C(13,10,9)_ ..%ListingSQL
			    Set tMsg = tMsg _ $C(13,10,9)_ $System.Status.GetErrorText(tSC)
			    Do ##class(%DeepSee.Utils).%WriteToLog("Listing",tMsg)
				Quit
			}
			Set ..%ListingResult = tStatement.%Execute()
		}
		Set $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"plan",$I($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"plan"))) = $LB("listing",tCube,..%ListingSQL)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	// JMD1390
	If (tLock) {
		Lock -^DeepSee.Listing(tCubeIndex,tQueryKey)
	}

	Quit tSC
}

/// Replaces a "tag" in a listing query <var>pSQL</var> (fieldList or straight SQL), using the 
/// string in <var>pRewrite</var>. The tag (such as $$$IKSUMMARY) can have zero or more parameters
/// in square brackets, which will be used to replace $$$1, $$$2, etc markers in <var>pRewrite</var>,
/// defaulting to the corresponding positions in <var>pDefaultParams</var> if no value is supplied
/// with the tag. <var>pRewrite</var> is supposed to contain appropriate quotes, as surrounding
/// single and double quotes in the tag itself will be removed.
/// If <var>pDefaultAlias</var> is non-null, it will be appended as the column alias for the rewrite
/// expression. This alias can also contain $$$1, $$$2, etc markers.
/// If <var>pAliasPrefix</var> is set, it will be prepended to any existing (or default) alias.
/// If <var>pStatic</var>=1, the rewrite code is considered to be COS code and run once, with its
/// result then replacing the tag in the query.
ClassMethod RewriteQueryTag(ByRef pSQL As %String, pTagName As %String, pRewrite As %String, pDefaultParams As %List = "", pDefaultAlias As %String = "", pAliasPrefix As %String = "", pStatic As %Boolean = 0) As %Status [ Internal ]
{
	set tSC = $$$OK
	try {
		set tTagLength = $length(pTagName)
		set tParamCount = $length(pRewrite_" "_pDefaultAlias,"$$$")-1
		
		while 1 {
			// find the next occurrence of pTagName
			set tPos = $find(pSQL, pTagName)
			quit:'tPos
			set tSqlLength = $length(pSQL), tStartPos = tPos-tTagLength-1
			
			// locate closing "]" and parameter list
			kill tParams
			set tParams = 0
			if ($e(pSQL,tPos)="[") {
				set tQuotes = "", tLastParamStart = tPos+1
				while ($i(tPos)<=tSqlLength) {
					set tChar = $e(pSQL,tPos)
					
					if (tChar=tQuotes) {
						if $e(pSQL,tPos+1)=tQuotes {
							// double quote!
							set tPos = tPos+1
							continue
						} else {
							// end of a quoted string
							set tQuotes = ""
							continue
						}
					} elseif (tChar="""") || (tChar="'") {
						// start of a quoted string
						set tQuotes = tChar
						continue
					}
					
					// skip if we're in a quoted string
					continue:tQuotes'=""
					
					// parameter ends at "]" or ","
					if (tChar = "]") || (tChar=",") {
						
						// get rid of surrounding quotes, these should be taken care of by pRewrite
						set tParam = $zstrip($e(pSQL,tLastParamStart,tPos-1),"<>W")
						if ($e(tParam)="'") && ($e(tParam,*)="'") {
							set tParam = $e(tParam,2,*-1)
						} elseif ($e(tParam)="""") && ($e(tParam,*)="""") {
							set tParam = $e(tParam,2,*-1)
						}
						set tParams($i(tParams)) = tParam
						
						quit:(tChar="]")
						set tLastParamStart = tPos+1
					}
					
				}
				set tEndPos = tPos+1
			} else {
				set tEndPos = tPos
			}
			
			// alias processing
			if (pDefaultAlias'="") || (pAliasPrefix'="") {
				if ($e(pSQL,tPos)=",") {
					// no trailing space, parameters or alias
					set tAlias = ""
				} else {
					set tQuotes = "", tAliasStart = tPos+1
					while ($i(tPos)<=tSqlLength) {
						set tChar = $e(pSQL,tPos)
						
						if (tChar=tQuotes) {
							if $e(pSQL,tPos+1)=tQuotes {
								// double quote!
								set tPos = tPos+1
								continue
							} else {
								// end of a quoted string
								set tQuotes = ""
								continue
							}
						} elseif (tChar="""") {
							// start of a quoted string
							set tQuotes = tChar
							continue
						}
						
						// skip if we're in a quoted string
						continue:tQuotes'=""
						
						quit:tChar=","
						quit:$e(pSQL,tPos,tPos+4)="FROM "
					}
					set tAliasEnd = tPos-1
					
					set tAlias = $zstrip($e(pSQL, tAliasStart, tAliasEnd), "<>W")
					
					// get rid of "As" keyword
					set:$$$UPPER($e(tAlias,1,3))="AS " tAlias = $zstrip($e(tAlias,4,*), "<>W")
					
					// get rid of alias quotes. we'll restore them later if required
					set:($e(tAlias)="""")&&($e(tAlias,*)="""") tAlias = $zstrip($e(tAlias,2,*-1), "<>W")
					
					set tEndPos = tAliasEnd+1
				}
				
				if (tAlias="") {
					set tAlias = pDefaultAlias
				}
				
				if (pAliasPrefix'="") {
					set tAlias = pAliasPrefix_$s(tAlias="":"", 1:" "_tAlias)
				}
				
				set:$f(tAlias," ") tAlias = $$$QUOTE(tAlias)
				set:tAlias'="" tAlias = " As "_tAlias
			} else {
				set tAlias = ""
			}
			
			set tRewrite = pRewrite
			set:tParams>tParamCount tParamCount = tParams
			for i = 1:1:tParamCount {
				set tParam = $g(tParams(i),$lg($g(pDefaultParams),i))
				set tRewrite = $replace(tRewrite, "$$$"_i, tParam)
				set tAlias = $replace(tAlias, "$$$"_i, tParam)
			}
			
			if (pStatic) {
				xecute ("(tValue) { set tValue = "_tRewrite_" }", .tValue)
				set tRewrite = tValue
			}
			
			set pSQL = $e(pSQL,1,tStartPos) _ " "_tRewrite_tAlias_" " _ $e(pSQL,tEndPos,*)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
}

/// Perform the work of a CREATE or DROP statement.
Method %ExecuteSessionCommand() As %Status [ Internal, Private ]
{
	Set tSC = $$$OK
	Try {
		If (..%Query.queryType = "CREATE") {
			// apply definition
			If (..%Query.%target = "set") {
				Set tKey = ""
				Set tSet = ..%Query.namedSets.GetNext(.tKey)
				While (tKey '= "") {
					// add definition to session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Set tInfo = $LB(tSet.name,tSet.definition)
						Set $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"namedSets",tKey) = tInfo
					}
					Set tSet = ..%Query.namedSets.GetNext(.tKey)
				}
			}
			ElseIf (..%Query.%target = "member") {
				Set tKey = ""
				Set tSet = ..%Query.calculatedMembers.GetNext(.tKey)
				While (tKey '= "") {
					// add definition to session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Set tInfo = $LB(tSet.parentDimension,tSet.originalName,tSet.definition)
						Set $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"calcMbrs",tKey) = tInfo
					}
					Set tSet = ..%Query.calculatedMembers.GetNext(.tKey)
				}
			}
		}
		ElseIf (..%Query.queryType = "DROP") {
			If (..%Query.%target = "set") {
				Set tKey = ..%Query.%targetKey
				If (tKey '= "") {
					// remove definition from session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Kill $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"namedSets",tKey)
					}
				}
			}
			ElseIf (..%Query.%target = "member") {
				Set tKey = ..%Query.%targetKey
				If (tKey '= "") {
					// remove definition from session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Kill $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"calcMbrs",tKey)
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Return number of visible nodes within the given axis (1-based).
Method %GetAxisSize(pAxis As %Integer) As %Integer
{
	Quit +$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"leaf",pAxis))
}

/// Return the count of columns in results table.
Method %GetColumnCount() As %Integer
{
	// Method added by DTB281
	Quit $S(..%GetAxisSize(1):..%GetAxisSize(1),1:1)
}

/// Return the count of rows in results table.
Method %GetRowCount() As %Integer
{
	// Method added by DTB281
	Quit $S(..%GetAxisSize(2):..%GetAxisSize(2),1:1)
}

/// Return number of axes within the result set (not including the slicer).
/// Returns 0 if the query has not been prepared and had its
/// axes executed.<br/>
/// On return, <var>pInfo</var> will contain array of axis number (1-based)
/// to axis top node number.
Method %GetAxisCount(Output pInfo As %Integer) As %Integer
{
	Kill pInfo
	Set tCount = 0
	Set tCube = ..%CubeKey
	Set tKey = ..%QueryKey

	If ((tCube'="")&&(tKey'="")&&($D($$$DeepSeeResultsGLVN(tCube,tKey,"size"),size))) {
		For n = 1:1:$LL(size) {
			Set tInfo = $LG(size,n)
			Set tType = $LG(tInfo,1)
			If (tType = "axis") {
				Set tCount = tCount + 1
				Set pInfo(tCount) = $LG(tInfo,2)
			}
		}
	}
	
	Set ..%AxisCount = tCount
	Quit tCount
}

/// Return true if the current query has to be tested for cell format overrides.
Method %HasCellFormatOverride() As %Boolean
{
	Quit ''$D($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"cmbrMap"))
}

/// Determine if the format for the given cell has been overridden (such as by
/// currentMember substitution) and return it.
/// <var>pCell...</var> contains the ordinal address of the cell.
Method %GetCellFormatOverride(pCell...) As %String
{
	Set tFormat = ""
	Set tAxisCount = ..%AxisCount
	If (tAxisCount="") {
		Set tAxisCount = ..%GetAxisCount()
	}
	Set tCube = ..%CubeKey
	Set tMissing = 0

	For a = 1:1:tAxisCount {
		// If no cell specified, use first cell along axis
		Set tCell = $S($G(pCell(a))'="":pCell(a),1:$O($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,"")))

		If (tCell'="") {
			// find node number for cell
			Set tNode(a) = $G($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,tCell))
		}

		If ((tCell="") || (tNode(a)="")) {
			Set tMissing = 1
			Quit
		}
	}

	If ('tMissing) {
		Set tFormat = $LG($G($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"cmbrMap",tNode(1),tNode(2),0)),12)
	}
	Quit tFormat
}

/// Get the value of the cell specified by the ordinal cell numbers 
/// <var>pCell1</var>, <var>pCell2</var>...<br/>
/// A cell number is the ordinal number of a cell along its axis.<br/>
/// The column axis is axis number 1, the row axis is axis number 2 and so on.<br/>
/// If the result has more dimensions than are provided, or if values are omitted, then the
/// first cell along each additional dimension is used.
Method %GetOrdinalValue(pCell...) As %String
{
	Set tAxisCount = ..%AxisCount
	If (tAxisCount="") {
		Set tAxisCount = ..%GetAxisCount()
	}
	Set tCube = ..%CubeKey
	Set tValue = ""
	Set tMissing = 0

	For a = 1:1:tAxisCount {
		// If no cell specified, use first cell along axis
		Set tCell = $S($G(pCell(a))'="":pCell(a),1:$O($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,"")))

		If (tCell'="") {
			// find node number for cell
			Set tNode(a) = $G($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,tCell))
		}

		If ((tCell="") || (tNode(a)="")) {
			Set tMissing = 1
			Quit
		}
	}

	If ('tMissing) {
		Set tValue = $Case(tAxisCount,
			0:..%GetValue(),
			1:..%GetValue(tNode(1)),
			2:..%GetValue(tNode(1),tNode(2)),
			3:..%GetValue(tNode(1),tNode(2),tNode(3)),
			4:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4)),
			5:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5)),
			6:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5),tNode(6)),
			7:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5),tNode(6),tNode(7)),
			:"")
	}

	Quit tValue
}

/// Get the value of the cell specified by the node numbers 
/// <var>pNode1</var>, <var>pNode2</var>...
Method %GetValue(pNode...) As %String
{
	// count nodes
	Set tCount = 0
	Set n = $O(pNode(""))
	While (n'="") {
		Set tCount = tCount + 1
		Set n = $O(pNode(n))
	}
	Set tValue = $Case(tCount,
		0:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0)),
		1:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1))),
		2:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2))),
		3:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3))),
		4:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4))),
		5:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5))),
		6:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5),pNode(6))),
		7:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5),pNode(6),pNode(7))),
		:"")
	Quit tValue
}

/// Find the axis label(s) for the item with ordinal position
/// <var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
/// Returns, via <var>pLabel</var> an array of labels associated with the item
/// from the most specific to the most general.<br/>
/// The return value is the number of labels returned.<br/>
/// Also returns, by reference the format and solve order for the label (higher solve order
/// takes precedence over lower and is used to determine which axis should supply the format for
/// a cell).
/// <var>pClasses</var> an array of classes associated with the item
Method %GetOrdinalLabel(Output pLabel As %String, pAxis As %Integer, pPosition As %Integer, Output pFormat As %String, Output pSolveOrder As %Integer, Output pStyle As %String, Output pHeaderStyle As %String, Output pClasses As %String) As %Integer
{
	Set tSC = $$$OK
	Kill pLabel
	Set pFormat = ""
	Set pStyle = ""
	Set pHeaderStyle = ""
	Set pSolveOrder = 0
	Set tLabelCount = 0

	Try {
		// DTB248 - Call API to collect relevant nodes for this label
		Set tSC = ..%GetOrdinalLabelNodes(pAxis,pPosition,.tNodes)
		If $$$ISERR(tSC) Quit
		
		// DTB248 - Go back through the labels last-to-first with new skip information
		Set tNodeNo=$O(tNodes(""),-1,tNode)
		While tNodeNo'="" {
			Set tType = $LG(tNode,1)
			Set tLabel = $LG(tNode,5)
			Set tSolveOrder = +$LG(tNode,15)
			//+ JSL4456
			Set tDimNo = +$LG(tNode,9)
			Set tHierNo = +$LG(tNode,10)
			Set tLevelNo = +$LG(tNode,11)
			//- JSL4456

			// JMD909
			Set tFormat = $LG(tNode,12)

			// JMD1375 first format takes precedence
			Set:(tFormat'="")&&(pFormat="") pFormat = tFormat

			Set:tSolveOrder>0 pSolveOrder = tSolveOrder
			If (tLabel'="") {
				Set tLabelCount = tLabelCount + 1
				Set pLabel(tLabelCount) = $LG(tNode,5)
				Set tClass=$LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(..%GetCubeName()),"mbr#",tDimNo,tHierNo,tLevelNo)),6) // class is 6th position JSL4456
				Set pClasses(tLabelCount) = tClass // JSL4456
				Set tStyle = $LG(tNode,18)
				Set:tStyle'="" pStyle = tStyle
				Set tHeaderStyle = $LG(tNode,19)
				Set:tHeaderStyle'="" pHeaderStyle = tHeaderStyle
			}
			Set tNodeNo=$O(tNodes(tNodeNo),-1,tNode)
		}
	}
	Catch ex {
		// Swallow the error - no status is returned in this method
	}
	
	Quit tLabelCount
}

/// Examine the axis nodes(s) for the item with ordinal position <var>pPosition</var> within axis <var>pAxis</var>,
/// and build an array of nodes contributing to the label at this ordinal position along the axis. The collection of 
/// nodes is returned in the format<br>
/// <var>pNodeArray</var>(nodeNumber) = $LB(nodeInfo).
Method %GetOrdinalLabelNodes(pAxis As %Integer, pPosition As %Integer, ByRef pNodeArray) As %Status [ Internal ]
{
	// Method added by DTB248
	Set tSC = $$$OK
	Kill pNodeArray
	
	If ('$D(pAxis)||'$D(pPosition)) Quit
	Try {
		Set tCubeIndex = ..%CubeKey
		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"axis",pAxis))
		Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,pPosition))
		
		// Collect the nodes from the axis global, noting the existence of any orsets.
		While ((tAxisKey'="")&&(tNodeNo'="")) {
			Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tType = $LG(tNode,1)
			Set tParent = $LG(tNode,4)
			
			If (tType = "axis") {
				Quit
			}
			ElseIf (tType="orset") {
				// Note that there is an orset in the label chain
				Set tOrsetLabelNodes(tNodeNo) = ""
			}
			Set pNodeArray(tNodeNo) = tNode
			Set tNodeNo = tParent
		}
		
		// ORSET processing - Traverse the array of nodes contributing to the label. 
		// For each orset encountered, note that all but the final label in that orset should be removed.
		If $D(tOrsetLabelNodes) {
			Set tCurrentOrset = 0
			Set tNodeNo = $O(tOrsetLabelNodes(""))
			Set tNode = pNodeArray(tNodeNo)
			
			While tNodeNo'="" {
				Set tType = $LG(tNode,1)
				Set tParent = $LG(tNode,4)
				If (tType="orset") {
					// Note that an orset has begun, and which node is its root
					Set tHideLabel(tNodeNo) = ""
					Set tCurrentOrset = tNodeNo
				}
				ElseIf (tCurrentOrset)  {
					If '((tType="mbr")||(tType="orset")||(tType="ortuple")) {
						// This node is not a legal member of orset, and so its parent is the final orset member
						Set tCurrentOrset = 0
						Kill tHideLabel(tParent)
					}
					Else {
						// Note that everything within the orset should have no label.
						// The final member will be not be known until it is left behind so
						// it cannot be removed when first encountered here.
						Set tHideLabel(tNodeNo) = ""
					}
				}

				Set tLastNodeNo = tNodeNo
				Set tNodeNo=$O(pNodeArray(tNodeNo),1,tNode)
			}
			
			If tCurrentOrset {
				// This is the case where there was only an orset, and so it was left open
				Kill tHideLabel(tLastNodeNo)
			}
		}
		
		// Prune the node array to contain only items that are label components
		Set tRemoveNodeNo = $O(tHideLabel(""))
		While (tRemoveNodeNo'="") {
			Kill pNodeArray(tRemoveNodeNo)
			Set tRemoveNodeNo = $O(tHideLabel(tRemoveNodeNo))
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Find the axis key(s) for the item with ordinal position
/// <var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
/// Returns, via <var>pKey</var> an array of labels associated with the item
/// from the most specific to the most general.<br/>
/// If the item on the axis has no key (for example, measures), a placeholder "" is inserted into
/// the pKey array to preserve teh same structure as returned by <method>%GetOrdinalLabel</method>.<br>
/// The return value is the number of keys returned.<br/>
Method %GetOrdinalKey(Output pKey As %String, pAxis As %Integer, pPosition As %Integer, Output pSpec) As %Integer
{
	// Method added by DTB232
	Kill pKey
	Kill pSpec
	Set tKeyCount = 0
	Set tCubeIndex = ..%CubeKey
	Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"axis",pAxis))
	Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,pPosition))
	While ((tAxisKey'="")&&(tNodeNo'="")) {
		Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
		Set tType = $LG(tNode,1)
		Set tParent = $LG(tNode,4)
		Set tKey = $LG(tNode,13)
		Set tLabel = $LG(tNode,5)
		Set tDimNo = +$LG(tNode,9)
		Set tHierNo = +$LG(tNode,10)
		Set tLevelNo = +$LG(tNode,11)
		If (tType = "axis") {
			Quit
		}

		If (tLabel'="") {
			Set tKeyCount = tKeyCount + 1
			Set pKey(tKeyCount) = tKey
			
			// Return the level spec
			Set tSC = ##class(%DeepSee.Utils).%GetDimensionSpec(tCubeIndex,.tSpec,tDimNo,tHierNo,tLevelNo)
			Set pSpec(tKeyCount) = tSpec
		}
		Set tNodeNo = tParent
	}
	Quit tKeyCount
}

/// Get the total associated with the given row (1-based).<br/>
Method %GetRowTotal(pRow As %Integer, pAgg As %String = "sum") As %String
{
	Set:pAgg="" pAgg="sum"
	Quit $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"total",2,pRow,pAgg))
}

/// Get the total associated with the given column (1-based).<br/>
Method %GetColumnTotal(pColumn As %Integer, pAgg As %String = "sum") As %String
{
	Set:pAgg="" pAgg="sum"
	Quit $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"total",1,pColumn,pAgg))
}

/// Get the grand total for the current query.<br/>
/// This is a simple sum of all cells and not an "aggregate".
Method %GetGrandTotal(pAgg As %String = "sum") As %String
{
	Quit $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"total"))
}

/// Utility method.<br/>
/// Assemble the query plan for this query.
/// The query must have been successfully executed.
Method %GetPlan(Output pPlan) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill pPlan
		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		If (tStatus < 100) {
			Set tSC = $$$ERROR($$$GeneralError,"Query must be executed before its plan can be displayed.")
			Quit
		}
		Set tSC = ..%GetPlanForQuery(.pPlan,..%Cube,..%QueryKey)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Show plan details for the given query.
/// Do not call this directly.
Method %GetPlanForQuery(ByRef pPlan, pCubeName As %String, pQueryKey As %String, pLevel As %Integer = 0) [ Internal, Private ]
{
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		// query text
		Set tText = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"query",1))

		Set tParent = $I(pPlan)
		Set pPlan(tParent) = $LB($S(pLevel>0:"subquery",1:"query"),tText)

		// get plan for this query
		Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",""))
		While (tKey '= "") {
			Set tInfo = $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey)
			Set tStep = $LG(tInfo,1)
			Set tCube = $LG(tInfo,2)
			Set tParm = $LG(tInfo,3)
			Set tParm2 = $LG(tInfo,4)
			If (tStep = "sq") { // subquery
				Set tNodeNo = pPlan + 1
				If ((tParm'="")&&(tCube'="")) {
					Set tSC = ..%GetPlanForQuery(.pPlan,tCube,tParm,pLevel+1)
					If $$$ISERR(tSC) Quit
				}
				Set pPlan(tParent,"ch",tNodeNo) = tCube_":"_tParm
			}
			ElseIf (tStep = "dim") {
				Set pPlan($I(pPlan)) = $LB("dim",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "exec") {
				Set pPlan($I(pPlan)) = $LB("exec",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "execA") {
				Set pPlan($I(pPlan)) = $LB("execA",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "cons") {
				Set pPlan($I(pPlan)) = $LB("consolidate")
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "listing") {
				Set pPlan($I(pPlan)) = $LB("listing",tParm)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Utility method.<br/>
/// Print out the plan for this query to the console.
/// The query must have been successfully executed.
Method %ShowPlan()
{
	Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
	If (tStatus < 100) {
		Write "Query must be executed before its plan can be displayed.",!
		Quit
	}
	Do ..%ShowPlanForQuery(..%Cube,..%QueryKey)
}

/// Show plan details for the given query.
Method %ShowPlanForQuery(pCubeName As %String, pQueryKey As %String, pLevel As %Integer = 0) [ Internal, Private ]
{
	If ((pCubeName="")||(pQueryKey="")) {
		Quit
	}
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// query text
	Set tIndent = (pLevel*3)
	Set tText = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"query",1))
	Write ?tIndent,"-------------- ","Query Plan"," ---------------------",!
	Write ?tIndent,"**",tText,"**",!

	// show plan for this query
	Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",""))
	While (tKey '= "") {
		Set tInfo = $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey)
		Set tStep = $LG(tInfo,1)
		Set tCube = $LG(tInfo,2)
		Set tParm = $LG(tInfo,3)
		Set tParm2 = $LG(tInfo,4)
		If (tStep = "sq") {
			Write ?tIndent,"**SUBQUERY**",!
			If ((tParm'="")&&(tCube'="")) {
				Do ..%ShowPlanForQuery(tCube,tParm,pLevel+1)
			}
			Else {
				Write ?tIndent,"No query info",!
			}
		}
		ElseIf (tStep = "dim") {
			Write ?tIndent,"**DIMENSION QUERY (",tParm2,"): ",tParm,"**",!
		}
		ElseIf (tStep = "exec") {
			Write ?tIndent,"**EXECUTE: ",tParm,"x",tParm2," task(s) **",!
		}
		ElseIf (tStep = "execA") {
			Write ?tIndent,"**EXECUTE PARALLEL: ",tParm,"x",tParm2," task(s) **",!
		}
		ElseIf (tStep = "cons") {
			Write ?tIndent,"**CONSOLIDATE**",!
		}
		ElseIf (tStep = "listing") {
			Write ?tIndent,"**LISTING QUERY:",tParm," **",!
		}
	
		Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey))
	}
	Write ?tIndent,"-------------- ","End of Plan"," -----------------",!
}

/// Utility method.
/// Print the results of the current query to the console.<br/>
/// If <var>pShowNodeNo</var> is true, show the internal node numbers.<br/>
/// If <var>pMaxRows</var> is defined, limit the number of rows displayed.<br/>
Method %Print(Output pStats, pShowNodeNo As %Boolean = 0, pMaxRows As %Integer = 0) As %Status
{
	Set tSC = $$$OK
	Try {
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			Quit
		}

		// wait a small time in case a background has not yet reported a error
		Hang 0.01

		Set pMaxRows = $S(pMaxRows>10:pMaxRows-10,1:0)

		Set tError = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"error"))
		If (tError'="") {
			Set tSC = tError
		}

		If $$$ISERR(tSC) {
			Do $System.Status.DisplayError(tSC)
			W !
			Set tSC = $$$OK
			Quit
		}

		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		If (tStatus < 100) {
			Write $$$Text("Result has errors or is not ready to be printed. Status: ","%DeepSee"),tStatus,!
			Quit
		}
		Set tAxisCount = ..%GetAxisCount()
		Set tShowNodeNums = pShowNodeNo

		If (..%Query.queryType = "DRILLTHROUGH") {
			Do ..%PrintListing()
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		// test for default format
		Set tDefFormat = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"format"))

		If (tAxisCount=0) {
			// single value answer
			Set tValue = ..%GetValue()
			Set tCellWidth = 20
			Write $$$Text("Result","%DeepSee"),":"
			// JMD1412
			If ((tValue'="")&&(tDefFormat'="")) {
				Write $J(..%FormatNumber(tValue,tDefFormat),tCellWidth),!
			}
			Else {
				Write $J($S(tValue="":"*",tValue'=+tValue:tValue,1:$FN(tValue,",")),tCellWidth),!
			}
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisIsSearch(a) = ..%Query.axes.GetAt(a).%IsSearch()		// DTB141
		}

		Set tVolume = ..%GetCellCount(..%CubeKey,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Do $System.Status.DisplayError(tSC)
			Quit
		}

		// Get row and column info
		Set tStart = $ZH
		Set tColCount = +$G(tAxisSize(1))

		If ((tVolume = 0)||(tColCount=0)) {
			Write $$$Text("ResultSet has found no results","%DeepSee"),!
			// Write "Volume: ",tVolume,?20,"Columns: ",tColCount,!
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		// JMD1406: if we have a 3rd axis, pick up its format
		Set tZCount = +$G(tAxisSize(3))
		If (tZCount>0) {
			Set z = ..%GetOrdinalLabel(.tZNames,3,1,.tZFormat,.tZSolveOrder)
			Set tDefFormat = tZFormat
		}

		// column headers
		For c=1:1:$G(tAxisSize(1)) {
			Set tLabelCount = ..%GetOrdinalLabel(.tNames,1,c,.tFormat,.tSolveOrder)
			Set tName = $G(tNames(1))
			Set:tFormat'="" tColFormat(c) = tFormat
			Set:tSolveOrder>0 tColSolveOrder(c) = tSolveOrder
			If (tShowNodeNums) {
				Set tColNodes(c) = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"leaf",1,c))
			}
			Set tColNames(c) = tName
		}

		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tHasRows = 0
			Set tRowCount = 1
		}

		Set tLblWidth = 18
		Set tTotal = 0
		Set tCells = 0
		Set tEmptyCells = 0

		Set tHasOverride = ..%HasCellFormatOverride()

		// print
		Set tDisplayedColCount = tColCount
		Set tTruncated = 0
		If (tDisplayedColCount > 6) {
			Set tDisplayedColCount = 6
			Set tTruncated = 1
		}
		If (tDisplayedColCount = 1) {
			Set tLblWidth = 24
		}
		Set tCellWidth = (80 \ (tDisplayedColCount + 1)) - 4
		Set:tCellWidth>18 tCellWidth = 18 
		For c = 1:1:tDisplayedColCount {
			Set tName = $E(tColNames(c),1,tCellWidth-$S(tShowNodeNums:4,1:0)) _ $S(tShowNodeNums:"["_tColNodes(c)_"]",1:"")
			Write ?(c-1)*(tCellWidth+3)+tLblWidth,$J(tName,tCellWidth)
		}
		Write:tTruncated ?76,"..."
		Write !

		// how many digits are needed for row #
		Set tRowDigits = 0
		If (tRowCount>1) {
			Set tRowDigits = (1+$ZLOG(tRowCount))\1
			Set tLblWidth = tLblWidth - tRowDigits
		}

		Set tRowsSkipped = 0
		For r = 1:1:tRowCount {
			Set tRowSolveOrder = 0
			Set tName = ""		// DTB141
			If (tHasRows) {
				Set tLabelCount = ..%GetOrdinalLabel(.tLabels,2,r,.tRowFormat,.tRowSolveOrder)
				For n=tLabelCount:-1:1 {
					Set tName = tName _ $S(tName="":"",1:"->")_ tLabels(n)
				}
			}
			ElseIf tAxisIsSearch(1) {		// DTB141
				Set tName = $$$Text("Results","%DeepSee")
			}
			
			Set tCells = tCells + tColCount
			If (pMaxRows>0) {
				If ((r > pMaxRows)&&('tRowsSkipped)) {
					Write ".......","rows not displayed",".......",!
					Set tRowsSkipped = 1
					Continue
				}
				ElseIf ((r > pMaxRows)&&(r < (tRowCount-10))) {
					// show last 10 rows
					Continue
				}
			}

			Set tName = $E(tName,1,$S(tShowNodeNums:tLblWidth-4,1:tLblWidth))
			If (tShowNodeNums) {
				Set tName = tName _ "[" _ $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"leaf",2,r)) _ "]"
			}
			// Show row # as well
			Write:tRowDigits>0 $J(r,tRowDigits)," "
			Write tName
			For c = 1:1:tDisplayedColCount {
				Set tValue = $Case(tAxisCount,
					1:..%GetOrdinalValue(c),
					:..%GetOrdinalValue(c,r))

				If (+$G(tColSolveOrder(c))>=+tRowSolveOrder) {
					Set tFormat = $S($G(tColFormat(c))'="":tColFormat(c),$G(tRowFormat)'="":tRowFormat,1:tDefFormat)
				}
				Else {
					Set tFormat = $S($G(tRowFormat)'="":tRowFormat,$G(tColFormat(c))'="":tColFormat(c),1:tDefFormat)
				}

				// JMD988 Test for format override
				If ((tAxisCount>1) && tHasOverride) {
					Set tFO = ..%GetCellFormatOverride(c,r)
					Set:tFO'="" tFormat = tFO
				}

				Set tTotal = tTotal + tValue
				Set:tValue="" tEmptyCells = tEmptyCells + 1

				If (tFormat'="") {
					Write ?(c-1)*(tCellWidth+3)+tLblWidth+tRowDigits+1,$J($S(tValue="":"*",tValue'=+tValue:tValue,1:..%FormatNumber(tValue,tFormat)),tCellWidth)
				}
				Else {
					Write ?(c-1)*(tCellWidth+3)+tLblWidth+tRowDigits+1,$J($S(tValue="":"*",tValue'=+tValue:tValue,tValue'=(tValue\1):$FN(tValue,",",2),1:$FN(tValue,",")),tCellWidth)
				}
			}
			Write:tTruncated ?76,"..."
			Write !
		}

		Set pStats("cells") = tCells
		Set pStats("empty") = tEmptyCells
		Set pStats("total") = tTotal
		Set ..%Statistics("Cells") = tCells
		Set ..%Statistics("Print") = $ZH - tStart

		If (..%Query.showPlan) {
			Do ..%ShowPlan()
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
}

/// Utility method.<br/>
/// For a DRILLTHROUGH query, print out the listing.
Method %PrintListing()
{
	Set tSC = $$$OK
	Try {
		Set tSC = ..%GetListingResultSet(.tRS,.tListingFields)
		If $$$ISERR(tSC) Quit
		Set tColumnMeta = tRS.%GetMetaData().columns
		If (tListingFields="") {		
			Set tColCount = tColumnMeta.Count()
		}
		Else {
			Set tColCount = $LL(tListingFields)
		}
	
		Write "   #"
		Set tColWidth = $S(tColCount<5:15,tColCount<6:12,tColCount<7:11,tColCount<8:10,1:5)

		If (tListingFields="") {		
			For c = 1:1:tColCount {
				Set tColInfo = tColumnMeta.GetAt(c)
				Write ?(((c-1)*tColWidth)+6),$E(tColInfo.colName,1,tColWidth-1)
			}
		}
		Else {
			For c = 1:1:tColCount {
				Write ?(((c-1)*tColWidth)+6),$E($LG(tListingFields,c),1,tColWidth-1)
			}
		}
		Write !

		Set n = 0
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set n = n + 1
			Write $J(n,4),":"
			For c=1:1:tColCount {
				If (tListingFields="") {
					Set tValue = tRS.%GetData(c)
				}
				Else {
					Set tValue = tRS.%Get($LG(tListingFields,c))
				}
				Write ?(((c-1)*tColWidth)+6),$E(tValue,1,tColWidth-1)
			}
			Write !
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
		Write !
	}
}

/// Lower-level function that, given the text of a DeepSee MDX query, <var>pMDX</var>, 
/// parses it and converts it to a DeepSee run-time query object without changing
/// the state of this Result Set.
Method %ParseMDX(pMDX As %String, pQuery As %DeepSee.Query.query) As %Status
{
	Set tSC = $$$OK
	Try {
		// parse the query
		Set tStart = $ZH
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMDX(pMDX,.pQuery,..%Trace)  // DTB108 - pass query by reference
		Set ..%Statistics("ParseMDX") = $ZH - tStart
		If $$$ISERR(tSC) Quit

		// JMD1140: test for %LISTING
		If (pQuery.%listing'="") {
			Set ..listing = pQuery.%listing
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Get information on the members of a specific axis within the current query.<br/>
/// <var>pAxis</var> is the axis number (1 = cols, 2 = rows, etc.), 0 indicates that
/// information for the slicer axis is to be returned.<br/>
/// Because it is impossible to pre-determine the size of a specific axis, the process
/// private global, <b>^||DeepSee.AxisMembers</b> is used to hold the results.
/// The caller is responsible for killing this global.<br/>
/// On return, <var>pKey</var> contains the top-level subscript for the process private global
/// under which the member information is stored.<br/>
/// The member information takes the form:<br/>
/// ^||DeepSee.AxisMembers(pKey,pAxis,j,k) = $LB(nodeno,text,dimName,hierName,levelName,memberKey,dimNo,hierNo,levelNo,[aggregate])<br/>
/// pKey is the key returned by this method.<br/>
/// pAxis is the axis number.<br/>
/// j is the ordinal position of the tuple within the axis.<br/>
/// k is the ordinal position of the member within the tuple. k is 0 for members that form a stand-alone tuple.
/// Otherwise k starts at 0 and increase towards the end of the tuple.<br/>
/// nodeno is the internal node number corresponding to the member within its axis.<br/>
/// text is the axis caption for the member.<br/>
/// Names are not enclosed within [ ] delimiters.<br/>
/// A fully-qualified name (UNAME) can be constructed by combining the names with the key:<br/>
/// Set tUName = "["_tDimName_"].["_tHierName_"].["_tLevelName_"].&["_tMemberKey_"]"<br/>
/// If <var>pItemNo</var> is provided, then it is the ordinal number of a single member within
/// the axis and only information about this member is returned.<br/>
Method %GetAxisMembers(pAxis As %Integer, Output pKey, pItemNo As %Integer = "") As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set pKey = ..%QueryKey
		If (pKey = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Query key is missing")
			Quit
		}

		Set tIsSlicer = 0
		Set tAxisKey = ""
		If (+pAxis > 0) {
			Set tCount = ..%GetAxisCount(.tAxisInfo)
			Set tAxisKey = $G(tAxisInfo(+pAxis))
		}
		ElseIf (+pAxis=0) {
			// slicer: special case
			Set tIsSlicer = 1
			Set tAxisKey = $G($$$DeepSeeResultsGLVN(..%CubeKey,pKey,"axis",0))
		}

		// add cube name to key
		Set pKey = ..%CubeKey_":"_pKey

		If (tAxisKey="") {
			Quit
		}
		Else {
			Kill ^||DeepSee.AxisMembers(pKey,pAxis)
			Set n = 0
			Set tCube = $$$UPPER(..%Cube)
			Set tCubeIndex = ..%CubeKey

			Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"axis",pAxis))

			// walk down leaf list for this axis
			// n.b., we shouldn't use "all": it may not be in the right order
			// (but there is no evidence of that!)

			Set tInfo = ""
			If (tIsSlicer) {
				Set tNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",1,"all",""))
			}
			Else {
				Set tLeafNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,""),1,tNodeNo)
				Set:tLeafNo="" tNodeNo = ""
			}
			While (tNodeNo '= "") {
				Set n = n + 1
				If ((pItemNo="")||(pItemNo=n)) {
					Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
					Set tType = $LG(tNode,1)
					Set tParent = $LG(tNode,4)
					Set tText = $LG(tNode,5)
					Set tKey = $Case(tType,"mbr":$LG(tNode,13),:"")
					Set tRSpec = $LG(tNode,14)

					If (tType="agg") {
						// this is an aggregate: construct the set of its children
						Set tAgg = $LG(tNode,6)

						// $LB(nodeno,label,dimname,hiername,levelname,memberKey,rSpec)
						// for agg, dimname="" and hiername is agg name
						Set k = 0
						Set tSpec = $LB(+tNodeNo,tText,"",tAgg)
						Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tSpec

						// loop over children
						Set k2 = 0
						Set cn = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
						While (cn'="") {
							Set k2 = k2 + 1
							Set tNode2 = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",cn))
							Set tType2 = $LG(tNode2,1)
							Set tParent2 = $LG(tNode2,4)
							Set tText2 = $LG(tNode2,5)
							Set tKey2 = $Case(tType2,"mbr":$LG(tNode2,13),:"")

							// Find dimension name (if we have already seen this, don't bother)
							Set tDimNo2 = +$LG(tNode2,9)
							Set tHierNo2 = +$LG(tNode2,10)
							Set tLevelNo2 = +$LG(tNode2,11)
							If ('$D(tDimInfo(tDimNo2,tHierNo2,tLevelNo2),tInfo2)) {
								Set tInfo2 = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo2,tHierNo2,tLevelNo2))
								Set tDimInfo(tDimNo2,tHierNo2,tLevelNo2) = tInfo2
							}
							Set tDimName2 = $LG(tInfo2,2)
							Set tHierName2 = $LG(tInfo2,3)
							Set tLevelName2 = $LG(tInfo2,4)
							Set tSpec2 = $LB(+tNodeNo,tText2,tDimName2,tHierName2,tLevelName2,tKey2,tDimNo2,tHierNo2,tLevelNo2)
							Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k,k2) = tSpec2

							Set cn = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",cn))
						}
					}
					Else {
						// Find dimension name (if we have already seen this, don't bother)
						Set tDimNo = +$LG(tNode,9)
						Set tHierNo = +$LG(tNode,10)
						Set tLevelNo = +$LG(tNode,11)
						If ('$D(tDimInfo(tDimNo,tHierNo,tLevelNo),tInfo)) {
							Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tDimInfo(tDimNo,tHierNo,tLevelNo) = tInfo
						}
						Set tDimName = $LG(tInfo,2)
						Set tHierName = $LG(tInfo,3)
						Set tLevelName = $LG(tInfo,4)

						// $LB(nodeno,label,dimname,hiername,levelname,memberKey,dno,hno,lno,[rspec])
						Set tSpec = $LB(+tNodeNo,tText,tDimName,tHierName,tLevelName,tKey,tDimNo,tHierNo,tLevelNo,tRSpec)

						// WAL032 -- handle %OR members
						// Insert the %OR spec in position 11
						Set tORMemberSpec = $LG(tNode,6)
						If (tORMemberSpec [ "|") {
							Set $list(tSpec,11) = tORMemberSpec
						}
						// WAL032

						Set k = 0				
						While (tParent'="") {
							// get info for parents of this node, if applicable
							Set tParentNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
							Set tParentType = $LG(tParentNode,1)
							If ((tParentType="axis")) Quit
							If ((tParentType="mbr")||(tParentType="msr")) {
								Set tText = $LG(tParentNode,5)
								Set tKey = $LG(tParentNode,13)
								// Find dimension name (if we have already seen this, don't bother)
								Set tDimNo = +$LG(tParentNode,9)
								Set tHierNo = +$LG(tParentNode,10)
								Set tLevelNo = +$LG(tParentNode,11)
								If ('$D(tDimInfo(tDimNo,tHierNo,tLevelNo),tInfo)) {
									Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
									Set tDimInfo(tDimNo,tHierNo,tLevelNo) = tInfo
								}
								Set tDimName = $LG(tInfo,2)
								Set tHierName = $LG(tInfo,3)
								Set tLevelName = $LG(tInfo,4)
								// Look at parent node, not info
								Set tParentSpec = $LB(+tParent,tText,tDimName,tHierName,tLevelName,tKey,tDimNo,tHierNo,tLevelNo,$LG(tParentNode,14))
								Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tParentSpec
								Set k = k + 1
							}
							Set tParent = $LG(tParentNode,4)
						}
						Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tSpec
					}
				}
				If (tIsSlicer) {
					Set tNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",1,"all",tNodeNo))
				}
				Else {
					Set tLeafNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,tLeafNo),1,tNodeNo)
					Set:tLeafNo="" tNodeNo = ""
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Clear out current statistics for this result set.
Method %ClearStatistics()
{
	Kill ..%Statistics
}

/// Get the value of a specific query statistic. e.g. "ParseMDX".<br/>
/// For "query" stats, add "query." to the stat name: e.g. ""query.Slices".
Method %GetStatistic(pStat As %String) As %String
{
	Set tValue = ""
	If (pStat'="") {
		If ($E($$$LOWER(pStat),1,6)="query.") {
			Set pStat = $E(pStat,7,*)
			If ($IsObject(..%Query)) {
				If (pStat="Slices") {
					// special case:
					Set tValue = 0
					Set tTotalAxisCount = ##class(%DeepSee.Query.Engine2).%GetAxisInfo(..%CubeKey,..%QueryKey,.tAxisType,.tAxisKey,.tAxisSize,.tSlicerAxis)
					// sometimes the slicer is treated as a normal 3rd axis
					If ((tSlicerAxis=0)&&(tTotalAxisCount=3)) {
						Set tSlicerAxis = 3
					}
					If (tSlicerAxis>0) {
						Set tValue = +$G(tAxisSize(tSlicerAxis))
					}
				}
				Else {
					Set tValue = $G(..%Query.%Statistics(pStat))
				}
			}
		}
		Else {
			Set tValue = $G(..%Statistics(pStat))
		}
	}
	Quit tValue
}

/// Write out current statistics for this result set.
Method %PrintStatistics()
{
	If ($IsObject(..%Query)) {
		Do ..%Query.%PrintStatistics()
	}

	Write !
	Write "ResultSet Statistics:",!
	Write " Cells:",?25,$$FormatNum($G(..%Statistics("Cells"))),!
	Write " Parse:",?25,$$FormatMS($G(..%Statistics("ParseMDX"))),!
	Write " Display:",?25,$$FormatMS($G(..%Statistics("Print"))),!
	Write " Total Time:",?25,$$FormatMS($G(..%Statistics("ParseMDX"))+$G(..%Statistics("Print"))),!
	Quit

	Set (t,n) = ""
FormatMS(t)
	Quit $J($FN(t*1000,",",3),15)_" ms"

FormatNum(n)
	Quit $J($FN(n,",",0),15)
}

/// Apply MDX FORMAT_STRING <var>pFormat</var> to numeric value <var>pValue</var>.
ClassMethod %FormatNumber(pValue As %Decimal, pFormat As %String, Output pType As %String, Output pStyle As %String) As %String
{
	Set tOutput = ""
	Set pStyle = ""

	// there may be a style spec tacked on after a ^
	Set tStyleSpec = $P(pFormat,"^",2)
	Set pFormat = $P(pFormat,"^",1)

	// special case for dates
	If ((pFormat = "yyyy-mm-dd")||(pFormat = "%date%")) {
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Set pType = "date"
		If (+pValue<=0) Quit ""
		If (pFormat = "%date%") {
			Quit $ZDT(pValue\1,,,,,,,,,,"@err")
		}
		Else {
			Quit $ZDT(pValue\1,3,,,,,,,,,"@err")
		}
	}
	//+ begin JSL4423
	// special case for duration of time (pValue is expressed in seconds)
	If ($e(pFormat,1,6) = "%time%") {
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Set pType = "integer"
		if pValue < 0 {
			Set pValue = $ZABS(pValue)
			Set tNegativeFlag = 1
			Set pStyle = $P(tStyleSpec,";",2)_";"
		}
		// if less than 1 day, use $ztime
		if pValue < 86400 {
			Set tResult = $ztime(pValue,1,,"")
		} else {
			Set tDays = pValue\86400
			Set tValue = pValue#86400
			Set tResult=$ztime(tValue,1,,"")
			Set tHours = $p(tResult,":",1)
			Set $p(tResult,":",1)= tDays*24+tHours
		}
		quit $S('$g(tNegativeFlag):"",1:"-")_tResult
	}
	//- end JSL4423
	Set tFormat = ""
	// JMD988: test for numeric string or special "%string%" format
	// JMD1001: Skip pValue=""
	// 
	// JMD1378: Don't let "0.25" trick us; convert it to .25
	Set:$IsValidNum(pValue) pValue = +pValue

	If ((pValue'="")&&('$IsValidNum(pValue)||(pValue'=+pValue)||(pFormat="%string%"))) {
		Set pType = "string"
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Quit pValue
	}
	Else {
		Set pType = $S(pValue=(pValue\1):"integer",1:"number")
		If (pValue > 0) { // positive
			Set tFormat = $P(pFormat,";",1)
			Set pStyle = $P(tStyleSpec,";",1)
		}
		ElseIf (pValue < 0) {  // negative
			Set tFormat = $P(pFormat,";",2)
			Set:tFormat'="" pValue = pValue * -1
			Set pStyle = $P(tStyleSpec,";",2)
		}
		ElseIf (pValue = 0) {  // zero
			Set tFormat = $P(pFormat,";",3)
			Set pStyle = $P(tStyleSpec,";",3)
		}
		ElseIf (pValue = "") { // missing
			Set tFormat = $P(pFormat,";",4)
			Set pStyle = $P(tStyleSpec,";",4)
			// JMD1001 (2)
			If (tFormat="") {
				Quit ""
			}
		}
	}

	If (pStyle="") {
		Set pStyle = $P(tStyleSpec,";",1)
	}
	If (pStyle'="") {
		Set pStyle = pStyle _ ";"
	}	
	
	Set:tFormat="" tFormat = $P(pFormat,";",1)
	If (tFormat="") {
		// default numeric format
		If (pValue>=0) {
			Quit $FN(pValue,",",$S(pType="integer":0,1:2))
		}
		Else {
			Quit "("_$FN(-pValue,",",$S(pType="integer":0,1:2))_")"
		}
	}

	// apply format
	Set tHasPerCent = tFormat["%"
	Set tHasComma = tFormat[","
	Set tHasZero = tFormat["0"
	Set tHasHash = (tFormat["#")||tHasZero

	Set:tHasPerCent pValue = pValue*100

	// JMD909 - Leading 0s
	Set tLeading0s = 0
	If (tHasZero) {
		// find leading zeroes
		Set t = 1
		While (t<=$L(tFormat)) {
			Set ch = $E(tFormat,t)
			If ((ch="#")||(ch=0)) {
				Set tLeading0s = tLeading0s + 1
			}
			ElseIf ((ch=".")) {
				Quit
			}
			Set t = t + 1
		}
		// now treat 0 as #
		Set tFormat = $Replace(tFormat,"0","#")
	}

	Set tPre = $TR($P(tFormat,"#",1),"\","")
	Set tPost = $S(tHasHash:$TR($P(tFormat,"#",$L(tFormat,"#")),"\",""),1:"")
	Set tScale = 0
	Set d = $F(tFormat,".")
	While (($E(tFormat,d)="#")||($E(tFormat,d)="0")) {
		Set tScale = tScale + 1
		Set d = d + 1
	}

	Set tOutput = $S(tHasHash:$FN(pValue,$S(tHasComma:",",1:""),tScale),1:"")
	// + WAL156 && Sascha Kisser
	Set tDS=##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
	Set:(tDS="") tDS = "."
	Set:tHasZero tOutput = $TR($J($P(tOutput,tDS,1),tLeading0s)," ",0)_$S(tScale>0:tDS,1:"")_$P(tOutput,tDS,2)
	// - WAL156 && Sascha Kisser
	Quit tPre _ tOutput _ tPost
}

/// Internal method.<br>
/// Local implementation of DataModel API.
Method %CopyDataFromModel(Output pData, Output pTypes, pSeries As %Integer = "") As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		Set tAxisCount = ..%GetAxisCount()

		If (tAxisCount = 0) {
			// single value answer
			Set pData(1,"Result") = ..%GetValue()
			Quit
		}

		// series = column
		// prop # = row

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%CubeKey,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (tVolume = 0) {
			// no results !!!
			Quit
		}


		// Get row info: rows are properties
		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tRowCount = 1
		}

		For sno = $S(pSeries="":1,1:pSeries):1:..%seriesCount {
			For r = 1:1:tRowCount {
				Set tValue = $Case(tAxisCount,
					1:..%GetOrdinalValue(sno),
					:..%GetOrdinalValue(sno,r))
					Set pData(sno,r) = tValue
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
}

/// Internal method.<br>
/// Called by controller to get meta data for the current query.
/// Each metadata value is a csv list.
Method %GetModelInfo(Output pPropNames As %String, Output pPropTypes As %Integer, Output pPropLabels As %String) As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set pPropNames = ""
		Set pPropTypes = ""
		Set pPropLabels = ""

		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		Set tAxisCount = ..%GetAxisCount()

		If (tAxisCount = 0) {
			// single value answer
			Set pPropNames = "Result"
			Set pPropTypes = 12
			Set pPropLabels = $$$Text("Result","%DeepSee")
			Quit
		}

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%Cube,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (tVolume = 0) {
			// no results !!!
			Quit
		}

		// columns are series
		Set tColCount = +$G(tAxisSize(1))
		Set ..%seriesCount = tColCount

		// column headers
		For c=1:1:$G(tAxisSize(1)) {
			Set tLabelCount = ..%GetOrdinalLabel(.tNames,1,c,.tFormat)
			Set ..%seriesNames(c) = $G(tNames(1))
		}

		// Get row info: rows are properties
		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tHasRows = 0
			Set tRowCount = 1
		}

		// Get names from rows
		For r = 1:1:tRowCount {
			If (tHasRows) {
				Set tName = ""
				Set tLabelCount = ..%GetOrdinalLabel(.tLabels,2,r,.tRowFormat)
				For n=tLabelCount:-1:1 {
					Set tName = tName _ $S(tName="":"",1:".")_ tLabels(n)
				}
			}
			Else {
				Set tName = $$$Text("Results","%DeepSee")
			}

			Set pPropNames = pPropNames _ $S(r=1:"",1:",") _ r
			Set pPropTypes = pPropTypes _ $S(r=1:"",1:",") _ 12
			Set pPropLabels = pPropLabels _ $S(r=1:"",1:",") _ tName
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
}

/// Find and return an MDX slicer statement that will return the specified range of cells in
/// the current query as a one-cell result.<br/>
/// For convenience, return the measure in play, if possible to determine.
Method %GetSlicerForCellRange(Output pSlicer As %String, pStartRow As %Integer, pStartCol As %Integer, pEndRow As %Integer, pEndCol As %Integer, Output pMeasure As %String) As %Status
{
	// deprecated: use %GetFiltersForCellRange instead
	Set tSC = $$$OK
	Try {
		Set pSlicer = ""
		Set pMeasure = ""

		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}

		// !!! what if axis count != 2
		Set tAxisCount = ..%AxisCount
		If (tAxisCount="") {
			Set tAxisCount = ..%GetAxisCount()
		}

		Set tColAxis = 1
		Set tRowAxis = 2
		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tRowAxis))

		// expression for rows
		Kill tSpecList
		For tRow = pStartRow:1:pEndRow {
			Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tRowAxis,tRow))
			If (tNodeNo="") {
				Continue
			}
			Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tParent = $LG(tNodeInfo,4)
			Set tNodeType = $LG(tNodeInfo,1)
			Set tId = $LG(tNodeInfo,6)
			Set tKey = $LG(tNodeInfo,13)
			Set tDimNo = $LG(tNodeInfo,9)
			Set tHierNo = $LG(tNodeInfo,10)
			Set tLevelNo = $LG(tNodeInfo,11)
			If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
				Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMbrType = $LG(tMbrInfo,1)
				Set tSpec = ""
				If (tMbrType="r") {
					// tack on remote spec
					Set tRemoteSpec = $LG(tNodeInfo,14)
					If (tRemoteSpec'="") {
						Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
					}
				}
				ElseIf (tNodeType="msr") {
					Set pMeasure = $LG(tMbrInfo,3)
				}
				Else {
					// JMD909 - fix for drill on Properties()
					If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
						Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_$$$dsEscapeIdent(tKey)_"]"
					}
				}

				// if any parent nodes are members, construct a tuple
				// check for relations in parents as well
				Set tIsTuple = 0
				While (tParent'="") {
					Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
					Set tPNodeType = $LG(tPNodeInfo,1)
					If ((tPNodeType="mbr")||(tPNodeType="msr")) {
						Set tPType = $LG(tPNodeInfo,1)
						Set tPId = $LG(tPNodeInfo,6)
						Set tPKey = $LG(tPNodeInfo,13)
						Set tPDimNo = $LG(tPNodeInfo,9)
						Set tPHierNo = $LG(tPNodeInfo,10)
						Set tPLevelNo = $LG(tPNodeInfo,11)
						If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
							// JMD1284
							Set:tSpec'="" tIsTuple = 1
							Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
							Set tPMbrType = $LG(tPMbrInfo,1)
							Set tPSpec = ""
							If (tPMbrType="r") {
								// tack on remote spec
								Set tRemoteSpec = $LG(tPNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
								}
							}
							ElseIf (tPType="msr") {
								Set pMeasure = $LG(tPMbrInfo,3)
							}
							Else {
								// JMD909
								If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_$$$dsEscapeIdent(tPKey)_"]"
								}
							}
							// JMD1284
							If (tPSpec'=tSpec) {
								Set:tPSpec'="" tSpec = tPSpec_$S(tSpec="":"",1:",")_tSpec
							}
						}
					}
					Set tParent = $LG(tPNodeInfo,4)
				}
				If (tIsTuple) {
					Set:tSpec'="" tSpec = "("_tSpec_")"
				}
				// JMD1284: add to list; remove duplicates
				Set:tSpec'="" tSpecList(tSpec) = ""
			}
		}

		// JMD1284: convert list to set
		Set tRowSpec = ""
		Set kc = 0
		Set tSpec = $O(tSpecList(""))
		While (tSpec'="") {
			Set kc = kc + 1
			Set tRowSpec = tRowSpec _ $S(kc>1:",",1:"") _ tSpec
			Set tSpec = $O(tSpecList(tSpec))
		}
		If (kc>1) {
			Set tRowSpec = "{" _ tRowSpec _ "}"
		}

		// expression for cols
		Kill tSpecList
		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tColAxis))

		For tCol = pStartCol:1:pEndCol {
			Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tColAxis,tCol))
			If (tNodeNo="") {
				Continue
			}
			Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tNodeType = $LG(tNodeInfo,1)
			Set tId = $LG(tNodeInfo,6)
			Set tParent = $LG(tNodeInfo,4)
			Set tKey = $LG(tNodeInfo,13)
			Set tDimNo = $LG(tNodeInfo,9)
			Set tHierNo = $LG(tNodeInfo,10)
			Set tLevelNo = $LG(tNodeInfo,11)
			
			If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
				Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMbrType = $LG(tMbrInfo,1)
				Set tSpec = ""
				If (tMbrType="r") {
					// tack on remote spec
					Set tRemoteSpec = $LG(tNodeInfo,14)
					If (tRemoteSpec'="") {
						Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
					}
				}
				ElseIf (tNodeType="msr") {
					Set pMeasure = $LG(tMbrInfo,3)
				}
				Else {
					// JMD909 - fix for drill on Properties()
					If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
						Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_$$$dsEscapeIdent(tKey)_"]"
					}
				}
				// if any parent nodes are members, construct a tuple
				Set tIsTuple = 0
				While (tParent'="") {
					Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
					Set tPNodeType = $LG(tPNodeInfo,1)
					If ((tPNodeType="mbr")||(tPNodeType="msr")) {
						Set tPType = $LG(tPNodeInfo,1)
						Set tPId = $LG(tPNodeInfo,6)
						Set tPKey = $LG(tPNodeInfo,13)
						Set tPDimNo = $LG(tPNodeInfo,9)
						Set tPHierNo = $LG(tPNodeInfo,10)
						Set tPLevelNo = $LG(tPNodeInfo,11)
						If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
							// JMD1284
							Set:tSpec'="" tIsTuple = 1
							Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
							Set tPMbrType = $LG(tPMbrInfo,1)
							Set tPSpec = ""
							If (tPMbrType="r") {
								// tack on remote spec
								Set tRemoteSpec = $LG(tPNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
								}
							}
							ElseIf (tPType="msr") {
								Set pMeasure = $LG(tPMbrInfo,3)
							}
							Else {
								// JMD909
								If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_$$$dsEscapeIdent(tPKey)_"]"
								}
							}
							// JMD1284
							If (tPSpec'=tSpec) {
								Set:tPSpec'="" tSpec = tPSpec_$S(tSpec="":"",1:",")_tSpec
							}
						}
					}
					Set tParent = $LG(tPNodeInfo,4)
				}
				If (tIsTuple) {
					Set:tSpec'="" tSpec = "("_tSpec_")"
				}
				// JMD1284: add to list; remove duplicates
				Set:tSpec'="" tSpecList(tSpec) = ""
			}
		}

		// JMD1284: convert list to set
		Set tColSpec = ""
		Set kc = 0
		Set tSpec = $O(tSpecList(""))
		While (tSpec'="") {
			Set kc = kc + 1
			Set tColSpec = tColSpec _ $S(kc>1:",",1:"") _ tSpec
			Set tSpec = $O(tSpecList(tSpec))
		}
		If (kc>1) {
			Set tColSpec = "{" _ tColSpec _ "}"
		}

		Set tWHERE = ""
		If ((tRowSpec '= "")&&(tColSpec '= "")) {
			// !!! Set tWHERE = "NONEMPTYCROSSJOIN(" _ tRowSpec _ "," _ tColSpec _ ")"
			Set tWHERE = "CROSSJOIN(" _ tRowSpec _ "," _ tColSpec _ ")"
		}
		ElseIf (tRowSpec '= "") {
			Set tWHERE = tRowSpec
		}
		ElseIf (tColSpec '= "") {
			Set tWHERE = tColSpec
		}

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))
		If (tSlicer '= "") {
			If (tWHERE = "") {
				Set tWHERE = tSlicer
			}
			Else {
				Set tWHERE = "CROSSJOIN(" _ tWHERE _ "," _ tSlicer _ ")"
			}

			// check for measure in slicer (simple case)
			If (pMeasure="") {
				If (tSlicer [ "[MEASURES].") {
					Set pMeasure = $P(tSlicer,"[MEASURES].",2,999)
					Set pMeasure = $P(pMeasure,"]",1)
					Set:$E(pMeasure)="[" pMeasure = $P(pMeasure,"[",2)
				}
			}
		}
		Set pSlicer = tWHERE
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Test for %GetFiltersForCellRange.
ClassMethod %TestFilters(pMDX As %String) As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tRS = ..%New()
		Set tSC = tRS.%PrepareMDX(pMDX)
		If $$$ISERR(tSC) Quit
		Set tSC = tRS.%Execute()
		If $$$ISERR(tSC) Quit
		Set tSC = tRS.%GetFiltersForCellRange(.tFilters,1,1,1,1)
		If $$$ISERR(tSC) Quit
		ZW tFilters
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
	}


	Quit tSC
}

/// Find and return a an array of MDX %FILTER statements that will return the specified range of cells in
/// the current query as a one-cell result.<br/>
/// On return, <var>pFilters</var> will contain the filter statement corresponding to each axis (1,2, etc) and the slicer
/// (0).<br/>
/// For convenience, return the measure in play, if possible to determine.<br/>
Method %GetFiltersForCellRange(Output pFilters As %String, pStartRow As %Integer, pStartCol As %Integer, pEndRow As %Integer, pEndCol As %Integer, Output pMeasure As %String, pAllRows As %Boolean = 0, pAllCols As %Boolean = 0, pSortCol As %Integer = 0, pSortDir As %String = "ASC", ByRef pPluginInfo As %String) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill pFilters
		Set pMeasure = ""
		Set pPluginInfo = "" // WAL170

		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}
		
		// + WAL170
		Set tPlugInList = ""
		Set tSC = ##class(%DeepSee.Utils).%GetKPIPlugInList(.tPlugInList)
		If $$$ISERR(tSC) Quit
		// - WAL170

		// we only support 2 axes
		Set tAxisCount = ..%AxisCount
		If (tAxisCount="") {
			Set tAxisCount = ..%GetAxisCount()
		}
		Set tColAxis = 1
		Set tRowAxis = 2
		
		

		// JMD1361: unite row and column logic
		// repeat logic for row and column axis
		For a = 1:1:2 {
			Set tXLat = 0
			If (a=1) {
				Set tCurrAxis = tRowAxis
				Set tAll = pAllRows
				Set tStartItem = pStartRow
				Set tEndItem = pEndRow
				Set:pSortCol>0 tXLat = 1
			}
			Else {
				Set tCurrAxis = tColAxis
				Set tAll = pAllCols
				Set tStartItem = pStartCol
				Set tEndItem = pEndCol
			}

			// loop
			Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tCurrAxis))
			Set tAxisSpec = ""

			Set tItems = 0
			If ('tAll) {
				For tItemIndex = tStartItem:1:tEndItem {
					// JMD1468 Note that rows are *display* rows and have to be converted to
					// logical rows to account for sorting.
					Set tItemNo = tItemIndex

					If (tXLat) {
						Set tItemNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"sort",pSortCol,pSortDir,tItemIndex),tItemNo)
					}

					// JMD1397: Use tCubeIndex
					Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tCurrAxis,tItemNo))
					If (tNodeNo="") {
						Continue
					}
					Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
					Set tDone = 0
					While ('tDone) {
						Set tDone = 1
						Set tNodeType = $LG(tNodeInfo,1)
						Set tAggType = $LG(tNodeInfo,6)
						If ((tNodeType="agg")&&(tAggType'="%KPI")&&(tAggType'="%MDX")) {
							// visit children of this node
							Set tLoopChildren = 1
							Set tChildNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))

							// n.b. for COUNT:EXCLUDEEMPTY we should add special processing here to find
							// only the members that are contributing
						}
						ElseIf ((tNodeType="exp")||((tNodeType="agg")&&((tAggType="%KPI")||(tAggType="%MDX")))) {
							// + WAL170 -- figure out if THIS kpi is a plugin
							If ((tAggType="%KPI")) {
								Set tKPIName = $$$UPPER($LG(tNodeInfo,8))
								Set tKPIProp = $LG(tNodeInfo,5)
								If ($G(tPlugInList(tKPIName))'="") { // WAL223
									Set pPluginInfo("NAME") = tKPIName
									Set pPluginInfo("PROP") = tKPIProp
								}
							}
							// - WAL170
							
							// WAL262 -- get PlugIn arguments (i.e., "%cube","PATIENTS") from axis
							Set tIndex = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
							Set tStartIndex=tIndex
							Set tLastArg = ""
							While tIndex'="" {
								// This means we're looking at user defined arguments
								If ((tIndex-tStartIndex)>=2) {
									If ($LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),5)="") {
										If ($LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),6)'="")&&
										   ($LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),6)'="%CONTEXT"){
											Set tArgs($LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),6))=""
											Set tLastArg = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),6)
										}
									}
									ElseIf ($LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),5)="Constant") {
										If tLastArg'="" {
											Set tArgs(tLastArg) = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tIndex),6)
										}
									}
								}
								Set tIndex = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",tIndex))
							}
							Merge pPluginInfo("ARGUMENTS") = tArgs
							// WAL252
							
							// JMD913
							// move up to parent of this node
							Set tNodeNo = $LG(tNodeInfo,4)
							Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
							Set tDone = 0
						}
						Else {
							Set tLoopChildren = 0
						}
					}
					
					While((tLoopChildren=0)||(tChildNodeNo'="")) {
						If (tLoopChildren) {
							Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tChildNodeNo))
							Set tNodeType = $LG(tNodeInfo,1)
						}
						
						Set tParent = $LG(tNodeInfo,4)
						Set tId = $LG(tNodeInfo,6)
						Set tKey = $LG(tNodeInfo,13)
						Set tDimNo = $LG(tNodeInfo,9)
						Set tHierNo = $LG(tNodeInfo,10)
						Set tLevelNo = $LG(tNodeInfo,11)

						If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
							Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tMbrType = $LG(tMbrInfo,1)
							Set tSpec = ""
							If (tMbrType="r") {
								Set tNullRef = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"relations",$$$UPPER($LG(tMbrInfo,2)),"nullReplacement"))
								If ((tNullRef'="")&&(tId=-1E14)) {
									// no relation
									Set tSpec = "["_$LG(tMbrInfo,2)_"]"_".["_tNullRef_"]"
								}
								Else {
									// JMD1316: get relationship spec from relationship member

									// tack on remote spec
									Set tRemoteSpec = $LG(tNodeInfo,14)
									// JMD1361: test for %OR in relationship
									If ($E(tRemoteSpec,1,4)="%OR(") {
										// strip off %OR, decorate each item, and reapply %OR
										// assume no commas in spec!
										Set t = $E(tRemoteSpec,6,*-2)
										Set ts = ""
										For tp = 1:1:$L(t,",") {
											Set ts = ts _ $S(ts="":"",1:",") _ "["_$LG(tMbrInfo,2)_"]"_"."_$P(t,",",tp)
										}
										Set tSpec = "%OR({"_ts_"})"
									}
									Else {
										If (tRemoteSpec'="") {
											Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
										}
										// special case for drilldown
										If ($$$UPPER($P(tSpec,".",$L(tSpec,".")))="CHILDREN") {
											Set tSpec = $P(tSpec,".",1,$L(tSpec,".")-1)
											Set:tKey'="" tSpec = tSpec _ ".&[" _ $$$dsEscapeIdent(tKey) _ "]"
										}
									}
								}
							} // "r"
							ElseIf (tNodeType="msr") {
								Set pMeasure = $LG(tMbrInfo,3)
							}
							Else {
								// JMD909 - fix for drill on Properties()
								If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
									If (tId["|") {
										// get dim #s
										Set tLevelNode = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbrs",$$$UPPER($LG(tMbrInfo,2)),$$$UPPER($LG(tMbrInfo,3)),$$$UPPER($LG(tMbrInfo,4))))
										Set tMbrClass = $LG(tMbrInfo,6)
										Set tIsTime = $classmethod(tMbrClass,"%IsA","%DeepSee.Time.AbstractLevel")
										// JMD1361: %OR in play: recreate set from ids
										// note: currently this will not work for %OR(computedDim)
										For p = 1:1:$L(tId,"|") {
											Set tId2 = $P(tId,"|",p)
											Set tMbrSpec = ""
											If (tIsTime) {
												// n.b. not needed; just avoids method call
												Set tMbrSpec = "&["_$$$dsEscapeIdent(tId2)_"]"
											}
											Else {
												// convert ID to KEY
												Set tMbrSpec = $classmethod(tMbrClass,"%GetMemberSpec",tId2,tCubeIndex,$LG(tLevelNode,1),$LG(tLevelNode,2),$LG(tLevelNode,3))
											}
											Set:tMbrSpec'="" tSpec = tSpec _ $S(tSpec="":"",1:",") _ "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"]."_tMbrSpec
										}
										Set:tSpec'="" tSpec = "%OR({"_tSpec_"})"
									}
									// + WAL148 -- Handle not case
									ElseIf (tId["!") {
										Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_$$$dsEscapeIdent(tKey)_"].%NOT"
									}
									// - WAL148
									Else {
										// no OR
										Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_$$$dsEscapeIdent(tKey)_"]"
									}
								}
							} // else

							// if any parent nodes are members, construct a tuple
							// check for relations in parents as well
							Set tIsTuple = 0
							Set tORSetNo = 0
							Kill tORSets
							While (tParent'="") {
								Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
								Set tPNodeType = $LG(tPNodeInfo,1)
								
								If (tPNodeType="orset") {
									// JMD1453 add to list of or sets
									Set tORSetNo = tORSetNo + 1
									Set:tIsTuple tSpec = "%OR({" _ tSpec _ "})"
									Set tORSets(tORSetNo) = tSpec
									Set:(tSpec="") tORSetJoin(tORSetNo-1) = "OR"  // + WAL148 -- empty tSpec means this orset joins other nodes
									Set tORSetJoin(tORSetNo) = "AND"	// DTB248 - assume this will be ANDed. If that is incorrect, it will be reset
									Set tSpec = ""
									Set tIsTuple = 0
								}
								ElseIf ((tPNodeType["tuple")) {                   // + WAL148 -- contains includes "ortuple"
									// JMD1453 add tuple to or set list
									Set tORSetNo = tORSetNo + 1
									Set:tIsTuple tSpec = "(" _ tSpec _ ")"
									Set tORSets(tORSetNo) = tSpec
									Set:(tSpec="") tORSetJoin(tORSetNo-1) = "AND" // + WAL148 -- empty tSpec means this (or)tuple joins other nodes
									Set tSpec = ""
									Set tIsTuple = 0
								}
								ElseIf ((tPNodeType="mbr")||(tPNodeType="msr")) {
									Set tPType = $LG(tPNodeInfo,1)
									Set tPId = $LG(tPNodeInfo,6)
									Set tPKey = $LG(tPNodeInfo,13)
									Set tPDimNo = $LG(tPNodeInfo,9)
									Set tPHierNo = $LG(tPNodeInfo,10)
									Set tPLevelNo = $LG(tPNodeInfo,11)
									If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
										Set:tSpec'="" tIsTuple = 1
										Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
										Set tPMbrType = $LG(tPMbrInfo,1)
										Set tPSpec = ""
										If (tPMbrType="r") {
											// tack on remote spec
											Set tRemoteSpec = $LG(tPNodeInfo,14)
											// JMD976
											If (tPId=-1E14) {
												// no relation
												Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_".&[<null>]"
											}
											ElseIf (tRemoteSpec'="") {
												// JMD1361: test for %OR in relationship
												If ($E(tRemoteSpec,1,4)="%OR(") {
													// strip off %OR, decorate each item, and reapply %OR
													// assume no commas in spec!
													Set t = $E(tRemoteSpec,6,*-2)
													Set ts = ""
													For tp = 1:1:$L(t,",") {
														Set ts = ts _ $S(ts="":"",1:",") _ "["_$LG(tPMbrInfo,2)_"]"_"."_$P(t,",",tp)
													}
													Set tPSpec = "%OR({"_ts_"})"
												}
												Else {
													Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
												}
											}
										}
										ElseIf (tPType="msr") {
											Set pMeasure = $LG(tPMbrInfo,3)
										}
										Else {
											// + WAL128 --  If we are dealing with an %OR of members,
											//              reassemble this into a %OR statement by putting the ID ($LG(axisNode,6))
											//              back together.
											//              This ensures that we get all the cell context for the listing
											Set tCurrPBaseSpec = ##class(%DeepSee.Query.Parser).%BuildEscapedSpec($LB($LG(tPMbrInfo,2),$LG(tPMbrInfo,3),$LG(tPMbrInfo,4)))		// DTB248
											If (tPId [ "|") {
												If (tPKey'="") {
													For i=1:1:$L(tPId,"|") {
														Set tCurrPId = $P(tPId,"|",i)
														Set tSC = ##class(%DeepSee.Utils).%GetMemberKeyForID(tCubeIndex,tPDimNo,tPHierNo,tPLevelNo,tCurrPId,.tCurrPKey)
														
														Set tCurrPSpec = tCurrPBaseSpec _ ".&["_$$$dsEscapeIdent(tCurrPKey)_"]"		// DTB248
														If tPSpec="" {
															Set tPSpec = "%OR({"	
														}
														Else {
															Set tPSpec = tPSpec _ ","	
														}
														Set tPSpec = tPSpec _ tCurrPSpec
													}
													Set tPSpec = tPSpec _ "})"	
												}
											}
											// + WAL148 -- handle %NOT case here, add ".%NOT" to tPSpec
											ElseIf (tPId["!") {
												Set tPSpec = tCurrPBaseSpec _ ".&["_$$$dsEscapeIdent(tPKey)_"].%NOT"		// DTB248
											}
											// - WAL148
											ElseIf (tPKey'="") {
												Set tPSpec = tCurrPBaseSpec _ ".&["_$$$dsEscapeIdent(tPKey)_"]"		// DTB28
											}
											// - WAL128
										}
										// JMD1387
										If (tSpec="") {
											Set tSpec = tPSpec
										}
										ElseIf (tPSpec'="") {
											Set tSpec = tPSpec_","_tSpec
											Set tIsTuple = 1
										}
									} // mbr|msr
								}
								Set tParent = $LG(tPNodeInfo,4)
							}
							If (tIsTuple) {
								Set:tSpec'="" tSpec = "("_tSpec_")"
							}
							
							// JMD1453 combine OR sets, if any
							Set oc = $O(tORSets(""))
							While (oc'="") {
								If (tSpec="") {
									Set tSpec = tORSets(oc)
								}
								ElseIf(tORSets(oc)'="") {
									// + WAL148 -- we need more information to decide how to combine the
									//             orsets, which could be OR'ed or AND'ed
									If ($G(tORSetJoin(oc)) = "AND") {
										Set tSpec = "CROSSJOIN("_tORSets(oc)_","_tSpec_")"
									}
									ElseIf ($G(tORSetJoin(oc)) = "OR") {
										Set tSpec = "%OR({"_tORSets(oc)_","_tSpec_"})"
									}
									// - WAL148
								}
								Set oc = $O(tORSets(oc))
							}

							Set tAxisSpec = tAxisSpec _ $S(tAxisSpec="":"",1:",") _ tSpec
							If ($L(tAxisSpec)>5000) {
								// JMD836: too many items: ignore restriction
								Set tItems = 0
								Set tAxisSpec = ""
								Quit
							}
							Set tItems = tItems + 1
						}
						If (tLoopChildren) {
							Set tChildNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",tChildNodeNo))
						}
						Else {
							Quit
						}
					} // while()
				}
				If (tItems > 1) {
					Set:tAxisSpec'="" tAxisSpec = "{" _ tAxisSpec _ "}"
				}
			}

			// save results
			If (a=1) {
				Set tRowSpec = tAxisSpec
			}
			Else {
				Set tColSpec = tAxisSpec
			}
		}

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))
		If (tSlicer '= "") {
			// check for measure in slicer (simple case)
			If (pMeasure="") {
				If (tSlicer [ "[MEASURES].") {
					Set pMeasure = $P(tSlicer,"[MEASURES].",2,999)
					Set pMeasure = $P(pMeasure,"]",1)
					Set:$E(pMeasure)="[" pMeasure = $P(pMeasure,"[",2)
				}
			}
		}
		Set:tColSpec'="" pFilters(1) = tColSpec
		Set:tRowSpec'="" pFilters(2) = tRowSpec
		Set:tSlicer'="" pFilters(0) = tSlicer
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Output the result of the current query in XML/A 
/// format to the current device. The query should be prepared
/// and executed first.<br/>
/// If there is an error, it is assumed that the caller will transform
/// the status value into a SOAP fault.
Method %OutputXMLA() As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tCubeName = $$$UPPER(..%Cube)
		Set tCubeIndex = ..%CubeKey
		Set tQueryKey = ..%QueryKey
		Set tStatus = ..%GetQueryStatus(tCubeName,tQueryKey)
		Set tAxisCount = ..%GetAxisCount()
		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisKeys(a) = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",a))
		}

		If (..%Query.queryType = "DRILLTHROUGH") {
			// !!! what to do for DRILLTHROUGH
			Quit
		}

		// find name of cube in original case
		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
		Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))

		// timestamps !!!
		Set tLastDataUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"lastDataUpdate"))
		Set tLastSchemaUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"lastSchemaUpdate"))

		If (tLastDataUpdate'="") {
			// format is: "2009-06-19T15:55:31"
			Set tLastDataUpdate = $TR($ZDT(tLastDataUpdate,3)," ","T")
		}
		If (tLastSchemaUpdate'="") {
			// format is: "2009-06-19T15:55:31"
			Set tLastSchemaUpdate = $TR($ZDT(tLastSchemaUpdate,3)," ","T")
		}


		// Cube section
		&html<
<root xmlns="urn:schemas-microsoft-com:xml-analysis:mddataset" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<OlapInfo>
<CubeInfo>
<Cube>
<CubeName>#($ZCVT(tCubeName,"O","XML"))#</CubeName>
<LastDataUpdate xmlns="http://schemas.microsoft.com/analysisservices/2003/engine">#(tLastDataUpdate)#</LastDataUpdate>
<LastSchemaUpdate xmlns="http://schemas.microsoft.com/analysisservices/2003/engine">#(tLastSchemaUpdate)#</LastSchemaUpdate>
</Cube>
</CubeInfo>
		>

		// Additional OLAP info

		// Axes info
		&html<<AxesInfo>>
		For a = 1:1:tAxisCount {
			&html<<AxisInfo name="Axis#(a-1)#">>
			// !!!
			&html<</AxisInfo>>
		}
		&html<</AxesInfo>>

		// Cell info
		&html<
<CellInfo>
<Value name="VALUE"/>
<FmtValue name="FORMATTED_VALUE" type="xsd:string"/>
<CellOrdinal name="CELL_ORDINAL" type="xsd:unsignedInt"/>
</CellInfo>
		>

		&html<</OlapInfo>>

		// Results


		// Axes section
		// !!! what if there are 0 axes
		// !!! what about the slicer
		&html<<Axes>>
		For a = 1:1:tAxisCount {
			// for each axis write out the tuples that make up each entry
			&html<<Axis name="Axis#(a-1)#">>
			&html<<Tuples>>
			Set tAxisKey = tAxisKeys(a)

			// walk down leaf index and get node #s for this axis
			Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			While (tItemNo '= "") {
				&html<<Tuple>>
				// use node number to get details for the axis node
				// (this comes from the axis cache)
				Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))

				// look up the chain of parents for this node to see what belongs to
				// this *tuple*; assemble a list of nodes
				Kill tNodes
				Set tLevel = 0
				Set tParentNo = $LG(tNode,4)
				Set tParentNode = tNode
				While (tParentNo '= "") {
					Set tType = $LG(tParentNode,1)
					If ((tType = "mbr")||(tType = "msr")||(tLevel=0)) {
						Set tLevel = tLevel + 1
						Set tNodes(tLevel) = tParentNode
					}
					Set tParentNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParentNo))
					Set tParentNo = $LG(tParentNode,4) // go up
				}

				// walk down list of nodes and emit members for this tuple
				For n = tLevel:-1:1 {
					Set tNode = tNodes(n)
					// pull details out of node
					Set tType = $LG(tNode,1)
					Set tCaption = $LG(tNode,5)
					Set tMbrId = $LG(tNode,6)
					Set tDimNo = +$LG(tNode,9)
					Set tHierNo = +$LG(tNode,10)
					Set tLevelNo = +$LG(tNode,11)

					If ('$D(tMbrInfoCache(tDimNo,tHierNo,tLevelNo),tMbrInfo)) {
						// Avoid going to the meta global by using local cache
						Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
						Set tMbrInfoCache(tDimNo) = tMbrInfo
					}

					If (tType = "msr") {
						Set tDimName = "[Measures]"
						Set tLevelName = "["_tCaption_"]"
						Set tUName = tDimName_".["_tCaption_"]"
					}
					Else {
						Set tDimName = "["_$LG(tMbrInfo,2)_"]"
						Set tHierName = "["_$LG(tMbrInfo,3)_"]"
						Set tLevelName = "["_$LG(tMbrInfo,4)_"]"
					
						// compute uname
						Set tUName = ""
						Set tDimClass = $LG(tMbrInfo,6)
						If (tDimClass'="") {
							Set tUName = $zobjclassmethod(tDimClass,"%GetMemberSpec",tMbrId,tCubeName,tDimNo,tHierNo,tLevelNo)
						}
						Set tUName = tDimName_"."_tHierName_"."_tUName
					}

					Set tDispInfo = 0 // !!!

					&html<<Member Hierarchy="#($ZCVT(tDimName,"O","XML"))#">>
					&html<<UName>#($ZCVT(tUName,"O","XML"))#</UName>>
					&html<<Caption>#($ZCVT(tCaption,"O","XML"))#</Caption>>
					&html<<LName>#($ZCVT(tLevelName,"O","XML"))#</LName>>
					&html<<LNum>#($ZCVT(tLevelNo,"O","XML"))#</LNum>>
					&html<<DisplayInfo>#($ZCVT(tDispInfo,"O","XML"))#</DisplayInfo>>
					&html<</Member>>
				}

				// end of this tuple
				&html<</Tuple>>
				Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)
			} 

			&html<</Tuples>>
			&html<</Axis>>
		}
		&html<</Axes>>

		// Cells
		&html<<CellData>>

		// Write out cells in order
		// Initial cell address
		Set tCellNo = 0
		For a=1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tAddr(a) = tNodeNo
		}
		Set tDone = 0
		While ('tDone) {
		Set tValue = $Case(tAxisCount,
			0:..%GetValue(),
			1:..%GetValue(tAddr(1)),
			2:..%GetValue(tAddr(1),tAddr(2)),
			3:..%GetValue(tAddr(1),tAddr(2),tAddr(3)),
			4:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4)),
			5:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5)),
			6:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6)),
			7:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6),tAddr(7)),
			:"")
			
			// determine type of the value
			// !!!! n.b, we need to find the actual format string to apply
			// for now we guess
			If ($IsValidNum(tValue)) {
				If (tValue = (tValue\1)) {
					Set tType = "xsd:long"
					Set tFmtValue = $FN(tValue,",",0)
				}
				Else {
					Set tType = "xsd:double"
					Set tFmtValue = $FN(tValue,",",2)
				}
			}
			Else {
				Set tType = "xsd:string"
			}
			&html<<Cell CellOrdinal="#(tCellNo)#"><Value xsi:type="#(tType)#">#(tValue)#</Value><FmtValue>#(tFmtValue)#</FmtValue></Cell>>
			Set tCellNo = tCellNo + 1

			// find next cell
			Set tFoundNext = 0
			Set a = 1
			While ('tFoundNext) {
				Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,tItemNo(a)),1,tNodeNo)
				If (tItemNo(a) '= "") {
					Set tAddr(a) = tNodeNo
					Set tFoundNext = 1
				}
				Else {
					Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,""),1,tNodeNo)
					Set tAddr(a) = tNodeNo
					Set a = a + 1
					If (a > tAxisCount) {
						Set tDone = 1
						Quit
					}
				}
			}
		}

		&html<</CellData>>
		&html<</root>>
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Return the default format string for this result.
/// Also returns the default label (measure name).
Method %GetDefaultFormat(Output pCaption As %String) As %String [ Internal ]
{
	Set pCaption = ""
	Set tCubeIndex = ..%CubeKey
	Set tQueryKey = ..%QueryKey

	#; determine default format
	Set tDefaultFormat = ""
	Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))

	// JMD1406: if we have a 3rd axis, pick up its format
	If (..%GetAxisSize(3)>0) {
		Set z = ..%GetOrdinalLabel(.tZNames,3,1,.tZFormat,.tZSolveOrder)
		Set tDefaultFormat = tZFormat
		Set pCaption = $G(tZName(z))
	}
	ElseIf (tSlicer'="") {
		Set tSlicerKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",0))
		If (tSlicerKey'="") {
			Set s = $O($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",1,"all",""))
			If (s'="") {
				Set tSNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",s))
				If ($LG(tSNode,1)="msr") {
					Set tDefaultFormat = $LG(tSNode,12)
					Set pCaption = $LG(tSNode,5)
				}
			}
		}
	}
	If (pCaption="") {
		Set pCaption = ##class(%DeepSee.Utils).%GetCountCaption(tCubeIndex)
	}

	Quit tDefaultFormat
}

/// Output the result of the current query in XML/A 
/// format to the current device. The query should be prepared
/// and executed first.<br/>
/// If there is an error, it is assumed that the caller will transform
/// the status value into a SOAP fault.
Method %OutputJSON(pPageSize As %Integer, pCurrPage As %Integer, pRowLabels As %List = "", pMaxRows As %Integer = "") As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		Set tStatus = ..%GetQueryStatus(..%Cube,tQueryKey)

		If (tStatus < 100) {
			// wait a bit!
			Hang 1
			// try again
			Set tStatus = ..%GetQueryStatus(..%Cube,tQueryKey)
		}

		// JMD1381
		Set tIsSlave = ($E(tQueryKey,1,6)="SLAVE:")
		If ((tStatus < 100)||tIsSlave) {
			Write "null",!
			Quit
		}

		// window
		Set tMaxCols = 500
		Set tStartRow = ((pCurrPage-1)*pPageSize)+1
		Set tEndRow = tStartRow + pPageSize - 1
		Set tRowCount = 0
		Set tColCount = 0

		// write out *all* rows and let the client page through the results
		// meta data consists of an array of up to 2 axes.
		// Each axis has list of tuples: {c:caption,f:format}
		// these correspond to leaf nodes.
		// and a graph of groups that refer to the tuples:
		// groups:[{caption:'',groups:[...],tuples:[]

		// data consists of a single array of values (cells: q.v.)

		Set tAxisCount = ..%GetAxisCount()
		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisKeys(a) = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",a))
		}

		Set tColCount = +$G(tAxisSize(1))
		Set tRowCount = +$G(tAxisSize(2))

		// JMD1462
		Set:tColCount=0 tColCount = 1
		Set:tRowCount=0 tRowCount = 1

		// JMD1128 
		Set tMaxJSONRows = $S(pMaxRows="":2000,1:+pMaxRows)
		Set:tRowCount>tMaxJSONRows tRowCount = tMaxJSONRows
		Set:tColCount>tMaxCols tColCount = tMaxCols

		Set tStartRow = 1
		Set tEndRow = tStartRow + tRowCount - 1

		If (..%Query.queryType = "DRILLTHROUGH") {
			Write "null",!
			Quit
		}	

		#; determine default format
		Set tDefaultFormat = ..%GetDefaultFormat(.tDefaultCaption)

		// find name of cube in original case
		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
		Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))

		Write "{"
		Write !,$$$ZENJSPAIR("cubeName",tCubeName),","
		Write !,$$$ZENJSPAIR("cubeClass",tCubeClass),","
		Write !,$$$ZENJSPAIR("defaultFormat",tDefaultFormat),","
		Write !,$$$ZENJSPAIR("defaultCaption",tDefaultCaption),","

		// row level captions
		Write !,"""rowCaptions"":[",!
		Set rc = $O(pRowLabels(""))
		While (rc'="") {
			Write $$$ZENJSVALUE(pRowLabels(rc))
			Set rc = $O(pRowLabels(rc))
			Write:rc'="" ","
		}
		Write "],",! // rowCaptions

		Write !,"""axes"":[",!

		// ?JMD- should we write out tuples post-json?
		If (tAxisCount = 0) {
			// default axes
			Write "{" // axis object
			Write """key"":","null",",",!
			Write """tuples"":[",!
				Set tCaption = "All"
				Write "{" // tuple object
				Write $$$ZENJSPAIR("caption",tCaption)
				Write "}",! // tuple object
			Write "]",! // tuples
			Write "}",! // axis object

			Write ",{",! // axis object
			Write """key"":","null",",",!
			Write """tuples"":[",!
				Set tCaption = "Count"
				Write "{",! // tuple object
				Write $$$ZENJSPAIR("caption",tCaption)
				Write "}",! // tuple object
			Write "]",! // tuples
			Write "}",! // axis object
		}

		// axis info
		For a = 1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tHasGroups = 0

			// JMD1128: construct set of groups within this axis
			Set tGroupCount = 1	// node # in groups graph
			Kill tGroups		// group info by number, with hierarchy as graph
								// leaf nodes contain leaf #
			Kill tGroupIndex 	// node # to group #

			Write:a>1 ","
			Write "{" // axis object
			Write !,$$$ZENJSPAIR("key",tAxisKey),","
			Write !,"""tuples"":[",!

			// walk down leaf index and get node #s for this axis
			// make sure we only write out values for current page
			If (a = 2) {
				Set tStart = tStartRow
				Set tEnd = tEndRow
			}
			Else {
				Set tStart = 1
				Set tEnd = tMaxCols
			}

			Set n = 0 // items written
			Set item = 0 // actual item #
			Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			While ((tItemNo '= "")&&(item<tEnd)) {
				Set item = item + 1
				If (item >= tStart) {
					// use node number to get details for the axis node
					// (this comes from the axis cache)
					Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))

					Set tType = $LG(tNode,1)
					Set tParent = $LG(tNode,4)
					Set tCaption = $LG(tNode,5)
					Set tMbrId = $LG(tNode,6)
					Set tDimNo = +$LG(tNode,9)
					Set tHierNo = +$LG(tNode,10)
					Set tLevelNo = +$LG(tNode,11)
					Set tFmt = $LG(tNode,12)
					Set tGroupNo = ""

					// JMD: test if we are showing a date value;
					// these may need to be reformatted on the client
					Set tKey = ""
					Set tDateType = ""
					If ((tDimNo'="")&&(tHierNo'="")&&(tLevelNo'="")) {
						If '$D(tMbrTypes(tDimNo,tHierNo,tLevelNo)) {
							Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tTimeClass = $LG(tDimInfo,6)
							Set tDType = ##class(%DeepSee.Utils).%GetTimeLevelType(tTimeClass)		// DTB188 - Use API

							Set tMbrTypes(tDimNo,tHierNo,tLevelNo) = tDType
						}
						Set tDateType = $G(tMbrTypes(tDimNo,tHierNo,tLevelNo))
					}
					Set:tDateType'="" tKey = $LG(tNode,13)

					// JMD1128: test if we are part of a group
					If (tParent'="") {
						If $D(tGroupIndex(tParent)) {
							// point to existing group
							Set tGroupNo = tGroupIndex(tParent)
						}
						Else {
							// build list of parents above this node
							Kill tPList
							Set pn = 0
							While (tParent'="") {
								Set tParentNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
								Set tParentType = $LG(tParentNode,1)
								If ((tParentType="mbr")||(tParentType="msr")) {
									Set tHasGroups = 1
									Set tPList(pn) = tParent
									Set pn = pn + 1
								}
								Set tParent = $LG(tParentNode,4)
							}

							// now walk down the list
							Set tLastParent = 0
							Set pn = $O(tPList(""),-1)
							While (pn'="") {
								Set tParent = tPList(pn)
								If $D(tGroupIndex(tParent)) {
									Set gc = tGroupIndex(tParent)
								}
								Else {
									Set gc = tGroupCount
									Set tGroupCount = tGroupCount + 1
								}
								Set tGroupIndex(tParent) = gc
								Set tGroups(gc) = tParent
								Set tGroups(tLastParent,"ch",gc) = ""
								Set tLastParent = gc
								Set tGroupNo = gc
								Set pn = $O(tPList(pn),-1)
							}
						}
					}

					Set n = n + 1
					If (tGroupNo'="") {
						Set tGroups(tGroupNo,"leaf",n) = ""
					}

					Write:n>1 ","
					Write "{" // tuple object
					Write $$$ZENJSPAIR("caption",tCaption)
					Write:tDateType'="" ",", $$$ZENJSPAIR("type",tDateType)
					Write:tKey'="" ",", $$$ZENJSPAIR("key",tKey)
					Write:tGroupNo'="" ",",$$$ZENJSPAIR("g",tGroupNo)
					Write:tFmt'="" ",",$$$ZENJSPAIR("format",tFmt)
					Write "}",! // tuple object
				}
				Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)
			}
			Write "]" // tuples

			Write ",""hasGroups"":",$S(tHasGroups:"true",1:"false"),!

			// JMD1128: groups and children
			If $D(tGroups) {
				//Do ..%OutputAxisGroupJSON(.tGroups,0,tCubeIndex,tAxisKey)
				// JMD1148: write out flat list of groups
				Write ",""groups"":["
				Set gn = 0
				Set g = $O(tGroups(""))
				While (g'="") {
					Set tCaption = ""
					Set tParentNo = ""
					Set tNodeNo = $G(tGroups(g))
					If (tNodeNo'="") {
						Set tGroupNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
						Set tCaption = $LG(tGroupNode,5)
						Set tParentNo = $LG(tGroupNode,4)
					}
					Set gn = gn + 1
					Write:gn>1 ","
					Write "{" // group object
					Write:tCaption'="" $$$ZENJSPAIR("caption",tCaption),","
					If (tParentNo'="") {
						Set tParentGroup = $G(tGroupIndex(tParentNo))
						Write:tParentGroup'="" $$$ZENJSPAIR("g",tParentGroup),","
					}
					If $D(tGroups(g,"ch")) {
						Write """groups"":["
						Set gc = $O(tGroups(g,"ch",""))
						While (gc'="") {
							Write gc
							Set gc = $O(tGroups(g,"ch",gc))
							Write:gc'="" ","
						}
						Write "],"
					}
					If $D(tGroups(g,"leaf")) {
						Write """tuples"":["
						Set gc = $O(tGroups(g,"leaf",""))
						While (gc'="") {
							Write gc
							Set gc = $O(tGroups(g,"leaf",gc))
							Write:gc'="" ","
						}
						Write "]"
					}
					Write "}",! // group object

					Set g = $O(tGroups(g))
				}
				Write "]",!

			}

			Write "}",! // axis object
		}

		Write "],",! // axes


		// Initial cell address
		For a=1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tAddr(a) = $G(tNodeNo)
		}

		// write out size of data;
		// this allows us to use 1 array for all data values

		Write $$$ZENJSPAIR("rowCount",tRowCount),",",!
		Write $$$ZENJSPAIR("columnCount",tColCount),",",!

		// cells
		// note: we only write out up to 2D results as our client has no use for
		// higher order information
		// JMD1148: simplify JSON for data
		// fastest way is to not use pure JSON!
		// instead, define an array of known-size and explicitly insert values into it.
		// data is written out as [R1C1,R1C2,R1C3,R2C1,R2C2,R2C3]
		Write """cells"":[],",!

		Write """rowTotals"":[],",!
		Write """columnTotals"":[],",!

		Write $$$ZENJSPAIR("grandTotal",+$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total"))),",",!

		Write $$$ZENJSPAIR("status",tStatus),! // last property
		Write "}"

		// JMD1148: violate JSON rules for speed's sake:
		Write ";",!

		// cells
		Write "var a = new Array(",tRowCount*tColCount,");",!
		Write "o.data.cells = a;",!

		If (tAxisCount = 0) {
			Write "a[0]="_$$$ZENJSVALUE(..%GetValue())_";",!
		}
		ElseIf (tAxisCount = 1) {
			Set tRowCount = 1
			Set c = 0
			While((tItemNo(1)'="")&&(c<tMaxCols)) {
				Write "a["_c_"]="_$$$ZENJSVALUE(..%GetValue(tAddr(1)))_";",!
				Set c = c + 1
				Set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
				Set tAddr(1) = tNodeNo
			}
		}
		Else {
			Set tCellCount = 0
			Set row = 0 // actual row #
			While((tItemNo(2)'="")&&(row<tEndRow)) {
				Set row = row + 1
				If (row >= tStartRow) {
					Set c = 0
					Set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,""),1,tNodeNo)
					Set tAddr(1) = tNodeNo
					While((tItemNo(1)'="")&&(c<tMaxCols)) {
						Set c = c + 1
						Set tValue = $Case(tAxisCount,
							0:..%GetValue(),
							1:..%GetValue(tAddr(1)),
							2:..%GetValue(tAddr(1),tAddr(2)),
							3:..%GetValue(tAddr(1),tAddr(2),tAddr(3)),
							4:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4)),
							5:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5)),
							6:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6)),
							7:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6),tAddr(7)),
							:"")
						Write "a["_tCellCount_"]="_$$$ZENJSVALUE(tValue)_";",!
						Set tCellCount = tCellCount + 1

						Set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
						Set tAddr(1) = tNodeNo
					}
				}
				Set tItemNo(2) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",2,tItemNo(2)),1,tNodeNo)
				Set tAddr(2) = tNodeNo
			}
		}
		// row "totals"
		Write "var a = new Array(",tRowCount,");",!
		Write "o.data.rowTotals = a;",!

		Set r = 0 // rows written
		For tRow = 1:1:tRowCount {
			Write "a["_r_"]="
			Set r = r + 1
			If $D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow)) {
				Write "{"
				Write $$$ZENJSPAIR("count",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"count"))),","
				Write $$$ZENJSPAIR("sum",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"sum"))),","
				Write $$$ZENJSPAIR("min",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"min"))),","
				Write $$$ZENJSPAIR("max",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"max"))),","
				Write $$$ZENJSPAIR("avg",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"avg"))),","
				Write $$$ZENJSPAIR("pct",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"pct")))
				Write "};",!
			}
			Else {
				Write "null;",!
			}
		}

		// column "totals"
		Write "var a = new Array(",tColCount,");",!
		Write "o.data.columnTotals = a;",!

		For tCol = 1:1:tColCount {
			Write "a["_(tCol-1)_"]="

			If $D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol)) {
				Write "{"
				Write $$$ZENJSPAIR("count",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"count"))),","
				Write $$$ZENJSPAIR("sum",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"sum"))),","
				Write $$$ZENJSPAIR("min",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"min"))),","
				Write $$$ZENJSPAIR("max",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"max"))),","
				Write $$$ZENJSPAIR("avg",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"avg"))),","
				Write $$$ZENJSPAIR("pct",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"pct")))
				Write "};",!
			}
			Else {
				Write "null;",!
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Write "/*"
		Do $System.OBJ.DisplayError(tSC)
		Write "*/"
	}
	Quit tSC
}

/// If the given query has pending results (such as from plug-ins), update them.
/// Return if there are any additional pending results.
Method %UpdatePendingResults(Output pPending As %Boolean) As %Status
{
	Set tSC = $$$OK
	Try {
		Set pPending = 0
		Set tCubeIndex = ..%CubeKey
		Set tQueryKey = ..%QueryKey
		Set tSC = ##class(%DeepSee.Query.Engine).%UpdatePendingResults(tCubeIndex,tQueryKey,.pPending)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Run the query audit code. (Test version).<br/>
/// This gives customer applications a chance to audit the queries run by DeepSee.
/// This is called whenever a query is executed by %DeepSee.ResultSet.<br/>
/// The query audit code is a valid ObjectScript expression stored in the ^DeepSee.AuditQueryCode global.
/// Audit query code should not write any output to the current device nor
/// should this code kill any % variables required by Zen or DeepSee.<br/>
/// The variable, %dsQuery, will contain the text of the query.
Method %RunQueryAuditCode(pQuery As %DeepSee.Query.query) As %Status
{
	// DTB065: This does the actual work of running the query code.
	Set tSC = $$$OK
	Try {
		Set tAuditCode = $G(^DeepSee.AuditQueryCode)
		If (tAuditCode'="") {
			New %dsCubeName,%dsQueryText,%dsResultSet
			Set %dsCubeName = ..%GetCubeName()
			Set %dsQueryText = ..%GetQueryText()
			Set %dsResultSet = $This
			X tAuditCode
		}
	}
	Catch(ex) {
		Set tSC = $$$ERROR($$$GeneralError,"Error in DeepSee Audit Query Code:" _ $ZE)
	}
	Quit tSC
}

}
