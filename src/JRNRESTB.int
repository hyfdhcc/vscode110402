ROUTINE JRNRESTB [Type=INT]
JRNRESTB ;Restore Journal from a File, Part II ;$Change: 4521965 $
	; Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/rtn/journal/jrnrestb.mac#1 $
 /*
 +--------------------------------------------------------+
 | Copyright 1986-2015 by InterSystems Corporation,       |
 | Cambridge, Massachusetts, U.S.A.                       |
 | All rights reserved.                                   |
 |                                                        |
 | Confidential, unpublished property of InterSystems.    |
 |                                                        |
 | This media contains an authorized copy or copies       |
 | of material copyrighted by InterSystems and is the     |
 | confidential, unpublished property of InterSystems.    |
 | This copyright notice and any other copyright notices  |
 | included in machine readable copies must be reproduced |
 | on all authorized copies.                              |
 +--------------------------------------------------------+
 */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/_syJrninc.inc#1 $ ($Change: 4521965 $) */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/_syMirror.inc#1 $ ($Change: 4521965 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/FILEINC.inc#1 $ ($Change: 4521965 $) */
INT(RestTime,jrnlist,dejrn,restopt,disjrn,ROLLJRN,ZJRNUSE,PriorList,DISMDB,LocalJrn,JrnDirList) ;
 n (RestTime,jrnlist,dejrn,restopt,disjrn,ROLLJRN,ZJRNUSE,PriorList,DISMDB,LocalJrn,JrnDirList) 
 s $zt="INTerr"
 i $g(RestTime)="" s RestTime=$zdt($h,8)
 s QUIETMODE=1,notresto=0,jrnstop=0
 s ALL='$d(dejrn)
 i $o(jrnlist(""),1,firstfile)
 i $o(jrnlist(""),-1,lastfile)
 s djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f(firstfile,";"),0:$e(firstfile,*-8-$l($p(firstfile,".",$l(firstfile,"."))),*),:$e(firstfile,*-8-$l($p(firstfile,".",$l(firstfile,"."))),$f(firstfile,";")-2)),:firstfile) ;used in nextfileopen (can be removed??)
 s djlast=$case($ZBITGET($ZVERSION(0),46),0:$case($f(lastfile,";"),0:$e(lastfile,*-8-$l($p(lastfile,".",$l(lastfile,"."))),*),:$e(lastfile,*-8-$l($p(lastfile,".",$l(lastfile,"."))),$f(lastfile,";")-2)),:lastfile)
 s nojrn=$s($g(disjrn):$$STOP^%SYS.NOJRN(),1:0)
 s checkerr=1 ; **** set to 0 during debugging
 s nullsubstat=$zu(68,1,1) 
 s prompt=0
 i $g(ROLLJRN) d ScanForOpenTrans
 s jrnlist="" ;important to nextfile
 d restore^JRNRESTF(.fastrest) 
 i 'fastrest {
   i '$$InitSort() {
     s disablesort=1,(cachetempmaxblks,sortchunklimit)=0
     d logmsg("Sorting is disabled",0,1)
   }
   d multrest
 }
 d ROLLBACK
 q ""
INTerr s $zt=""
 i $g(jrnstat) d ENABLE^%SYS.NOJRN
 q $ze
main ;
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 n checkerr,%jrnfile,%curfile,nojrn,disjrn
 n clu,adr,type,ALL,tranopen,lastindex,badtran
 n PriorList,ScanList ;a list of journal files prior to the 1st processed file
 n LocalJrn,JrnFileList
 n nextadr,lastadr,cnt,prefstrategy,sizmod,rc,sfn
 n r,dir,new,cd,glo,gnode,dirnam,nomount,canonic,zjrnerr,zjrnerrmsg
 n dbcol  ;stores collations of the databases involved
 n globname,sortcnt ;sortcnt(globname): # of sorted SETs per global
 n numrestjobs s numrestjobs=$System.Util.NumberOfCPUs() ;# of concurrent restore jobs, limited by # of CPUs
 n percentdone ;percentage of restoring done by a job
 n disablesort ;disable sorting so that sets/kills are NOT applied out of order
 n shrid ;if set, use fast dejournaling instead of sorting and multi-daemon
 n fastrest ;=1 or 2, with 2 probably faster than 1
 n clrsw10 ;whether to clear switch 10 (fastrest requires switch 10 OFF)
 n cachetempblksiz,cachetempmaxblks,sortchunklimit
 n resterr ;error message generated by caller of ztrap and passed upward
 n sorterr,sortbegerr,sortenderr,globerr 
 s (sorterr,sortbegerr,sortenderr,globerr)=0
 n restopt s restopt="" ;behavior of restore daemons in certain error events
 n clumember,numclu,minseq,maxseq,maxclumstart,private
 n newref,oldref
 n colseq,curcol,x,djid,clutrans
 i $G(fromrest)'=1,'$G(QUIETMODE) n dejrn,global
 n dejrnNodup
 n jrnstop s jrnstop=0
 s nojrn=0
 s checkerr=1 ; **** set to 0 during debugging
 i '$d(%UI) n %UI s %UI="CHUI"
 n JrnDirList,statnode,trannode,i,err,savedisablesort,xOS,a
 i checkerr s $ze="",$zt="exitmain"
 n nullsubstat s nullsubstat=$zu(68,1,1) 
 i '$$what^JRNRESTD() q  ;  determine what should be dejournalled
 s %curfile=$$curfile() ; current journal file, or "" if none enabled
 N curfile,jrnfile,djfirst,djlast,prompt,curdir,altdir,prefix,lookpath   
 n tempnode,promptnode ;for prompt=1 & fastrest=2
 N ROLLJRN,dj,notresto,maxsize,shortnam,expqty
 n jrnlist ;a number-index array of the journal files to be processed
 S dj=0,ROLLJRN=0,notresto=0 ;HYY035
 n RestTime s RestTime=$zdt($h,8)
 n RestCount s RestCount=0
 L +^SYS("RESTORE","JOURNAL"):10 e  w:'$g(QUIETMODE) !,*7,"Acquiring lock on "_$name(^SYS("RESTORE","JOURNAL"))_" timed out",!,"Warning on concurrent journal restores is disabled" g postwarnconcur
 i '$g(^SYS("RESTORE","JOURNAL")) s RestCount=1,^SYS("RESTORE","JOURNAL")="1:"_RestTime
 e  d  i 'RestCount L -^SYS("RESTORE","JOURNAL") g exitmain
 . i $g(QUIETMODE) d $zu(9,"","WARNING: Multiple copies of journal restores appear to be running simultaneously. (If that is incorrect, reset "_$name(^SYS("RESTORE","JOURNAL"))_" to 0 after restore completes.)",(0>0),0) i 1
 . e  d  i $$YN("Continue","N")="N" q
 . . w !,?7,"***WARNING: Another journal restore appears to be going on"
 . . w !,"or perhaps a previous journal restore was terminated improperly."
 . . w !,"In the latter case, you may issue the command"
 . . w !?5,"SET "_$name(^SYS("RESTORE","JOURNAL"))_"=0"
 . . w !,"after this restore operation completes."
 . s RestCount=$i(^SYS("RESTORE","JOURNAL")),$p(^SYS("RESTORE","JOURNAL"),",",RestCount)=RestTime,$p(^SYS("RESTORE","JOURNAL"),":")=RestCount
 L -^SYS("RESTORE","JOURNAL")
postwarnconcur ;
    ; restore one or more journal files
 i $g(QUIETMODE) s CHATTY=0,RC=$$nextquiet^JRNRESTO
 e  D
 . S curfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%curfile,";"),0:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),*),:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),$f(%curfile,";")-2)),:%curfile)
 . D SETUP^JRNRESTO Q:$G(notresto)  ;HYY073
 . D:jrnstop  
 . . S %curfile=$ZU(78,3),curfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%curfile,";"),0:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),*),:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),$f(%curfile,";")-2)),:%curfile)
 . . ; prepare for INT^JRNSTART call when we are done
 . . ; curdir, altdir, and prefix are defined in SETUP
 . . S shortnam=curfile,expqty=0,maxsize=$P($ZU(78,22,%curfile,3),",",2)
 . i $g(QUIETMODE),'$g(ROLLJRN) ;don't roll back open transactions
 . e  i $g(fromrest)'=8,'$d(clujrn) d ScanForOpenTrans q:$g(notresto)
 . i $g(fromrest)=8 s fastrest=0 
 . e  d restore^JRNRESTF(.fastrest) i fastrest q
 . e  i '$$InitSort() d  i '($$yesno("Do you want to continue","Y")="Y") s notresto=1 q 
 . . s disablesort=1,(cachetempmaxblks,sortchunklimit)=0
 . . d logmsg("Sorting is disabled",0,1)
 . e  d multrest q
 . d onejobrest
 ; dejrn (or ALL) is used in above restoration. It is not clear to
 ; me whether rolling back partial open transactions is desirable.
 ; For now we ignore dejrn. Maybe we should give the user an option?
ROLLBACK ;
 i 'notresto,$D(tranopen)!$D(badtran) d
 . i $g(QUIETMODE) q:'$g(ROLLJRN)  i 1  ;in QUIETMODE, ROLLJRN decides rollback
 . e  i $$YN("Rollback incomplete transactions",$s($g(ROLLJRN):"Y",1:"N"))="N" q
 . N i s i="" f  s i=$o(^SYS("RESTORE","JOURNAL",RestTime,"Files",i),1,dj) q:i=""  s dj(i)=$p(dj,",")
 . m dj=ScanList 
 . s dj=$g(^SYS("RESTORE","JOURNAL",RestTime,"Files"))_","_$g(ScanList) ;# of files
 . s i=$g(ScanList)
 . ;see if we can find the missing TSTARTs; otherwise we will not
 . ;roll back bad transactions.
 . n a,b,d,d1,d2,f,kill,limit,logmessage
 . n lognewval,logoldval,oldadr
 . i $D(clujrn),$D(tranopen) d
 . . ; If this was a cluster restore then build the dj() array out
 . . ; of the list of open transactions and the clumember(id,"rest")
 . . ; arrays. In a cluster a tranopen() entry has the form:
 . . ;                   adr,shortname,id
 . . ; where id is the cluster member #.
 . . n pid,remsys,line,index,id,transjrn,cnt,jcur,jlast
 . . ;
 . . s pid="" f  s pid=$O(tranopen(pid)) q:pid=""  d
 . . . s remsys="" f  s remsys=$O(tranopen(pid,remsys)) q:remsys=""  d
 . . . . s line=tranopen(pid,remsys)
 . . . . s index=$P(line,",",2)_"J",id=$P(line,",",3)
 . . . . s transjrn(id,index)=""
 . . . . s index=$p($p(line,",",2),":",2)  ;get journal short name
 . . . . s $p(tranopen(pid,remsys),",",2)=index
 . . . . s clutrans(id,pid,remsys)=tranopen(pid,remsys)
 . . ; Now transjrn() contains the list of journal files that contain
 . . ; open transactions for each cluster member. We use the 1st and
 . . ; last journal file in this list to build the list of journal
 . . ; files to process during transaction rollback.
 . . k dj
 . . s dj=0
 . . s id="" f  s id=$O(transjrn(id)) q:id=""  d
 . . . ; combine all restored and unrestored jrn files into one place
 . . . merge clumember(id,"rest")=clumember(id,"files")
 . . . ; get 1st and last journal files for transaction rollback
 . . . s jcur=$O(transjrn(id,"")),jlast=$O(transjrn(id,""),-1)
 . . . ; setup dj(cnt.....cnt+n)=journal files in range of jcur:jlast
 . . . ; transaction rollback runs cnt+n.....cnt so store them 1st->last
 . . . f  d  q:jcur=jlast  s jcur=$O(clumember(id,"rest",jcur)) q:jcur=""
 . . . . s line=clumember(id,"rest",jcur)
 . . . . s dj=dj+1,dj(dj)=$P(clumember(id,"rest",jcur),"^")
 . . . . s djid(dj)=id  ; djid() tracks the id for dj() entries
 . I $D(badtran) D
 . . W !,"There are some open transactions with TSTARTs missing!",! 
 . . i $D(clujrn) d  q
 . . . w !,"This was a cluster restore so we cannot search back for"
 . . . w !,"the corresponding TSTART records. These transactions will"
 . . . w !,"not be rolled back."
 . . Q:$$YN("Look back for missing TSTARTs","N")="N"
 . . D ASKSET("Look back up to file (YYYYMMDD.NNN):",.djfirst)
 . . S %jrnfile="",jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(dj(1),";"),0:$e(dj(1),*-8-$l($p(dj(1),".",$l(dj(1),"."))),*),:$e(dj(1),*-8-$l($p(dj(1),".",$l(dj(1),"."))),$f(dj(1),";")-2)),:dj(1))
 . . F  Q:'(($p(jrnfile,".")>$p(djfirst,"."))||(($p(jrnfile,".")=$p(djfirst,"."))&&($p(jrnfile,".",2)>$p(djfirst,".",2))))  D
 . . . S %jrnfile=$$FINDPREV(.jrnfile) Q:%jrnfile=""
 . . . D open Q:adr=-1
 . . . D SCANBJRN(jrnfile,.badtran,.tranopen)
 . . . D close
 . . . S i=i-1,dj(i)=%jrnfile
 . . . I '$D(badtran) S jrnfile=djfirst Q
 . S $P(dj,",",2)=i
 . ; since a process cannot have an open transaction and a bad
 . ; transaction (TSTART missing) at the same time, merging badtran
 . ; into tranopen should be OK. Merging makes rollback easier.
 . ;M tranopen=badtran
 . ; For clustered systems we make sure that the tranopen array
 . ; only reflects the open transactions for the cluster member
 . ; who's journal we're restoring. The clumember() array has the
 . ; contents of transopen() organized by cluster member. We use
 . ; the scalar version of djid to track which cluster member is
 . ; currently loaded into transopen. When djid(dj) differs from
 . ; djid we kill off transopen and reload it with clutrans from
 . ; the correct cluster member.
 . i $D(clujrn) s djid=-1 ; there isn't a cluster member #-1
 . n dir,noredir s noredir=1,dir="" f  s dir=$o(dejrn(dir)) q:dir=""  s dejrn(dir)=$p(dejrn(dir),",",2,$l(dejrn(dir))) i dejrn(dir)]"",dejrn(dir)'=dir k noredir
 . i $g(noredir) k dejrn  ;no db redirection for rollback
 . e  s dir="" f  s dir=$o(dejrn(dir)) q:dir=""  i dejrn(dir)="" s dejrn(dir)=dir 
 . k ^||ISC.ROLLBACK.bitset
 . s i="" f  s i=$o(dj(i),-1) q:i=""  d
 . . i $D(clujrn),djid'=djid(i) d
 . . . k tranopen 
 . . . merge tranopen=clutrans(djid(i))
 . . . k clutrans(djid(i))
 . . . s djid=djid(i)
 . . q:'$D(tranopen)
 . . S %jrnfile=dj(i),jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile)
 . . d open q:adr=-1
 . . S adr=$zu(78,18,0)
 . . d start^ROLLBACK(.tranopen,adr_","_jrnfile,-1,checkerr,1,.dejrn,"RESTORE")
 . . D close
 . . D CLEAN(jrnfile,.tranopen)
 . K i 
 n tdir,mntst,dismnt
 m nomount=^SYS("RESTORE","JOURNAL",RestTime,"SkipDB")
 i $d(nomount)>1,'$g(QUIETMODE)||$g(DISMDB) { ;DISMDB set via INT()
   s tdir="" f  {
     s tdir=$o(nomount(tdir),1,mntst) q:tdir=""
     i mntst=1 { ;found at least one mounted database that failed to be updated
       s dismnt(tdir)=""
       f  s tdir=$o(nomount(tdir),1,mntst) q:tdir=""  s:mntst=1 dismnt(tdir)=""
       i '$g(QUIETMODE) {
	 d msgout("Some updates of the following database(s) were skipped during journal restore, due to errors. The database(s) might be in an inconsistent state.")
         s tdir="" f  s tdir=$o(dismnt(tdir)) q:tdir=""  d msgout(tdir,4)
         i $$YN("Do you want to dismount the above database(s) (yes/no)")="N" q
       }
       s tdir="" f  s tdir=$o(dismnt(tdir)) q:tdir=""  i $zu(3,tdir)>0 d logmsg(tdir_" dismounted",$g(QUIETMODE),2)
       q
     }
   }
 }
exitmain ;
 k ^||ISC.ROLLBACK.bitset
 s $zt="exitmain1"
 i '$g(zjrnerr),$ze]"" d resterrlog($ze)
 d sortflush()
exitmain1 s $zt=""
     ; restart journaling if we stopped it
 I jrnstop d  ; restart journaling to a new file
 . n curfile,STU,lastfile,jrnall,jrnflag,expqty,maxsize,altdir
 . n curdir,prefix,shortnam,jrnflag,jrninfo,started,err
 . D init^JRNSTART
 . D INT^JRNSTART(curdir,altdir,shortnam,prefix,maxsize,expqty,jrnall,.err)
 . I $G(err)'="" D $zu(9,"","ERROR: "_err,(0>0),0)
 i nojrn d ENABLE^%SYS.NOJRN ; reenable journaling if necessary
 i $g(ZJRNUSE),'$g(zjrnerr) d 
 . i $$YN("Do you want to rename your journal filter","")="Y" d 
 . . x "zl ZJRNFILT zs XJRNFILT zr  zs ZJRNFILT"
 . . w !,"Journal filter ZJRNFILT renamed to XJRNFILT",!
 . . s (ZJRNUSE,ZJRNUSEMARK)=0
 . e  d  
 . . i $$YN("Do you want to delete your journal filter","")="Y" d
 . . . x "zl ZJRNFILT zr  zs ZJRNFILT"
 . . . w !,"Journal filter ZJRNFILT deleted",!
 . . . s (ZJRNUSE,ZJRNUSEMARK)=0
 i $zu(68,1,nullsubstat)  ;restore null subscript setting
 i '$g(RestCount) g exitmain2
 L +^SYS("RESTORE","JOURNAL"):10 e  w:'$g(QUIETMODE) !,*7,"Acquiring lock on "_$name(^SYS("RESTORE","JOURNAL"))_" timed out",!,$name(^SYS("RESTORE","JOURNAL"))_" was NOT updated",! g exitmain2
 i RestCount=1 s ^SYS("RESTORE","JOURNAL")=0
 e  d   ;RestCount>1
 . i '$g(QUIETMODE) d  i $$YN("Reset the count of journal restore to 0")="Y" s ^SYS("RESTORE","JOURNAL")=0 q
 . . w !,"INFO: There appears to be another journal restore going on"
 . . w !,"If NO journal restore is going on, you may fix the count by resetting"
 . s $p(^SYS("RESTORE","JOURNAL"),",",RestCount)=""
 . s $p(^SYS("RESTORE","JOURNAL"),":")=^SYS("RESTORE","JOURNAL")-1
 L -^SYS("RESTORE","JOURNAL")
exitmain2 ;
 q
InitSort() ;
 n cachetempsfn s cachetempsfn=$zu(173) ;sfn of CACHETEMP database
 n cachetempinfo s cachetempinfo=$zu(49,cachetempsfn)
 i +cachetempinfo'=cachetempsfn d logmsg("CACHETEMP unavailable",0,1) q 0
 s cachetempmaxblks=$p($zu(49,cachetempsfn),",",6) ;max size in blocks
 i 'cachetempmaxblks q 1 ;max size unlimited: sortlimit not used; sorting is ON
 n rc,freeMB,cachetempdir s cachetempdir=$p($zu(49,cachetempsfn,3),"^",2) 
 s rc=##class(SYS.Database).GetDatabaseFreeSpace(cachetempdir,.freeMB)
 i 'rc d logmsg($System.Status.GetErrorText(rc),0,1) q 0 ;disable sorting on err
 s cachetempblksiz=$p($zu(49,cachetempsfn),",",2)
 s freeMB=cachetempmaxblks-$p(cachetempinfo,",",22)*cachetempblksiz/(1024*1024)+freeMB\1
 n sortlimitKB s sortlimitKB=freeMB*1024\4 ;limit for *all* sort jobs, in KBs
 n sortsizeKB s sortsizeKB=$case($v($zu(40,1,31),-1,4),0:1024,:$v($zu(40,1,31),-1,4)) ;memory size for sorting, in KBs
 n numsort s numsort=sortlimitKB\sortsizeKB
 i 'numsort d  q 0 ;not enough free space for even one sort job; disable sorting
 . d logmsg("Insufficient free space ("_freeMB_"MB) in CACHETEMP for sorting size "_(sortsize\1024)_"MB -- additional "_(sortsizeKB\1024*4-freeMB+1)_"MB free space is required",0,1)
 i numsort<numrestjobs s numrestjobs=numsort
 s sortchunklimit=sortlimitKB*1024\$ZU(40,0,20)
 q 1
ScanForOpenTrans ;
 n firstpath,lastpath,jrnfilecnt,minxfilecnt,minxfileoff,name
 i $d(JrnDirList) m lookpath=JrnDirList ;need it to locate files on PriorList
 s $zt="ErrorScanForOpenTrans"
 i $d(jrnlist) {
   i $o(jrnlist(""),-1,lastpath)
   i $o(jrnlist(""),1,firstpath)
 } elseif $d(JrnFileList) { ;we have a list of source journal files to restore
   i $o(JrnFileList(""),1,firstpath)
   s name=$$GetJrnFileName(firstpath)
   s firstpath=$$FULLPATH(name)
   i firstpath="" w !,*7,"*** Unable to locate journal file ",name,! zt "FILE"
   i $o(JrnFileList(""),-1,lastpath)
   s name=$$GetJrnFileName(lastpath)
   s lastpath=$$FULLPATH(name)
   i lastpath="" w !,*7,"*** Unable to locate journal file ",name,! zt "FILE"
 } else {
   s lastpath=$$FULLPATH(djlast)
   s firstpath=$$FULLPATH(djfirst)
 }
 s minxfilecnt=$zu(78,22,lastpath,18)
 i minxfilecnt<=0 w !,*7,"*** ",lastpath_$case(+minxfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
 s minxfilecnt=$p(minxfilecnt,",",2)
 s jrnfilecnt=$zu(78,22,firstpath,12)
 i jrnfilecnt<=0 w !,*7,"*** ",firstpath_$case(+jrnfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
 s jrnfilecnt=$p(jrnfilecnt,",",2)
 i minxfilecnt>jrnfilecnt q  ;no open trans prior to the 1st file
 i minxfilecnt=jrnfilecnt {
   i '$g(DEJRNSTART) q  ;no open trans prior to the 1st file
   ;i $p(DEJRNSTART,",",2)=firstpath (sanity check??)
   s minxfileoff=$zu(78,22,lastpath,19)
   i minxfileoff<=0 w !,*7,"*** ",lastpath_$case(+minxfileoff,0:" does not exist",:" is not a journal file"),! zt "FILE"
   s minxfileoff=$p(minxfileoff,",",2)
   i minxfileoff>=DEJRNSTART q  ;no open trans prior to the start of restore
   w !,"To scan the first journal file for open transactions --"
   d ScanOneJrnForOpenTrans($p(DEJRNSTART,",",2),+DEJRNSTART)
   q
 } 
 n index,jrnfpath,curfilecnt,jrnstop
 i $d(PriorList) {
   s index="" f  {
     s index=$o(PriorList(index),-1,jrnfpath) 
     i index="" w !,*7,"*** Missing previous ",jrnfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     i $d(JrnDirList) {
       s name=$$GetJrnFileName(jrnfpath)
       s jrnfpath=$$FULLPATH(name)
       i jrnfpath="" w !,*7,"*** Unable to locate journal file ",name," that may contain TSTARTs",! zt "FILE"
     }
     s curfilecnt=jrnfilecnt
     s jrnfilecnt=$zu(78,22,jrnfpath,12)
     i jrnfilecnt<=0 w !,*7,"*** ",jrnfpath_$case(+jrnfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
     s jrnfilecnt=$p(jrnfilecnt,",",2)
     i jrnfilecnt<minxfilecnt w !,*7,"*** Missing ",curfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     s ScanList($i(ScanList,-1))=jrnfpath ;jrnfilecnt>=minxfilecnt
     i jrnfilecnt=minxfilecnt q
   }
 } else {
   s jrnfpath=firstpath
   f  {
     s jrnfpath=$$findprev(jrnfpath,.jrnstop) i $g(jrnstop) q
     i jrnfpath="" w !,*7,"*** Missing previous ",jrnfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     s curfilecnt=jrnfilecnt
     s jrnfilecnt=$zu(78,22,jrnfpath,12)
     i jrnfilecnt<=0 w !,*7,"*** ",jrnfpath_$case(+jrnfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
     s jrnfilecnt=$p(jrnfilecnt,",",2)
     i jrnfilecnt<minxfilecnt w !,*7,"*** Missing ",curfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     s ScanList($i(ScanList,-1))=jrnfpath ;jrnfilecnt>=minxfilecnt
     i jrnfilecnt=minxfilecnt q
   }
 }
 i $d(ScanList) w !,"To scan older journal files for open transactions --"
 s index="" f  {
   s index=$o(ScanList(index),1,jrnfpath) q:index=""
   d ScanOneJrnForOpenTrans(jrnfpath)
 }
 i '$d(tranopen) k ScanList
 i $g(DEJRNSTART) {
   w:'$d(ScanList) !,"To scan the first journal file for open transactions --"
   d ScanOneJrnForOpenTrans($p(DEJRNSTART,",",2),+DEJRNSTART)
 }
 q
ErrorScanForOpenTrans s $zt=""
 i $ze["<INTERRUPT>" { ;CTRL-C by user to abort scanning
   w !,"User aborted scanning older journal files for open transactions.",!
   w "Tranactions started in those files might remain open after the restore.",!
   s $ze=""
   q
 }
 w !,"ERROR: ",$ze,!
 w !,"There is a problem with searching for open transactions in older files."
 i $g(QUIETMODE) {
   w !,"Restore will continue, but transactions started in files earlier than"
   w !,"the first one to be restored might remain open after the restore."
 } else {
   w !,"If you decide to continue, transactions started in files earlier than"
   w !,"the first one to be restored might remain open after the restore."
   i ($$yesno("Do you want to abort","Y")="Y") s notresto=1
 }
 i '$d(tranopen) k ScanList
 s $ze=""
 q 
ScanOneJrnForOpenTrans(jrnfpath,endaddr) ;
 n dev,addr,next,type,name
 s dev=$zu(78,5,jrnfpath,0) 
 i dev<0 w !,*7,"*** Unable to open ",jrnfpath,! zt "OPEN"
 s $zt="ErrScanOneJrn",$ze=""
 d $zu(78,6,dev)
 s name=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfpath,";"),0:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),*),:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),$f(jrnfpath,";")-2)),:jrnfpath)
 w !,"Scanning ",jrnfpath,$s($g(endaddr):" up to "_endaddr,1:"")," ..."
 s addr="" f  {
   s next=$zu(78,17,addr) q:next'>0  i $g(endaddr),next>endaddr q
   s addr=next
   s type=$zu(78,8,addr)
   i type=4 {
     s tranopen($zu(78,10,addr),$ZU(78,25,addr))=addr_","_name
   } elseif type=5 {
     k tranopen($zu(78,10,addr),$ZU(78,25,addr))
   }
 }
 d $zu(78,7,dev)
 q
ErrScanOneJrn s $zt="" 
 d $zu(78,7,dev)
 ztrap $ze
SCANBJRN(jf,bad,opn) ;scan backward journal file jf to find TSTARTs
 N (jf,bad,opn)
 S adr=$zu(78,18,0) 
 F  S adr=$zu(78,18,adr) Q:adr'>0  D:$zu(78,8,adr)=4
 . Q:'$D(bad($zu(78,10,adr),$ZU(78,25,adr)))
 . K bad($zu(78,10,adr),$ZU(78,25,adr))
 . S opn($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jf
 Q
 ; input: 
 ;       opn: tranopen
 ;       jf: journal file name (short)
CLEAN(jf,opn) ;clears opn entries with jf as 2nd data field 
 N (opn,jf)
 S pid=""
 F  S pid=$O(opn(pid)) Q:pid=""  D
 . S remsysid="" 
 . F  S remsysid=$O(opn(pid,remsysid)) Q:remsysid=""  D
 . . I $P(opn(pid,remsysid),",",2)=jf K opn(pid,remsysid)
 Q
nextfileE s $zt=""
 i $g(clu)]"",clu'<0 d close s clu=-1 ;close any open file
 i $g(zjrnerr) ztrap $ze 
jrnfileE s $zt=""  ;this entry point is shared with nxtcluupd/nxtclufile
 i $ze["<Z" d logmsg($g(resterr),0,2) i 1
 e  d logmsg("Error processing journal file "_$g(%jrnfile)_": "_$ze,0,2)
 i $d(restopt(2)) s zjrnerr=(restopt'[2) i 1 
 e  i $g(CHATTY) d
 . w !,"It is recommended that you abort dejournaling at this point. However,"
 . w !,"if you want to continue, we will have to skip this file."
 . s zjrnerr='($$yesno("Do you want to continue","N")="Y")
 i $g(zjrnerr) ztrap $ze
 d logmsg("Skipping journal file "_$g(%jrnfile),0,0)
 s $ze=""
 q
nextfile ;
 s $zt="nextfileE"
 n currfile s currfile=jrnfile
 N a,b,findnexterr
 i $d(jrnlist) d  g nextfileopen ;HYY1500
 . i jrnfile="" ztrap:$g(jrnlist) "JLST" i 1 ;expect jrnfile="" => jrnlist=""
 . e  i '$g(jrnlist) ztrap "JLST" ;expect jrnlist="" => jrnfile=""
 . e  i $case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnlist(jrnlist),";"),0:$e(jrnlist(jrnlist),*-8-$l($p(jrnlist(jrnlist),".",$l(jrnlist(jrnlist),"."))),*),:$e(jrnlist(jrnlist),*-8-$l($p(jrnlist(jrnlist),".",$l(jrnlist(jrnlist),"."))),$f(jrnlist(jrnlist),";")-2)),:jrnlist(jrnlist))'=jrnfile ztrap "JLST"
 . s jrnlist=$o(jrnlist($g(jrnlist)),1,%jrnfile) ;$g(jrnlist) is the index
 . i jrnlist,%jrnfile]"" s jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile) q
 . d logmsg("Unable to continue further due to an error locating the file following "_$g(prefix)_currfile,0,2) s zjrnerr=1 ztrap "FILE"
 e  i $d(JrnFileList) d  g nextfileopen 
 . i jrnfile="" ztrap:$g(JrnFileList) "JLST" i 1 ;expect jrnfile="" => JrnFileList=""
 . e  i '$g(JrnFileList) ztrap "JLST" ;expect JrnFileList="" => jrnfile=""
 . e  i $case($ZBITGET($ZVERSION(0),46),0:$case($f(JrnFileList(JrnFileList),";"),0:$e(JrnFileList(JrnFileList),*-8-$l($p(JrnFileList(JrnFileList),".",$l(JrnFileList(JrnFileList),"."))),*),:$e(JrnFileList(JrnFileList),*-8-$l($p(JrnFileList(JrnFileList),".",$l(JrnFileList(JrnFileList),"."))),$f(JrnFileList(JrnFileList),";")-2)),:JrnFileList(JrnFileList))'=jrnfile ztrap "JLST"
 . s JrnFileList=$o(JrnFileList($g(JrnFileList)),1,%jrnfile) ;$g(JrnFileList) is the index
 . i 'JrnFileList||(%jrnfile="") d  q  ;shouldn't be here
 . . d logmsg("Unable to continue further due to an error locating the "_$s(currfile="":"first file",1:"file following ")_$g(prefix)_currfile,0,2) 
 . . s zjrnerr=1 ztrap "FILE"
 . s jrnfilename=$$GFILE^SHDWCBLK(%jrnfile) ;jrnfilename contains prefix if any
 . s jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile) ;jrnfile doesn't contain any prefix
 . s i="" f  s i=$o(lookpath(i)) q:i=""  s %jrnfile=lookpath(i)_jrnfilename i $ZU(78,22,%jrnfile)>0 q
 . i i="" d logmsg("Unable to continue further due to an error locating the file "_jrnfilename_" in given directories",0,2) s zjrnerr=1 ztrap "FILE"
 e  i jrnfile="" S jrnfile=djfirst,%jrnfile=$$FULLPATH(djfirst) i 1
 e  s %jrnfile=$$FINDNEXT(.jrnfile,.findnexterr)
 i prompt {
   s b=%jrnfile
   f  {
     i $g(CHATTY) { ;interactive job
       W !!,"Restore From Journal File: ",jrnfile," =>" R a,!
     } else {  ;fastrest=2
       k @promptnode@("input")
       s @promptnode@("default")=jrnfile
       s a=0 f  {
         i $d(@promptnode@("input")) q
	 h .01
	 i $i(a)#1000=0 { ;generate a message every 10 seconds
	   d logmsg("Waiting for user input on next file to restore",1,0)
	 }
       }
       s a=@promptnode@("input")
       k @promptnode@("default")
     }
     i (a="")||(a=jrnfile) q  ;use jrnfile and %jrnfile we have got
     I $$STOP(a) s zjrnerr=1 ztrap "FILE"
     S b=%jrnfile,%jrnfile=$$FULLPATH(a) 
     i %jrnfile'="" q
     i $g(CHATTY) { ;interactive job
       W "Cannot locate the file",! 
     } else {
       s @promptnode@("error")="Cannot locate the file"
     }
     s %jrnfile=b
   }
   s @promptnode@("error")=""
   i a'="",a'=jrnfile s jrnfile=a
   i (($p(jrnfile,".")>$p(djlast,"."))||(($p(jrnfile,".")=$p(djlast,"."))&&($p(jrnfile,".",2)>$p(djlast,".",2)))) q
 }
 i (($p(jrnfile,".")>$p(djlast,"."))||(($p(jrnfile,".")=$p(djlast,"."))&&($p(jrnfile,".",2)>$p(djlast,".",2)))) d  q
 . s clu=-1 
 . d logmsg("Unable to continue further due to the missing file following "_$g(prefix)_currfile,0,2) s zjrnerr=1 ztrap "FILE"
 i %jrnfile="" d  s %jrnfile=$$FULLPATH(jrnfile) ;to continue on to open
 . s clu=-1 
 . i $g(findnexterr)'="" d logmsg(findnexterr,0,2) s zjrnerr=1 ztrap "FILE"
 . i $$FULLPATH(jrnfile)="" d logmsg("Unable to continue further due to the missing file "_$g(prefix)_jrnfile,0,2) s zjrnerr=1 ztrap "FILE"
 . i currfile=jrnfile d logmsg("Unable to continue further due to an error locating the file following "_$g(prefix)_currfile,0,2) s zjrnerr=1 ztrap "FILE"
 . s $zt="nextfileE"
 . s resterr="File(s) missing between '"_$g(prefix)_currfile_"' and '"_$g(prefix)_jrnfile_"' " 
 . ztrap "FILE"
nextfileopen ;HYY1500
 d open i adr=-1 q
 i +$g(DEJRNSTART),$p(DEJRNSTART,",",2)=%jrnfile s adr=+DEJRNSTART
 n i s i=$i(^SYS("RESTORE","JOURNAL",RestTime,"Files"))
 s ^SYS("RESTORE","JOURNAL",RestTime,"Files",i)=%jrnfile_","_$zdt($h,8)
 s:adr ^SYS("RESTORE","JOURNAL",RestTime,"Files",i,"StartAddress")=adr
 i fastrest {
   d finish ;DejrnFile will open it again
   i jrnfile=djfirst d $zu(78,53,shrid,1,0,adr,%jrnfile)
   s clu=$$DejrnFile^JRNRESTF(%jrnfile,adr,shrid)
   i fastrest>1 q
 } else { 
   s $zt="nextfileE" i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
 }
 W !        
     ;
begin ;begin recovering from JOURNAL
 d output^%Wprim($c(13,10)_%jrnfile)
 w ! ;given the above output^%Wprim, a new line is all we need
 n count s lastindex=$zu(78,18,0)
   ; find next record to restore and restore it
   ; after every #num restores, print the % of file processed
 N num S num=$$InitDispCount(lastindex)
 s lastindex=$zu(78,18,lastindex) ;used in nextupd, consistent with restoreone (cf. findfiles^JRNRESTC2)
 i lastindex s count=0 f  d nextupd q:type=-1  d restore q:$g(zjrnerr)=1  i $i(count)>num w $j(adr*100/lastindex,7,2)_"%" s count=0,percentdone=(adr*100/lastindex)_","_%jrnfile i $g(cachetempmaxblks) d sortlimit ;s rc=##class(SYS.Database).GetDatabaseFreeSpace("cachetemp",.freeMB) w $j(freeMB,4,1),$j($$$GetpSortChunks,4)
 s lastindex=$zu(78,18,0) ;probably not needed
 d sortflush()
 i '$g(zjrnerr) w $j(100,6,2)_"%" d output^%Wprim("***Journal file finished at "_$ztime($p($h,",",2)))
finish s a=$zu(78,7,clu),clu=-1
clo2 i $g(ZJRNUSE)=1,'$g(zjrnerr) d
 . i $$YN("Do you want to rename your journal filter","")="Y" d
 . . x "zl ZJRNFILT zs XJRNFILT zr  zs ZJRNFILT"
 . . w !,"Journal filter ZJRNFILT renamed to XJRNFILT",!
 . . s (ZJRNUSE,ZJRNUSEMARK)=0
 . e  d
 . . i $$YN("Do you want to delete your journal filter","")="Y" d
 . . . x "zl ZJRNFILT zr  zs ZJRNFILT"
 . . . w !,"Journal filter ZJRNFILT deleted",!
 . . . s (ZJRNUSE,ZJRNUSEMARK)=0
 q
Error s $zt=""
 ztrap $ze
InitDispCount(lastindex) ;
 n num s num=lastindex\10000 S:num<100 num=100 ;minimum check count 
 i $g(cachetempmaxblks),num*2>sortchunklimit s num=sortchunklimit\2
 q num
findprev(jrnfpath,jrnstop) ;find the journal file preceding jrnfpath
 n prev,name,path
 s jrnstop=0 ;if jrnstop=0, returning "" is considered an error by caller
 s prev=$P($zu(78,22,jrnfpath,1),",",2) ;jrnfpath is assumed a valid journal file
 i prev="" s jrnstop=1 q "" ;we have reached JRNSTOP
 i $g(prefix)="" {
   s name=$$GetJrnFileName(prev) ;name may or may not contain a prefix
 } else {
   s name=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prev,";"),0:$e(prev,*-8-$l($p(prev,".",$l(prev,"."))),*),:$e(prev,*-8-$l($p(prev,".",$l(prev,"."))),$f(prev,";")-2)),:prev) ;name only, excluding directory and prefix
 }
 s path=$$FULLPATH(name) ;match name with files in given directories
 q path ;found previous file if path'=""
FINDPREV(jf) ;find the journal file preceding jf
 N date,seq,pjf,days,days0
 S date=$P(jf,".",1),seq=$P(jf,".",2),pjf=""
 I seq>1 D  Q:pjf'="" pjf
 . S jf=date_"."_$s((seq)<101:$e((seq)-1+1000,2,4),1:(seq)-1)
 . S pjf=$$FULLPATH(jf)
 ;pjf="" so far
 S days=$zdh(date,8),days0=$zdh($P(djfirst,".",1),8)        
 F  D  Q:days<days0  S pjf=$$FULLPATH(jf) Q:pjf'=""  
 . S days=days-1 
 . S jf=$zd(days,8)_".001"
 Q pjf
FINDNEXT(jf,err) ;find the journal file following jf; err (if any) on return
 N date,seq,pjf,days,curdays,date1
 n jrnfpath s jrnfpath=$$FULLPATH(jf) i jrnfpath="" q ""  ;error condition
 n nextjrnf s nextjrnf=$P($zu(78,22,jrnfpath,2),",",2) 
 i nextjrnf]"" {
   n jrnfilename,nextprefix 
   s jrnfilename=$$GetJrnFileName(nextjrnf) ;with prefix if any
   s nextprefix=$$GJrnPrefix(jrnfilename)
   i $g(prefix)'=nextprefix {
     s err="Unable to continue as the file following '"_jrnfpath_"' has a different prefix '"_nextprefix_"'"
     q ""
   }
   s jf=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfilename,";"),0:$e(jrnfilename,*-8-$l($p(jrnfilename,".",$l(jrnfilename,"."))),*),:$e(jrnfilename,*-8-$l($p(jrnfilename,".",$l(jrnfilename,"."))),$f(jrnfilename,";")-2)),:jrnfilename) ;without prefix
   s nextjrnf=$$FULLPATH(jf) q nextjrnf
 }
 S date=$P(jf,".",1),seq=$P(jf,".",2),pjf=""
 I seq<(2**31-1) D  i pjf]"" g verify
 . S jf=date_"."_$s((seq)<99:$e((seq)+1001,2,4),1:(seq)+1)
 . S pjf=$$FULLPATH(jf)
 ;pjf="" so far
 S days=$zdh(date,8),curdays=$P($H,",",1)        
 F  D  Q:days>curdays  S pjf=$$FULLPATH(jf) Q:pjf'=""  
 . S days=days+1 
 . s jf=$zd(days,8)_".001"
 i pjf="" q ""
verify ;
 n prevjrnf s prevjrnf=$P($zu(78,22,pjf,1),",",2) i prevjrnf]"",$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevjrnf,";"),0:$e(prevjrnf,*-8-$l($p(prevjrnf,".",$l(prevjrnf,"."))),*),:$e(prevjrnf,*-8-$l($p(prevjrnf,".",$l(prevjrnf,"."))),$f(prevjrnf,";")-2)),:prevjrnf)'=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfpath,";"),0:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),*),:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),$f(jrnfpath,";")-2)),:jrnfpath) q ""
 Q pjf
 ;
 ; input:
 ;       jf,prefix,lookpath
FULLPATH(jf) ;returns the full name of jf if it exists; otherwise, ""
 N f,i
 S i=1
 if $ZBITGET($ZVERSION(0),46) {
	 ; for USEDSONLY, there are no short names and long names
	 if $ZU(78,22,f) {
		 quit f
	 }
	 quit ""
 }
 F  S f=lookpath(i)_$G(prefix)_jf Q:$ZU(78,22,f)>0  S i=i+1 Q:i>lookpath
 Q:i>lookpath ""
 Q f
STURestore ;Restore loop for STU^JRNRESTO
 n colseq,curcol
 n lastindex s lastindex=$zu(78,18,$zu(78,18,0))
 f  d nextupd q:type=-1  d restore ;HYY073
 q
restoreone(id,index) ;
 ; Called from JRNCLUREST2.
 ; 
 ; This is a journal file from a system that was not part of
 ; the cluster at the time so just use the standard journal
 ; restore code to process it.
 ; 
 ; Many of the following variables are from JRNRESTO/JRNRESTB
 n line,%jrnfile,adr,num,count,lastindex,type,a,clu,zjrnerr,zjrnerrmsg,jrnfile
 n cd,gnode,r,glo,new,zpid,zdir,zglo,ztype,zremsys,restmode
 n colseq,curcol,x
 ;         
 s clu=-1
 s $ZT="restoneerr"
 ;
 s line=clumember(id,"files",index)
 k clumember(id,"files",index)  ; we're restoring this so remove it
 ;
 ; jrnfile is recorded in badtrans/transopen where as %jrnfile is
 ; the actual journal file name.
 ;
 s %jrnfile=$P(line,"^",1)
 s jrnfile=$e(index,1,$L(index)-1)_","_id
 s lastindex=$P(line,"^",6)
 s num=$$InitDispCount(lastindex)
 w !,"Restoring: ",%jrnfile," from cluster member #",id
 w !
 d open^JRNRESTO d:adr=-1 openerr^JRNRESTO
 i lastindex s count=0 f  d nextupd q:type=-1  d restore q:$g(zjrnerr)=1  i $i(count)>num w $j(adr*100/lastindex,7,2)_"%" s count=0,percentdone=(adr*100/lastindex)_","_%jrnfile i $g(cachetempmaxblks) d sortlimit
 w $j("100",7,2),"%"
 s a=$zu(78,7,clu),clu=-1
 ; We restored this journal so record that here
 s clumember(id,"rest",index)=line
 q
restoneerr ;
 s chan=clu  ; resterr expects the open channel in "chan"
 d resterr^JRNCLUREST
 q
 ;
clurestore(maxseq) ;
 ; Called from JRNCLUREST.
 ; 
 ; Perform the cluster restore starting with the journal records
 ; loaded into jrnseq(). The format of jrnseq() (from cluopen) is:
 ;     jrnseq(seq,chan)=offset^type^id^index
 ; If maxseq is not 0, then this is the highest sequence # that we
 ; want to restore. Once we reach that sequence number we don't restore
 ; any more records from any journal files for that cluster member.
 ;
 n seq,chan,line,adr,a,id,index,nxtseq,recseq,num,count
 n colseq,curcol
 n bitpos,newbitval
 ;
 ; totbytes is the total # of bytes being restored for this run
 ; sumbytes is the # of bytes in the journal files we've finished
 ;   with so far.
 ;
 ; Add up the # of bytes being restored during this cluster mstart
 s progmsg="    completed processing "
 s totbytes=0,sumbytes=0
 i fastrest d  ;to reopen the files with shrid
 . n newchan,addr,jrnf
 . s seq="" f  s seq=$O(jrnseq(seq)) q:seq=""  d
 . . n jrnchan m jrnchan=jrnseq(seq) k jrnseq(seq)
 . . s chan="" f  s chan=$O(jrnchan(chan)) q:chan=""  d
 . . . s line=jrnchan(chan),id=$P(line,"^",3),index=$P(line,"^",4)
 . . . s jrnf=$P(clumember(id,"files",index),"^"),addr=+line
 . . . d $zu(78,7,chan) 
 . . . s newchan=$$DejrnFile^JRNRESTF(jrnf,addr,shrid) 
 . . . s jrnseq(seq,newchan)=line
 s seq="" f  s seq=$O(jrnseq(seq)) q:seq=""  s chan=""  d
 . f  s chan=$O(jrnseq(seq,chan)) q:chan=""  d
 . . s line=jrnseq(seq,chan),id=$P(line,"^",3),index=$P(line,"^",4)
 . . s sumbytes=sumbytes+$P(line,"^")
 . . s line=clumember(id,"files",index)
 . . f  d  q:index=""  
 . . . s totbytes=totbytes+$P(line,"^",6)
 . . . s index=$O(clumember(id,"files",index))
 . . . q:index=""
 . . . s line=clumember(id,"files",index)
 . . . i $P(line,"^",9)'=tstamp s index=""  ; we're done
 w !,"Processing cluster start: "
 s a=$zdth(tstamp,-2) w $ZD(a)," ",$ZT($P(a,",",2),4)
 s num=totbytes\10000 s:num<100 num=100,adr=0
 w !,?5 W $j("0",6,2),"% "
 s count=0
 f  s seq=$O(jrnseq("")) q:seq=""  d
 . f  s chan=$O(jrnseq(seq,"")) q:chan=""  s line=jrnseq(seq,chan) d
 . . k jrnseq(seq,chan)
 . . s a=$zu(78,6,chan)
 . . s adr=$P(line,"^"),type=$P(line,"^",2),id=$P(line,"^",3)
 . . s index=$P(line,"^",4)
 . . i maxseq&(seq>maxseq) d  q
 . . . s clumember(id,"rest",index)=clumember(id,"files",index)
 . . . k clumember(id,"files")
 . . . s a=$zu(78,7,chan),chan=-1
 . . s sumbytes=sumbytes-adr
 . . s nxtseq=$O(jrnseq(""))
 . . i maxseq&(nxtseq=""!(nxtseq>maxseq)) s nxtseq=maxseq
 . . ; jrnfile is used in transopen/badtrans along with the address
 . . ; for tracking transactions during the journal restore
 . . s %jrnfile=$P(clumember(id,"files",index),"^",1)
 . . s jrnfile=$E(index,1,$L(index)-1)_","_id
 . . s recseq=seq f  d restore:(recseq'<seq),nxtcluupd q:type=-1  s recseq=$zu(78,11,adr) q:nxtseq'=""&(recseq>nxtseq)  s count=count+1 d:count'<num dispcnt
 . . s:type'=-1 sumbytes=sumbytes+adr
 . . ; If we stopped because we reached the end of the journal files
 . . ; from this system for this cluster mstart then nxtclufile closed
 . . ; the journal and updated the clumember() array. If we stopped
 . . ; because maxseq is defined, and we've restored that sequence
 . . ; number, then kill off the rest of clumember(id,"files")
 . . ; because we just restored the last journal file for this cluster
 . . ; member.
 . . i (type'=-1)&maxseq&(nxtseq=maxseq) d  q
 . . . s clumember(id,"rest",index)=clumember(id,"files",index)
 . . . k clumember(id,"files")
 . . . s a=$zu(78,7,chan),chan=-1
 . . . s type=-1,adr=-1,jrnfile=""
 . . ; If there are more journal records to restore for this cluster
 . . ; member, create a new jrnseq() entry for it.
 . . s:type'=-1 jrnseq(recseq,chan)=adr_"^"_type_"^"_id_"^"_index
 w:$X>70 ! w:'$X ?5 w $J(100,6,2),"%"
 ;
 q
dispcnt ;
 w:$X>70 !
 w:'$X ?5
 w $J((adr+sumbytes)*100/totbytes,6,2),"% "
 s count=0
 s percentdone=((adr+sumbytes)*100/totbytes)_","_$g(tstamp)
 i $g(cachetempmaxblks) d sortlimit
 q
 ;
nxtcluupd ;
 ; Called to get the next adr to restore from this cluster member.
 ; If we reach the end of a journal file for this cluster member
 ; we move it from clumember(id,"files") to clumember(id,"rest")
 s nextadr=$zu(78,17,adr) g nxtclufile:'nextadr s adr=nextadr
 s type=$zu(78,8,adr)
 ;if it is SET/KILL, check to see if we care. If we do, leave it to
 ;restore; otherwise, skip to the next record
 i (type=6)!(type=7)!(type=9)!(type=14) D  Q:$G(modify)!ALL  g nxtcluupd
 . D:'ALL check
 . Q:'$zu(78,9,adr)  ;optimized for (modify!ALL)&`jrntrans
 . D:($G(modify)!ALL)
 . . ;make sure it is not already in either tranopen or badtran
 . . Q:$D(tranopen($zu(78,10,adr),$ZU(78,25,adr)))
 . . Q:$D(badtran($zu(78,10,adr),$ZU(78,25,adr)))
 . . S badtran($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 ;restore does not care about TSTART/TCOMMIT.
 ;if 2nd TSTART for the same pid appears, 1st one will be forgotten or
 ;ignored. it would be better if tranopen and badtran are combined 
 ;into one.
 i type=4 d  g nxtcluupd
 . s tranopen($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 i type=5 d  g nxtcluupd
 . k tranopen($zu(78,10,adr),$ZU(78,25,adr))
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 g:type'=-1 nxtcluupd
nxtclufile ;
 s lastadr=$zu(78,18,$zu(78,18,0)) i adr<lastadr d
 . s $zt="jrnfileE"
 . s resterr="Journal "_$g(%jrnfile)_" ends unexpectedly at "_adr_" (end expected at "_lastadr_") - possible corruption in the journal" 
 . ztrap "JEND"  
 ; We reached the end of this file, see if there's another journal
 ; file from this cluster member for this cluster start
 ;
 s n=$zu(78,7,chan),chan=-1 ; close this journal file
 s n=clumember(id,"files",index)
 w:$X !
 w progmsg,$case($ZBITGET($ZVERSION(0),46),0:$case($f($P(n,"^"),";"),0:$e($P(n,"^"),*-8-$l($p($P(n,"^"),".",$l($P(n,"^"),"."))),*),:$e($P(n,"^"),*-8-$l($p($P(n,"^"),".",$l($P(n,"^"),"."))),$f($P(n,"^"),";")-2)),:$P(n,"^"))," for cluster member #",id,!
 s sumbytes=sumbytes+$P(n,"^",6)
 s clumember(id,"rest",index)=clumember(id,"files",index)
nxtcfile2 ;
 k clumember(id,"files",index)
 s index=$O(clumember(id,"files",index))
 g:index="" nxtcfiledone
 s line=clumember(id,"files",index)
 i $P(line,"^",9)=tstamp d  g:chan=-1 nxtcfile2 g nxtcluupd
 . s %jrnfile=$P(line,"^",1)
 . s chan=$zu(78,5,%jrnfile,0)
 . i chan=-1 d openerr^JRNCLUREST q
 . s n=$zu(78,6,chan)
 . s adr=0
 . i fastrest d  ;i fastrest>1 q  ;fastrest=2 doesn't work with cluster restore
 . . d $zu(78,7,chan) s chan=-1 
 . . s chan=$$DejrnFile^JRNRESTF(%jrnfile,adr,shrid) 
 . s jrnfile=$e(index,1,$L(index)-1)_","_id
nxtcfiledone ;
 s type=-1,adr=-1,jrnfile=""
 q
 ;
cluadjstartpos ;
 s seq="" 
 f  s seq=$O(jrnseq(seq)) q:seq=""!(seq'<minseq)  d
 . i 'flag d
 . . s flag=1 
 . . w !,"Discarding records prior to sequence #",minseq
 . . s progmsg="   skipped journal file "
 . s chan="" f  s chan=$O(jrnseq(seq,chan)) q:chan=""  d
 . . s line=jrnseq(seq,chan)
 . . k jrnseq(seq,chan)
 . . s n=$zu(78,6,chan)
 . . s adr=$P(line,"^"),type=$P(line,"^",2),id=$P(line,"^",3)
 . . s index=$P(line,"^",4)
 . . f  d nxtcluupd q:type=-1  s recseq=$zu(78,11,adr) q:recseq'<minseq
 . . s:type'=-1 jrnseq(recseq,chan)=adr_"^"_type_"^"_id_"^"_index
 q
   ;
   ; restore the current record if its directory is mountable
   ; input variables: type,adr
   ; get directory and make sure it is mounted
   ; HYY419: curcol should be loaded with the current collation
   ;             sequence. On exit, the current collation sequence for
   ;             the process may have changed and the caller should save
   ;             and restore the original if so desired.
restore i checkerr s $zt="skiprec"
 i type=13 d:$g(ZJRNUSEMARK)  q  ;skip journal marker record
 . s $zt="ZJRNERR",x=$ZU(78,35,adr) 
 . d MARKER^ZJRNFILT(adr,%jrnfile,$p(x,","),$p(x,",",2),$p(x,",",3),$p(x,",",4,$l(x)))
 S dir=$zu(78,12,adr),new=dir I 'ALL S new=$G(dejrn(dir)),new=$P(new,",",2,$L(new)) S:'$L(new) new=dir
 ;1st time for each directory, check if it can't be mounted...
 if ($G(fromrest)'=8),'$D(dir(new)) Q:$D(nomount(new))  Q:'$$mount(new,adr,%jrnfile)
 ;
 n zt,zremsys,zpid,zdir,zglo,ztype,restmode
 i $g(ZJRNUSE) d  q:'restmode
 . i ($zversion(1)=1) s zpid=$zh($zu(78,10,adr)),zdir=$zu(12,$zu(78,12,adr)),zglo=$zu(78,13,adr),zglo="^"_$p(zglo,"]",3,$l(zglo))
 . i '($zversion(1)=1) s zpid=$zu(78,10,adr),zdir=$zu(12,$zu(78,12,adr)),zglo=$zu(78,13,adr),zglo="^"_$p(zglo,"]",2,$l(zglo))
 . i type=6 s ztype="S"
 . i type=14 s ztype="s"
 . i type=7 s ztype="K"
 . s zremsys=$ZU(78,25,adr) 
 . i zremsys s zpid=zpid_","_zremsys
 . i type=9 s ztype="ZK"
 . s zt=$zt,$zt="ZJRNERR",restmode=0 
 . d ^ZJRNFILT(zpid,zdir,zglo,ztype,.restmode,adr,$zu(78,24,adr))
 . s $zt=zt
 if $G(fromrest)=8 d  q  ; This is a JCONVERT operation
 . s gref=$zu(78,13,adr)
 . i 'includedir s gref="^"_$p(gref,"]",$l($qs(gref,-1),"]")+1,999) ; strip dir
 . i type=6 s value=$zu(78,15,adr) 
 . e  i type=14 s value=$zu(78,36,adr)_","_$zu(78,37,adr)
 . e  s value=""
 . n xval s xval=$zcvt(value,"O",xlate)
 . i (fmode1="V")||((fmode1="U")&&(recsep=+recsep)),$l(xval)>65534 d
 . . d $zu(9,"","Value length "_$l(xval)_" exceeds limit",(0>0),0)
 . . d $zu(96,0,5) ;generate a <MAXSTRING> error to be trapped by skiprec
 . u file2
 . d wvar(type)
 . d wvar(gref)
 . d wvar(xval)
 . u IOSAVE
 . s reccnt=reccnt+1  ;for displaying when we're done in ^JCONVERT
 i fastrest=1 {	// read journal in COS and queue record in C
   s stat=$zu(78,47,adr,adr)
   i stat<0 ztrap "STAT"  ;???
   d $zu(78,54,adr) ;@FIXME@ should be done in nextupd and nxtcluupd
   q
 }
 I type=6 DO  Q  ;for SET
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) i '$g(sortcnt(globname)) d
 . . s colseq=$ZU(78,27,adr) i colseq'=dbcol(new),('$d(@($p(newref,"(",1,$l(new,"("))))),$zu(178,"^^"_new,$qs(newref,0),colseq)
 . . d sortbeg 
 . s @newref=$zu(78,15,adr) ;i $i(sortcnt(globname))
 If type=14 DO  Q   ;for SET $BIT
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) i $g(sortcnt(globname)) d sortend i 1
 . e  s colseq=$ZU(78,27,adr) i colseq'=dbcol(new),('$d(@($p(newref,"(",1,$l(new,"("))))),$zu(178,"^^"_new,$qs(newref,0),colseq)
 . s $Bit(@newref,$zu(78,36,adr))=$zu(78,37,adr)
 ;
 I type=7 DO  Q  ;for KILL
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) d:$g(sortcnt(globname)) sortend K @newref
 I type=9 DO  Q  ;for ZKILL
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) d:$g(sortcnt(globname)) sortend ZKILL @newref 
 Q
skiprec S $zt="skiprec1"
 d:checkerr=2
 . ; for checkerr=2 we record errors in the errlist array. 
 . n i,dirname,new
 . i $g(fastrest) s adr=$g(fastaddr),dirname=$s($g(targetdir)="":"<unknown>",1:targetdir) i 1
 . e  s dirname=$S($G(adr):$zu(78,12,adr),1:"<unknown>")
 . s errlist=$G(errlist)+1
 . s errlist("all",errlist)=$LISTBUILD($G(%jrnfile),$G(adr),$ZE)  ;all errors in order
 . s ^SYS("STUJRNERRLIST")=errlist
 . s ^SYS("STUJRNERRLIST","all",errlist)=errlist("all",errlist)
 . ; if this is the 1st error for this directory then count another db err
 . if '$G(errlist("db",dirname)) s i=$I(errlist("db")),errlist("db",i)=dirname,^SYS("STUJRNERRLIST","db")=i,^SYS("STUJRNERRLIST","db",i)=dirname  ;databases with errors
 . s i=$I(errlist("db",dirname))
 . s errlist("db",dirname,i)=$LISTBUILD($G(%jrnfile),$G(adr),$ZE)
 . s ^SYS("STUJRNERRLIST","db",dirname)=i
 . s ^SYS("STUJRNERRLIST","db",dirname,i)=errlist("db",dirname,i)
 . i $g(fastrest) d $zu(9,"","Error in JRNRESTB: "_$ZE_$C(10,13)_"     "_%jrnfile_" addr="_$g(adr)_$C(10,13)_"     "_$g(globref),(0>0),0) i 1
 . e  d $zu(9,"","Error in JRNRESTB: "_$ZE_$C(10,13)_"     "_%jrnfile_" addr="_$g(adr)_$C(10,13)_"     "_$zu(78,13,adr),(0>0),0) q:'$L(dirname)!('$G(adr))  ;if dir is "<unknown>" or "" then stop here
 . d:i>$G(errmax)  ; stop restoring this db if the max # of errors/db is exceeded
 . . ; If we remove dir(new) and set nomount(new) to true then restore will
 . . ; stop writing records to this database. We also dismount it now so that
 . . ; in case something goes wrong and the system lets users on, its dismounted.
 . . s new=dirname I '$g(fastrest),'ALL S new=$G(dejrn(dirname)),new=$P(new,",",2,$L(new)) S:'$L(new) new=dirname
 . . d:'$L(new)
 . . . d $zu(9,"","Cannot locate directory name for offset "_adr_" in "_%jrnfile_". Not dismounted",(0>0),0)
 . . d:$L(new)
 . . . k dir(new)
 . . . s nomount(new)=1
 . . . do $ZU(3,new)
 . . . d $zu(9,"","Too many errors restoring to "_new_"."_$C(10,13)_" Dismounting and skipping subsequent records",(0>0),0)
 . . . s errlist("db",dirname)=errlist("db",dirname)_"^1"  ;flag we skipped the rest
 . . . s ^SYS("STUJRNERRLIST","db",dirname)=errlist("db",dirname)
skiprec1 ;
 S $zt="skiprec2"
 ;checkerr=2 logs the message up higher so that it comes before the note
 ;that subsequent records are skipped when the max error count is exceeded.
 g:checkerr=2 skiprec2 
 i $g(zjrnerr) ztrap $ze 
 n ze s ze=$ze 
 i $g(fastrest) s adr=$g(fastaddr)
 e  d  
 . s $zt="skiprec2"
 . s globref=$zu(78,13,adr),globnam=$p(globref,"(",1,$l($qs(globref,-1),"("))
 s $ze=ze
 if $g(globnam)="" {
   i $i(globerr($ze))>1 s $ze="" g skipdir ;and quit skiprec
   s errmsg="Failed to process update at offset "_$g(adr)_" of file "_$g(%jrnfile)_": "_$ze
   d logmsg(errmsg,0,2)
   d logmsg("Future messages of error "_$ze_" will be suppressed",0,0)
   s ^SYS("RESTORE","JOURNAL",RestTime,"Errors",$i(^SYS("RESTORE","JOURNAL",RestTime,"Errors")))=errmsg
 } else {
   i $i(globerr(globnam))>1 s $ze="" g skipdir ;and quit skiprec
   s errmsg="Failed to process update of global node "_globref_" at offset "_$g(adr)_" of file "_$g(%jrnfile)_": "_$ze
   d logmsg(errmsg,0,2)
   d logmsg("Future error messages on global "_globnam_" will be suppressed",0,0)
   s ^SYS("RESTORE","JOURNAL",RestTime,"Errors",$i(^SYS("RESTORE","JOURNAL",RestTime,"Errors")))=errmsg
 }
 d skipdir
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(globerr) d
 . i '($$yesno("Do you want to continue","Y")="Y") s zjrnerr=1 q
 . s globerr=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
skiprec2 s $zt=""
 i $g(zjrnerr) ztrap $ze
 s $ze="" 
 q
skipdir s $zt="skipdirE"
 i $g(targetdir)]"",$i(globerr(targetdir))>3 {
   k dir(targetdir)
   s nomount(targetdir)=1
   s errmsg="Too many errors restoring to database "_targetdir_" from journal file "_$g(%jrnfile)_". Skipping subsequent updates to the database"
   d logmsg(errmsg,0,2)
   s ^SYS("RESTORE","JOURNAL",RestTime,"Errors",$i(^SYS("RESTORE","JOURNAL",RestTime,"Errors")))=errmsg
   s ^SYS("RESTORE","JOURNAL",RestTime,"SkipDB",targetdir)=1 ;same as nomount()
 }
 q
skipdirE s $zt=""  d logmsg($ze,0,1) s $ze="" q
 ; we haven't dejournalled from this directory - see if its mounted
 ; adr/jrnfile is the current position in case we want to remember
 ;   this to recovery a non-recovered db later
mount(mdir,adr,jrnfile)
 n a
 n dbattrib,nojrnbit,mirrorbit,mirrorstate  ;JO2141 
trymnt i checkerr s $zt="nomnt"
 s $ze="" ;clear $ze so that nomnt can tell whether it is a real error
 s a=$zu(49,mdir) i (a=-2)!(a=-3) g nomnt
 s dbattrib=+$p(a,",",17),nojrnbit=+$zu(40,8,23)
 s mirrorbit=+$ZU(40,8,28)
 if $zb(dbattrib,mirrorbit,1) {
	s dbstatus=$p(a,",",18),failoverdbbit=$$getfailoverdb()
    if '$SYSTEM.Mirror.IsPrimary()&&$zb(+dbstatus,+failoverdbbit,1) {
	   ; you can't write to a mirrored database if this isn't the primary
	   ; this also covers skipping mirrored db's at startup
	   s nomount(mdir)=2
 	   d logmsg("Not restoring "_mdir_" because mirrored databases can only be restored on the primary",0,1)
  	   i $d(restopt(1)) {
	  	  s zjrnerr=(restopt[1)
  	   } elseif $g(CHATTY),'($d(nomount)#10) {
	 	  use 0
 	      i '($$yesno("Do you want to continue","Y")="Y") {
	 	      s zjrnerr=1
 	      } else {
 		     w !,"Journal records for ",mdir," will be ignored"
 	         s nomount=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 	      }
 	   }
	   q:'$g(zjrnerr) 0 
	   s $ze="" 
	   ztrap $ze    
	}
 }
 i $zb(dbattrib,nojrnbit,1) d  q:'$g(zjrnerr) 0 s $ze="" ztrap $ze
 . s nomount(mdir)=2
 . i $g(STU)="S" d  i 1
 . . i $zu(173)=+a q  ;cachetemp
 . . s dbres=$p($p(a,",",25),"_",2)
 . . i dbres'="CACHE",dbres'="CACHELIB",dbres'="CACHETEMP",dbres'="SAMPLES",dbres'="DOCBOOK" d logmsg("Not restoring "_mdir_" because the database is not journaled",0,1)
 . e  d logmsg("Not restoring "_mdir_" because the database is not journaled",0,1)
 . i $d(restopt(1)) s zjrnerr=(restopt[1) q
 . i $g(CHATTY),'($d(nomount)#10) u 0 d
 . . i '($$yesno("Do you want to continue","Y")="Y") s zjrnerr=1 q
 . . w !,"Journal records for ",mdir," will be ignored"
 . . s nomount=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 i -1<a,a<$zu(40,0,41) s dir(mdir)=0,dbcol(mdir)=$Piece($zu(49,mdir),",",13) q 1
   ; 1st try to mount privately, then clustered
 s a=$zu(17,mdir,0) i a'<0 s dir(mdir)=1,dbcol(mdir)=$Piece($zu(49,mdir),",",13) q 1 ; private mount
 s a=$zu(17,mdir,1) i a'<0 s dir(mdir)=2,dbcol(mdir)=$Piece($zu(49,mdir),",",13) q 1 ; cluster mount
nomnt i checkerr s $zt="" ; Handle failure to mount directory
 i checkerr=2 {
   s a=$$CheckErrMntRequired^ROLLBACK(mdir,.errlist)
   i +a=-2 {
     i $l(a,",")>1 d logmsg($p(a,",",2,$l(a)),0,2)
     d logmsg("Failed to mount required database "_mdir_$s($ze]"":": "_$ze,1:""),0,2)
     s zjrnerr=1,$ze="" ztrap $ze
   }
 }
 d logmsg("Failed to mount database "_mdir_$s($ze]"":": "_$ze,1:""),0,2)
 i $d(restopt(1)),(restopt[1) s zjrnerr=1,$ze="" ztrap $ze
 i '$g(CHATTY) g errmnt ; Skip Q&A if dialog not allowed
 i $$YN("Do you want to retry the mount","")="Y" w ! g trymnt
 w !,"Journal records for ",mdir," will be ignored"
 i '($$yesno("Do you want to continue","")="Y") s zjrnerr=1 ztrap $ze
errmnt s $ze="",nomount(mdir)=2 q 0_","_a ; Problems
getfailoverdb()
 n x
 try {
	 s x=$zu(40,8,33)
 } catch {
	 s x=$zh("80000")
 }
 q x
nextupd i checkerr s $zt="nxterr"
 s nextadr=$zu(78,17,adr) g nxtdone:'nextadr s adr=nextadr
 s type=$zu(78,8,adr)
 i type=13 q
 ;if it is SET/KILL, check to see if we care. If we do, leave it to
 ;restore; otherwise, skip to the next record
 i (type=6)!(type=7)!(type=9)!(type=14) D  Q:$G(modify)!ALL  g nextupd
 . D:'ALL check
 . Q:'$zu(78,9,adr)  ;optimized for (modify!ALL)&`jrntrans
 . D:($G(modify)!ALL)
 . . ;make sure it is not already in either tranopen or badtran
 . . Q:$D(tranopen($zu(78,10,adr),$ZU(78,25,adr)))
 . . Q:$D(badtran($zu(78,10,adr),$ZU(78,25,adr)))
 . . S badtran($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 ;restore does not care about TSTART/TCOMMIT.
 ;if 2nd TSTART for the same pid appears, 1st one will be forgotten or
 ;ignored. it would be better if tranopen and badtran are combined 
 ;into one.
 i type=4 d  g nextupd
 . s tranopen($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 i type=5 d  g nextupd
 . k tranopen($zu(78,10,adr),$ZU(78,25,adr))
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 i type=-1 g nxtdone
 g nextupd
nxterr S $ZT="" 
 i $g(zjrnerr) ztrap $ze 
 i $ze["<Z",$g(resterr)]"" d logmsg(resterr,0,2) i 1
 e  d logmsg("Error processing journal record at offset "_$g(adr)_" of file "_$g(%jrnfile)_": "_$ze,0,2)
 d:checkerr=2
 . ; for checkerr=2 we record errors in the errlist array. Here we
 . ; have a problem with an entire journal file. These are recorded in
 . ; the "misc" (as opposed to "db") subnode. adr is set to NULL since it
 . ; doesn't apply here.
 . n index
 . s errlist=$G(errlist)+1
 . s errlist("all",errlist)=$LISTBUILD($G(%jrnfile),"",$ZE)
 . s index=$I(errlist("misc"))
 . s errlist("misc",index)=$LISTBUILD($G(%jrnfile),"",$ZE)
 i $d(restopt(2)) s zjrnerr=(restopt'[2) i 1
 e  i $g(CHATTY) d
 . w !,"It is recommended that you abort dejournaling at this point. However,"
 . w !,"if you decide to continue, we will have to skip the rest of the file."
 . s zjrnerr='($$yesno("Do you want to continue","N")="Y")
 i $g(zjrnerr) ztrap $ze
 d logmsg("Skipping the rest of the journal file",0,0)
 s $ze=""
 s type=-1,adr=0 q
nxtdone ;
 i adr'<lastindex s type=-1,adr=0 q
 s resterr="Journal "_$g(%jrnfile)_" ends unexpectedly at "_adr_" (end expected at "_lastindex_") - possible corruption in the journal" 
 ztrap "JEND"
 ;
check ;
 s dir=$zu(78,12,adr)
 S cd=$G(dirnam(dir)) I cd="" S (cd,dirnam(dir))=$S($G(xOS)||(dir[":mirror:"):dir,1:$ZU(12,dir)) i $d(dejrnNodup),'$d(dejrnNodup(cd)) s dejrn(cd)=1 s @statnode@(cd)=$j ;consider hashing on restore daemon number to spread these out.
 I $G(dejrn(cd)) S modify=1 Q  ;entire directory is valid
 i '$D(dejrn(cd)) s modify=0 q  ; not dejournaling this directory
   ; no - see if global is valid
 s gnode=$zu(78,13,adr)
 s glo=$e($qs(gnode,0),2,512)
 S modify=0 I $D(dejrn(cd,glo)) S modify=1 Q  ;specified global
 N pat,g S g="" F  S g=$O(dejrn(cd,g)) Q:g=""  DO  Q:modify
 . S pat=dejrn(cd,g) I pat="" S pat=$$PATRN(g),dejrn(cd,g)=pat
 . I glo?@pat S modify=1 ;global matches requested pattern
 Q  ;modify=1 if matches one of the patterns
open i checkerr s $zt="openend"
 s clu=$zu(78,5,%jrnfile,0)
 i clu<0 s resterr="ERROR OPENING JOURNAL FILE "_%jrnfile ztrap "OPEN"
 s a=$zu(78,6,clu),adr=0
 q
openend S $ZT="" s adr=-1 g nextfileE
close I checkerr S $ZT="etclose"
 S a=$zu(78,7,clu),clu=-1
 Q
etclose S adr=-1 Q
 ;
   ; $$curfile()
   ; returns current journal file name, if any, else ""
curfile() i '($zversion(1)=1) s $zt="curfile1" q $p($zu(78,4)_","_$zu(78,3),",",2)
 n file
 s $zt="curfile1"
 s file=$p($zu(78,4)_","_$zu(78,3),",",2)
 q:file="" ""
 s file=$ZU(12,file) ; canonize journal file name
 q file
curfile1 q ""
 ; 
ZJRNERR d $zu(9,"",$ze_" error during journal filter",(1>0),1)
 d $zu(9,"","***Restore is aborted***",(1>0),1) s zjrnerr=1,$ze="" zq 1 g @$zt
 ;
 ; Input: globname
 ; Modified (sortend only): sortcnt
sortbeg q:$g(disablesort)  s $zt="sortbegE" x "i $sortbegin("_globname_"),$i(sortcnt(globname))" q
sortbegE s $zt="" 
 i $i(sortbegerr(globname,$ze))>1 s $ze="" q  
 d logmsg("Error starting sorting on global "_globname_": "_$ze,0,2)
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(sortbegerr) d
 . w !,"If you decide to continue, updates of the global may be applied" 
 . w !,"without being sorted first."
 . i '($$yesno("Do you want to continue","Y")="Y") s zjrnerr=1 q
 . s sortbegerr=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 i $g(zjrnerr) ztrap $ze
 s $ze=""
 q
sortend q:$g(disablesort)  s $zt="sortendE" x "ztrap:$sortend("_globname_")<0 ""SORT""" k sortcnt(globname) q
sortabort q:$g(disablesort)  s $zt="sortendE" x "ztrap:$sortend("_globname_",0)<0 ""SORT""" k sortcnt(globname) q
sortendE s $zt=""
 i $i(sortenderr(globname,$ze))>1 s $ze="" q  
 d logmsg($s($g(abortflush):"Discarding",1:"Applying")_" updates of global "_globname_" failed"_$s($ze["<NAMESPACE>":" due to namespace change",1:"")_": "_$ze,0,2)
 i $g(flushonerr) k sortcnt(globname) q
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(sortenderr) d
 . w !,"Updates to the global ",globname," have been lost."
 . w !,"You can either complete this journal restore and then re-run it for "
 . w !,"only this global, or you can abort the journal restore and restart it"
 . w !,"for all globals."
 . i ($$yesno("Do you want to abort","Y")="Y") s zjrnerr=1
 i $g(zjrnerr) k sortcnt(globname) ztrap $ze
 s $ze=""
 q
 ; 
sortlimit ;
 q:$g(disablesort)
 s $zt="sorterr"
 i $v($zu(40,1,55),-1,4)<sortchunklimit q  
 n globname
 s globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  d sortend
 q
sortflush(abortflush) ;flush all sorted SETs to databases or abort sorting
 s $zt="sorterr"
 q:$g(disablesort)
 n flushonerr
 i $g(zjrnerr) s flushonerr=1
 e  s flushonerr=0
 i $g(abortflush) d  q
 . s globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  d sortabort
 n totalcnt,globcnt,cnt 
 s totalcnt=0,globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  s totalcnt=totalcnt+sortcnt(globname) i $i(globcnt)
 i 'totalcnt q  ;nothing to flush
 i $g(STU)="S" d $zu(9,"","Journal reads completed. Applying changes to databases...",(0>0),0) i 1
 e  w !!,"Journal reads completed. Applying changes to databases...",!
 s cnt=0,globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  s cnt=cnt+sortcnt(globname) d sortend w:$g(STU)'="S" $j(cnt/totalcnt*100,7,2),"%"
 q
sorterr s $zt="" 
 i $g(zjrnerr),'$g(flushonerr) ztrap $ze ;pass error from sortend
 i '$d(sortcnt) d logmsg($ze_", but no global appears affected",0,1) q
 d logmsg("Failed to "_$s($g(abort):"discard",1:"apply")_" updates: "_$ze,0,2)
 d logmsg("The following globals are affected and should be restored again",0,0)
 n globname s globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  d logmsg(globname,0,0)
 i $d(flushonerr) k sortcnt
 i $g(flushonerr) q
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(sorterr) d
 . i '($$yesno("Do you want to continue","N")="Y") s zjrnerr=1 q
 . s sorterr=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 i $g(zjrnerr) ztrap $ze
 s $ze=""
 q
ClearSwitch10() ;
 i $g(clrsw10)]"" q clrsw10 ;it has been asked before, so leave it
 i '$SYSTEM.Util.GetSwitch(10) q 1 ;switch 10 is CLEAR/OFF
 i '$g(CHATTY) s clrsw10=0 q 0 ;leave switch 10 ON in non-interative mode
 w !?5,"** WARNING ** Switch 10 is set, preventing multi-job journal restore"
 w !?5,"Will restore in single job mode if switch 10 is not cleared"
 i $$YN("Clear switch 10 to start multi-job restore","N")="N" s clrsw10=0
 e  i $System.Util.SetSwitch(10,0) s clrsw10=1
 e  d resterrlog("Unable to clear switch 10") s clrsw10=0
 q clrsw10
 ; 
 ; Purpose: perform concurrent restore whenever possible
 ; Input: numrestjobs, dejrn
multrest ;single-system or cluster restore with concurrent job support
 s $zt="multrestE"
 ; CHATTY, QUIETMODE: whether to allow user input (CHATTY=1, QUIETMODE=0)
 ;                    [no user input allowed in jobbed jobs] 
 n i
 n dir ;source database directory
 n targ ;target database directory
 n target ;(targ): array of database redirections, indexed by target databases
 n restjob ;(i,targ): array of jobbed jobs' PIDs & associated target databases
 n stat ;(i): array of jobbed jobs' status (success/failure/percentdone)
 n statnode ;the global node for restore job to set success/failure upon exit
 n statnodebase ;the base of statnode
 n percentdone ;(pid): percentage of restore done by a job, indexed by PIDs
 n trannode ;transaction info from restore jobs: ("open") or ("bad")
 n abort ;1 to abort concurrent restore (may continue to single job restore)
 n pid
 s (statnode,statnodebase)=$name(^SYS("RESTORE","JOURNAL",RestTime,"Status"))
 s trannode=$name(^SYS("RESTORE","JOURNAL",RestTime,"transactions"))
 i numrestjobs=1 d onejobrest q  ;no concurrent restore on SP machines
 ; Distribute workload by target databases. It is possible, although unlikely,
 ; that multiple source databases are redirected to one target database.
 i '$d(dejrn) d GetDirList(.numrestjobs,.dejrn,.dejrnNodup) i numrestjobs=1 k dejrn,dejrnNodup d onejobrest q  ;one job to restore ALL databases
 s dir="" f  s dir=$o(dejrn(dir)) q:dir=""  S targ=$G(dejrn(dir)),targ=$P(targ,",",2,$L(targ)) S:'$L(targ) targ=dir m target(targ,dir)=dejrn(dir)
 ; count # of targ databases and assign them to available CPUs
 s targ="" f i=0:1 s targ=$o(target(targ)) q:targ=""  s restjob(i#numrestjobs,targ)=""
 i i<2 s numrestjobs=1 d onejobrest q  ;only one database to restore
 i '$$ClearSwitch10() s numrestjobs=1 d onejobrest q 
 i i<numrestjobs s numrestjobs=i ;not enough target databases to use all CPUs
 i $g(cachetempmaxblks) s sortchunklimit=sortchunklimit\numrestjobs ;per-job threshold
 i $g(restopt)'["0" d getrestopts(.restopt,numrestjobs)
 i $d(ALL) n SaveAll s SaveALL=ALL,ALL=0
 w !! s abort=0 f i=0:1:(numrestjobs-1) d  q:abort  ;i = pseudo CPU#
 . ;fix dejrn info and statnode before passing them on to the jobbed job
 . ;note that the original dejrn and statnode remain intact as we NEW them here
 . n statnode s statnode=$name(@statnodebase@(i))
 . n dejrn s targ="" f  s targ=$o(restjob(i,targ)) q:targ=""  m dejrn=target(targ) s @statnode@(targ)=""
 . j onejobrest:(:(1+2)):10 e  d restjobfail(i) q  ;may abort concurrent restore
 . k dejrnNodup
 . s restjob(i)=$zc d restjobok(i)
 ; optionally run single-job restore if concurrent restore has been aborted
 i $d(SaveALL) s ALL=SaveALL
 i abort d  q  
 . i $g(CHATTY),$$YN("Restore in single job mode","Y")="N" q  ;no restore
 . k restopt s restopt=""
 . d onejobrest
 ; periodically check the status of each remaining restore job; print progress
 d MONITOR(RestTime,''$d(clujrn),10,1) q:abort
 w !!,"[Journal restore completed]"
 ; prepare for transaction rollback (to be done by caller) if necessary
 m tranopen=@trannode@("open"),badtran=@trannode@("bad")
 q
multrestE ;
 s $zt=""
 i $g(zjrnerr) ztrap $ze
 i $ze'["INTERRUPT" d resterrlog($ze),BACK^%ETN
 ; offer an option to monitor progress of restoring if current job ("monitor")
 ; quits without aborting existing restor jobs
 i $d(restjob) d restfail i 'abort w !!,"To monitor or manage existing restor jobs, ",!,?8,"DO MONITOR^JRNRESTB(""",RestTime,"""",$s($d(clujrn):",1",1:""),")",!
 q
GetDirList(numrestjobs,dejrn,dejrnNodup) public {
 s rset=##class(%Library.ResultSet).%New("SYS.Database:List")
 d rset.Execute()
 while rset.Next() {
	 s t=rset.GetData(1),dejrn(t)=1
 }
 k rset
 s rset=##class(%Library.ResultSet).%New("Config.Databases:List")
 d rset.Execute()
 while rset.Next() {
	 s t=##class(%Library.File).ComputeFullDBDir(rset.GetData(2)),dejrn($zu(12,t))=1
 }
 k rset
 s n=0,d="" f  s d=$o(dejrn(d)) q:d=""  d
 .s x=$zu(49,d) i +x<0 k dejrn(d) q
 .s t=$zb(+$p(x,",",17),+$zu(40,8,23),1)
 .i 't s n=n+1 q
 .k dejrn(d) q
 m dejrnNodup=dejrn
 i n<numrestjobs s numrestjobs=n
 q n
}
resterrlog(msg) w !,*7,"[***ERROR: ",$g(msg),"]",! q 
 ; Input: restjob
 ; i: pseudo CPU#, index of restjob and stat arrays
restjobfail(i) ;
 w !,*7,"***ERROR: Failed to job off a job to apply journal to "
 s targ="" f  s targ=$o(restjob(i,targ)) q:targ=""  w !,?8,targ 
 k restjob(i)
 d restfail
 q
 ; Input: restjob, statnodebase
 ; i: pseudo CPU#, index of restjob and stat arrays
restjobok(i) ;
 w !,"Restore Job #",i," (PID ",restjob(i),") applying journal to "
 s targ="" f  s targ=$o(restjob(i,targ)) q:targ=""  w !,?8,targ s @statnodebase@(i,targ)=restjob(i)
 q
restfail ;
 i $g(CHATTY),$$YN("Abort concurrent restore and terminate existing restore jobs (if any)","Y")="N" q
 s i="" f  s i=$o(restjob(i)) q:i=""  i $g(restjob(i)),'$zu(4,restjob(i)) d resterrlog("Failed to kill job of PID "_restjob(i))
 w !!,"[Concurrent journal restore aborted]",!
 k restjob
 s abort=1
 q
 ; Input: restjob
 ; Return: >0 (completion time) - restore completed
 ;         -1,error - restore failed
 ;         0,percentdone - ongoing restore 
reststat(i) ;
 n pid,stat
 s pid=restjob(i),stat=$g(@statnodebase@(i)) i stat q stat  ;success or failure
 i $zu(67,0,pid)<2 s stat=$g(@statnodebase@(i)) s:'stat stat="-1,Job terminated abnormally"  q stat
 q "0,"_$$restpercent(pid)
 ;
 ; Purpose: Show completion time (on success) or error message (on failure)
 ; Input: 
 ;   restjob, stat
 ;   i - pseudo CPU#, index of restjob and stat arrays
showstat(i) ;
 n pid s pid=restjob(i)
 i stat(i)>0 w !,"[Restore Job #"_i_" (PID ",pid,") completed restore at ",stat,"]",! q
 d resterrlog("Restore Job #"_i_" (PID "_pid_"): "_$p(stat(i),",",2,$l(stat(i))))
 q
 ;
 ; Return percentage done by job 'pid' or "" if job (temporarily?) unavailable
restpercent(pid) ;
 s $zt="restpercentE"
 q $zu(88,2,pid,"percentdone") ;$zu(88) may get spurious <NOJOB> errors
restpercentE s $zt="" d:$ze'["<NOJOB>" BACK^%ETN q ""
 ;
 ; Show 'percentdone' values of existing restore jobs in columns (CPU#)
 ; if pid is specified, show 'percentdone' value of one job
 ; Input: stat, restjob, numrestjobs, isclujrn
 ; Input/Output: percentdone
showpercent(i) ;
 i $d(i) d  q
 . s percentdone=$p(stat(i),",",2,$l(stat(i)))
 . i $p(percentdone,",",2)'=$p($g(percentdone(i)),",",2) d  i 1
 . . n info s info=$p(percentdone,",",2) 
 . . w !,"Restore Job #",i," restoring "
 . . i info?1.N,$g(isclujrn) n a s a=$zdth(info,-2) w "cluster start: ",$ZD(a)," ",$ZT($P(a,",",2),4) i 1
 . . e  w "journal ",info ;may apply to cluster restore (cf. restoreone)
 . . w !
 . . s percentdone(i)=percentdone
 . e  i +percentdone>$g(percentdone(i)) s percentdone(i)=percentdone
 . e  s percentdone=+$g(percentdone(i))
 . w ?(i*8),$j(percentdone,7,2),"%"
 s i="" f  s i=$o(restjob(i)) q:i=""  s stat(i)=$g(stat(i)) q:$p(stat(i),",",2,$l(stat(i)))'=$g(percentdone(i))
 i i="" w "." q  ;no progress so far; just print a dot on the same line
 ; there is some progress; print the percentages on a new line, in columns
 w ! f i=0:1:(numrestjobs-1) i $g(restjob(i)) d showpercent(i)
 q
onejobrest ;one job restore (perhaps a jobbed off job)
 s $zt="resterr"
 i $g(shrid,-1)'<0,$zu(78,51,shrid,0,0) ;job designated as journal reader
 i '$g(disablesort),$$IsLongStringEnabled() s disablesort=1,cachetempmaxblks=0
 i $zj\2#2=0,$g(restopt)'["0" d getrestopts(.restopt,0)
 i $zu(68,1,1)
 i $zj\2#2=0 k trannode 
 e  s CHATTY=0,QUIETMODE=1 D:$g(disjrn) DISABLE^%SYS.NOJRN
 ; If we're restoring clustered directories then go off to cluster restore
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$d(clujrn) s:fastrest fastrest=1 d restore^JRNCLUREST i 1
 e  d sysrest ;otherwise, perform a single-system restore
 d sortflush()
 k sortcnt 
 d restdone
 q
sysrest ;single-system restore (as opposed to clu restore, restore^JRNCLUREST)
 s $zt="sysrestE"
 ;the post-"d nextfile" jrnfile is the one dejournalled in nextfile
 ;make sure djlast is no greater than %curfile (<=current date)
 ;DEJRNSTART is valid for the first file to dejournal only
 S jrnfile="",%jrnfile="" f  d nextfile q:+$g(zjrnerr)  q:'(($p(djlast,".")>$p(jrnfile,"."))||(($p(djlast,".")=$p(jrnfile,"."))&&($p(djlast,".",2)>$p(jrnfile,".",2))))  k DEJRNSTART
 q
sysrestE ;similar to resterr^JRNCLUREST
 S $ZT=""
 i '$$askabort() q
 i $g(clu)]"",clu'<0 s clu=$zu(78,7,clu),clu=-1
 ztrap $ze
resterr s $zt="resterr1"
 n ze i $$askabort() s ze=$ze 
 i $d(sortcnt) d  ;do this only if there are sorted, not-yet-applied updates
 . n abort s abort=0
 . i '$g(zjrnerr) s abort=0 ;always apply sorted updates if we are NOT aborting
 . e  i $g(CHATTY) s abort=($$YN("Apply updates to databases before aborting restore","N")="N") i 1
 . e  i $d(restopt(3)) s abort=(restopt[3)
 . d sortflush($g(abort))
 . k sortcnt 
 i $g(shrid,-1)'<0 d FreeShare^JRNRESTF(RestTime)
 i '$g(zjrnerr) s $ze="" q
 i $d(ze) s $ze=ze 
resterr1 s $zt="",zjrnerr=1
 i $g(statnode)]"" s @statnode="-1,"_$ze_","_$g(zjrnerrmsg)
 i $zj\2#2 d logmsg("journal operation aborted",1,2) i 1
 e  w !!,"[journal operation aborted]",!
 ztrap $ze
askabort() s $zt=""
 u 0
 i $g(zjrnerr) q 1
 d logmsg($ze,0,2) 
 i $g(CHATTY),$$YN("Continue","NO")="Y" s $ze="" q 0 ;continue rather than abort
 s zjrnerr=1
 q 1
restdone ;after a successful restore...
 i $g(shrid,-1)'<0 {
   i $zu(78,49,shrid)<0 ztrap "SYNC"
   s sfnupd=$zu(78,76,shrid,-3)
   s i=0 f  {
     s i=$f(sfnupd,1,i) q:'i
     s sfn=i-2
     s ^SYS("RESTORE","JOURNAL",RestTime,"DB",sfn)=$p($zu(49,sfn,3),"^",2)
   }
   d FreeShare^JRNRESTF(RestTime)
 }
 w !!,"[journal operation completed]"
 i $g(statnode)]"" s @statnode=$zdt($h,8) ;completion time (>0), incl. flushing
 ; trannode is defined iff ROLLJRN=1 and $zj\2#2=1 (jobbed job)
 ; tranopen and badtran arrays should be identical among complete restore jobs
 ; thus, one copy is enough.
 i $g(trannode)]"" l +@trannode m:'$d(@trannode) @trannode@("open")=tranopen,@trannode@("bad")=badtran l -@trannode
 q
MONITOR(RestTime,isclujrn,interval,passthru) ;
 i '$g(passthru) n (RestTime,isclujrn,interval,passthru) d monini q:abort  s $zt="multrestE"
 w ! f  q:'$d(restjob)  d showpercent() h interval s i="" f  s i=$o(restjob(i)) q:i=""  s (stat,stat(i))=$$reststat(i) i stat d showstat(i) k restjob(i) i stat<0 d restfail q:abort
 q
monini ;
 s CHATTY=1,QUIETMODE=0
 i '$d(RestTime) w "Invalid parameter ",RestTime,! q
 s statnodebase=$name(^SYS("RESTORE","JOURNAL",RestTime,"Status"))
 m restjob=@statnodebase
 i '$d(restjob) w "Not available for monitoring",! q
 s numrestjobs=$o(restjob(""),-1)+1,isclujrn=+$g(isclujrn) i isclujrn s clujrn=1
 s abort=0,interval=$g(interval,10) ;default interval 10 seconds
 s i="" f  s i=$o(restjob(i)) q:i=""  d  q:abort
 . s targ=$o(restjob(i,"")) i targ="" k restjob(i) q  ;something unexpected
 . s (stat,stat(i))=$g(restjob(i)),restjob(i)=restjob(i,targ) ;PID
 . i stat d showstat(i) k restjob(i) i stat<0 d restfail
 k stat  ;showpercent() assumption
 q
wvar(s)	;s s=$zcvt(s,"O",xlate) ;caller passed in 's' in translated form
 i fmode1'="U" w s w:fmode1="S" ! q
 i recsep=+recsep s l=$l(s) w $zwc(l),s w:recsep=2&(l#2) $c(0) q
 w s,recsep
 q
logmsg(msg,quietly,severity) ;
 i '$g(quietly),$g(CHATTY) d
 . i $g(severity) u 0 w !,*7,"***",$s(severity>1:"ERROR",1:"WARNING"),": ",msg,!
 . e  u 0 w !,msg,!
 i $zu(9,"","[JOURNAL RESTORE] "_msg,0,severity)
 i severity>1 s zjrnerrmsg=msg
 q
msgout(msg,indent) ;
 n off,i,word 
 s indent=+$g(indent) u 0 w !?indent 
 f i=1:1:$l(msg," ") s word=$p(msg," ",i) w:($x+$l(word)>78) !?indent w word," "
 q
yesno(prompt,default) ;
 n ans u 0 w ! s ans=$$YN(prompt,$g(default)) w ! q ans
getrestopts(restopt,multi) [disablesort,zjrnerr] PUBLIC {
 s restopt(1,(""[1))="Continue despite database-related problems (e.g., a target database is not journaled, cannot be mounted, etc.), skipping affected updates"
 s restopt(1,'(""[1))="Abort if an update would have to be skipped due to a database-related problem (e.g., a target database is not journaled, cannot be mounted, etc.)"
 s restopt(2,'(""'[2))="Abort if an update would have to be skipped due to a journal-related problem (e.g., journal corruption, some cases of missing journal files, etc.)" 
 s restopt(2,(""'[2))="Continue despite journal-related problems (e.g., journal corruption, some missing journal files, etc.), skipping affected updates"
 i '$g(disablesort) {
   s restopt(3,(""[3))="Apply sorted updates to databases before aborting"
   s restopt(3,'(""[3))="Discard sorted, not-yet-applied updates before aborting (faster)"
 }
 s restopt="0" ;initial values, all defaults, + indicate questions asked.
 s multi=+$g(multi)
 i multi d
 . w !,"Before we job off restore daemons, you may tailor the behavior of a"
 . w !,"restore daemon in certain events by choosing from the options below:"
 . s i="" f  s i=$o(restopt(i)) q:i=""  w ! d msgout("DEFAULT:    "_restopt(i,0),5) w ! d msgout("ALTERNATE:  "_restopt(i,1),5)
 i 'multi d
 . w !,"You may tailor the response to errors by choosing between the alternative"
 . w !,"actions described below.  Otherwise you will be asked to select an action"
 . w !,"at the time an error actually occurs." 
 . s i="" f  s i=$o(restopt(i)) q:i=""  w ! d msgout("Either "_restopt(i,0),5) w ! d msgout("or     "_restopt(i,1),5)
 i multi s yn=$$yesno("Would you like to change the default actions","N")
 i 'multi d
 .s yn=$$yesno("Would you like to specify error actions now","N")
 .i yn="N" k restopt
 i yn="N" g confirm  ;use defaults
 d get1restopt(.restopt,1)
 d get1restopt(.restopt,2)
 i '$g(disablesort) d get1restopt(.restopt,3)
 i multi w !,"Based on your selection, a restore daemon will",!
 e  w !,"Based on your selection, this restore will",!
 s i="" f  s i=$o(restopt(i)) q:i=""  d msgout("** "_restopt(i,restopt[i)) w !
confirm ;
 i $$yesno("Start the restore","Y")="N" s notresto=1,zjrnerr=1 ztrap "STOP"
 q
}
get1restopt(restopt,i) PUBLIC {
get1restoptask	;
 w ! d msgout(1_".  "_restopt(i,0),5) w ! d msgout(2_".  "_restopt(i,1),5)
 r !!,"Select option [1 or 2]:  ",option
 i option=1 q
 i option=2 s restopt=restopt_i q
 g get1restoptask
}
IsLongStringEnabled() PUBLIC {
  s $zt="Error"
  i $zu(69,69) q 1
  s $p(str,".",$ZU(40,0,20)+1)="."
  q 1
Error s $zt="",IsEnabled=($ze'["MAXSTRING"),$ze="" q IsEnabled
}
STOP(x) S x=$$UC($E(x,1,4)) Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
UC(x) q $zcvt(x,"u")
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
YNN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No/Never w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ","Vv"[D:"Never => ",1:"") ;Yes, No, Never, or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YNV"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"ynv","YNV") I "^YNV"'[R W "  enter Yes or No, or V for Never, please"
 S POP=(R="^") W *8,$E($S(R="N":"No",R="Y":"Yes",R="V":"Never",1:""),$L(X),5) Q R
PATRN(X) N q,i,x,c S q=0,x="" F i=1:1:$L(X) S c=$E(X,i) S:c="""" c=c_c DO
 . I "*?&#"'[c S x=x_$S(q:c,1:"1"""_c),q=1 Q  ;simple text -- no pattern
 . S x=x_$E("""",q)_$S(c="&":"1A",c="#":"1N",c="*":".E",1:"1E"),q=0 Q
 S:q x=x_"""" S X=$P($P($P($P(X,"?"),"#"),"&"),"*") Q x ;return ?@x
HasFile(f) Q ''$zu(78,22,f) ;1: file exists 0: not
 ; BITWISE.INC, DPB139 07/09/93
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 i ($zversion(1)=1) d
 . n x
 . s x=$$ChkDirVALID(dir)
 . i x'="" s dir=x
 i '($zversion(1)=1) Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))
 i '($zversion(1)=1) s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 i ($zversion(1)=1) d  q dir
 . n x
 . s x=$$ChkDirVALID(dir)
 . i x'="" s dir=x
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 i ($zversion(1)=1) S $E(d1,$L(d1))="."_d2_"]"
 i '($zversion(1)=1) S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 i ($zversion(1)=1) q:$$ChkDirVALID(dir)="" 1  ; dir is invalid, return failure
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q