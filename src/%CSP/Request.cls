Include %cspInclude

/// The <CLASS>%CSP.Request</CLASS> class encapsulates an incoming URL and its parameters.
/// <P>When a csp request is received, the CSP Server creates an instance of the 
/// <CLASS>%CSP.Request</CLASS> class. 
/// This is accessible via the <VAR>%request</VAR> variable.
Class %CSP.Request Extends %RegisteredObject [ ServerOnly = 1, System = 3 ]
{

/// A string containing the URL up to and including the page name 
/// and extension, but not including the query string.
Property URL As %String;

/// Used to keep track of old values
Property store As %String [ Internal, MultiDimensional, Private ];

/// A string containing the name of the CSP page being processed.
Property PageName As %String;

/// If the url contains the configuration name of the server as the first piece
/// then this is defined to be the correct prefix to prepend to urls so they
/// include this config name
Property URLPrefix As %String;

/// A string indicating the type of browser from which the request 
/// originated, as determined from the HTTP_USER_AGENT header.
Property UserAgent As %String;

/// The Gatewway Request Id 
Property RequestId As %String;

Method UserAgentSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%UserAgent=val
	Quit $$$OK
}

/// A string indicating the MIME Content-Type of the request.
Property ContentType As %String;

Method ContentTypeSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%ContentType=val
	Quit $$$OK
}

/// Character set this request was send in, if not specified in the HTTP headers
/// it defaults to the character set of the page it is being submitted to.
Property CharSet As %String;

/// Internal character set to use to convert the input, will be the <property>CharSet</property> if
/// specified in the HTTP headers, else we determine this from the page this is being dispatched to.
Property ConvertCharSet As %String [ Internal, Private ];

/// A <class>%CSP.Stream</class> containing the content submitted
/// with this request.
Property Content As %CSP.Stream;

/// A string indicating HTTP method used for this request. Normally one
/// of 'GET', 'POST', or 'HEAD'.
Property Method As %String;

/// HTTP protocol version of the browser request. Normally either
/// 'HTTP/1.0' for older browsers and 'HTTP/1.1' for newer browsers.
Property Protocol As %String;

Method ProtocolSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%Protocol=val
	Quit $$$OK
}

/// True if the communication between the browser and the web server was using
/// the secure https protocol. False for a normal http connection.
Property Secure As %Boolean [ InitialExpression = 0 ];

Method SecureSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%Secure=val
	Quit $$$OK
}

/// The section of the Url that the CSP Gateway on the web server matched
/// against to determine which Cach&eacute; server to send the request to.
/// If the Url was '/csp/samples/menu.csp' and the CSP Gateway is setup to
/// match all requests to '/csp' then this parameter would be '/csp'.
Property GatewayApplication As %String;

Method GatewayApplicationSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewayApplication=val
	Quit $$$OK
}

/// The name of the connection in the CSP Gateway that this request was sent to.
Property GatewayConnectionName As %String;

Method GatewayConnectionNameSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewayConnectionName=val
	Quit $$$OK
}

/// How the gateway obtained the sessionId infomration.<ul>
/// <li>0 - Field not defined</li>
/// <li>1 - New session generated by Gateway</li>
/// <li>2 - CSPCHD in url/form</li>
/// <li>3 - Browser cookie</li>
/// <li>4 - SOAP payload</li></ul>
Property GatewaySessionIdSource As %Integer [ Internal ];

Method GatewaySessionIdSourceSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewaySessionIdSource=val
	Quit $$$OK
}

/// True if the sessionId is newly assigned by the gatway, and false if it is provided by the browser
Property GatewayNewId As %Boolean [ InitialExpression = 0 ];

/// The internal build version of the CSP gateway talking to the server
Property GatewayBuild As %String;

Method GatewayBuildSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewayBuild=val
	Quit $$$OK
}

/// Internal information on CSP gateway functions
Property GatewayFunctions As %String [ Internal ];

Method GatewayFunctionsSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewayFunctions=val
	Quit $$$OK
}

/// The session cookie that the gateway picked as the sessionId
Property GatewaySessionCookie As %String;

Method GatewaySessionCookieSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewaySessionCookie=val
	Quit $$$OK
}

/// The instance host name of the gateway that is communicating with this process
Property GatewayInstanceName As %String;

Method GatewayInstanceNameSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%GatewayInstanceName=val
	Quit $$$OK
}

/// Internal property to hold CSP gateway originated error codes
Property GatewayError As %Status [ Internal ];

/// The section of the Url that has been matched against a CSP application name.
Property Application As %String;

Method ApplicationSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%Application=val
	Quit $$$OK
}

/// True if the request came the CSP gateway, and false if it was from the
/// command line or the built in web server.
Property CSPGatewayRequest As %Boolean [ InitialExpression = 0 ];

Method CSPGatewayRequestSet(val As %String) As %Status [ Internal, Private ]
{
	Set i%CSPGatewayRequest=val
	Quit $$$OK
}

/// The value of the Server Response Timeout in the Gateway configuration.
Property GatewayTimeout As %Integer [ InitialExpression = 60 ];

/// An array of strings containing any parameter name/value pairs associated with this request.
/// The format of this array is:<br><ul>
/// <li>%request.Data(&lt;NAME&gt;,&lt;INDEX&gt;)=&lt;VALUE&gt;</li>
/// <li>%request.Data(&lt;NAME&gt;,&lt;INDEX&gt;,"encrypt")=&lt;Encrypted state&gt;</li>
/// <li>%request.Data(&lt;NAME&gt;,&lt;INDEX&gt;,"O")=&lt;Order number item was added&gt;</li>
/// </ul>
/// Where &lt;NAME&gt; is the name of the parameter, &lt;INDEX&gt; is an index number starting at 1 as
/// you may have multiple parameters with the same name so subsequent ones will be added with
/// a higher index number. &lt;VALUE&gt; is the value of this parameter. &lt;Encrypted state&gt; is
/// 1 if the value of this parameter was encrpyted and 0 otherwise.<br>
/// Note that it is faster to access this multidimensional property directly rather than going through
/// the accessor methods. For example:
/// <example>
/// ; Set the index number one 'Name' to 'Value'
/// Set %request.Data("Name",1)="Value"
/// ; Output the value of parameter 'Name' for index number one (the default)
/// Write %request.Data("Name",1)
/// ; Insert a new value for parameter 'Name' to 'Value'
/// Set %request.Data("Name",$Order(%request.Data("Name",""),-1)+1)="Value"
/// ; Test if parameter 'Name' at index 2 is encrypted
/// If $Data(%request.Data("Name",2,"encrypt"))
/// </example>
Property Data As %String [ MultiDimensional ];

/// An array of strings containing any cookie values associated with this request.
/// The format of this array is:<br><ul>
/// <li>request.Cookies(&lt;NAME&gt;,&lt;INDEX&gt;)=&lt;VALUE&gt;</li>
/// </ul>
/// Where &lt;NAME&gt; is the name of the cookie, &lt;INDEX&gt; is an index number starting at 1 as
/// you may have multiple cookies with the same name so subsequent ones will be added with
/// a higher index number. &lt;VALUE&gt; is the value of this cookie.<br>
/// <br>
/// It is suggested that you use the accessor methods rather than set/get the value of this
/// multidimentional property directly.
Property Cookies As %String [ MultiDimensional ];

/// An array of streams containing any multipart/mime data associated with this request.
/// The format of this array is:<br><ul>
/// <li>request.MimeData(&lt;NAME&gt;,&lt;INDEX&gt;)=&lt;VALUE&gt;</li>
/// </ul>
/// Where &lt;NAME&gt; is the name of the mime data stream, &lt;INDEX&gt; is an index number starting at
/// 1 as you may have multiple mime streams with the same name so subsequent ones will be added with
/// a higher index number. &lt;VALUE&gt; is the Oref of the stream associated with this mime data.<br>
/// <br>
/// It is suggested that you use the accessor methods rather than set/get the value of this
/// multidimentional property directly.
Property MimeData As %CacheString [ MultiDimensional ];

/// An array of strings containing any environment values associated with this request.
/// The format of this array is:<br><ul>
/// <li>request.CgiEnvs(&lt;NAME&gt;)=&lt;VALUE&gt;</li>
/// </ul>
/// Where &lt;NAME&gt; is the name of the Cgi environment variable and &lt;VALUE&gt; is the
/// value of this environment variable.<br>
/// <br>
/// It is suggested that you use the accessor methods rather than set/get the value of this
/// multidimentional property directly.
Property CgiEnvs As %String [ MultiDimensional ];

/// Store some CSP application specific internal data for this request
Property AppData As %String [ Internal ];

Method AppDataSet(data As %String) As %Status [ Internal, Private ]
{
	Set i%AppData=data
	Quit $$$OK
}

/// Store some CSP application specific internal data for this request
Property AppMatch As %String [ Internal ];

Method AppMatchSet(data As %String) As %Status [ Internal, Private ]
{
	Set i%AppMatch=data
	Quit $$$OK
}

/// Classname we are going to call
Property Class As %String [ Internal ];

Method ClassSet(val As %String) As %Status [ Private ]
{
	Set i%Class=val
	Quit $$$OK
}

/// Type of request we have
Property Service As %String [ InitialExpression = "CSP", Internal ];

Method ServiceSet(val As %String) As %Status [ Private ]
{
	Set i%Service=val
	Quit $$$OK
}

Method UpdateURL(url As %String, servername As %String = "", response As %CSP.Response, update As %Boolean = 0) As %Status [ Internal ]
{
	#Dim serverurl,path,match,app,cookiepath
	If servername'="" { Set serverurl="//"_servername_url } Else { Set serverurl=url }
	Set app=$$getapp^%SYS.cspServer(serverurl,.path,.match)
	$$$CSPLogVar(2,"CSPServer", "[UpdateURL] Looking up: "_serverurl_" path found: "_path_" Appl= "_app, "", i%RequestId )
	If $extract(serverurl,1,2)="//" Set path=$extract(path,$length(servername)+3,*)
	#; For non-REST applications use older url format without any trailing '/' pieces if this is for a csp/cls/zen page
	If $$$GetSecurityApplicationsDispatchClass(app)="",$extract(url,$find(url,"."),*)["/" {
		Set ext=$zstrip($zconvert($piece($piece($piece(url,".",2,*),"/"),".",*),"l"),">W")
		If ext="cls"||(ext="zen")||(ext="csp") {
			Set url=$piece(url,".")_"."_$piece($piece(url,".",2,*),"/")
		}
	}
	#; Keep a copy of the original values so we can reset them before returning because of the
	#; gateway optimisation that only sends values that have changed over the link.
	If update=1 {
		If '$data(i%store("URL")),i%URL'="" Set i%store("URL")=i%URL
		If '$data(i%store("Method")),i%Method'="" Set i%store("Method")=i%Method
	}
	Set i%URL=url,i%AppData=app,i%Application=path,i%AppMatch=match,i%URLPrefix=$piece(path,match),i%PageName=$piece(url,"/",*),i%Class=""
	#; Only update the cookie path on the initial url as server side redirects do not effect the url the browser requested
	If 'update,$isobject($get(response))=1 {
		Set cookiepath=i%URLPrefix_$$$GetSecurityApplicationsCookiePath(app)
		If $zconvert($extract(url,1,$length(cookiepath)),"l")=$zconvert(cookiepath,"l") {
			Set cookiepath=$extract(url,1,$length(cookiepath))
		}
		If $extract(cookiepath,*)'="/" Set cookiepath=cookiepath_"/"
		Set response.CookiePath=cookiepath
	}
	If app="" {
		If $isobject($get(response))=1 Set response.OutputSessionToken=0
		Return $$$ERROR($$$CSPApplicationDoesNotExist,$zconvert($piece(url,"/",1,*-1),"l"))
	}
	#; Swap namespaces to the right one for this request, do not swap if using default error page
	If (url'=$$$DefaultErrorPage) {
		Set ns=$$$GetSecurityApplicationsNameSpace(app)
		Try {
			If ns'="" Set $namespace=ns
		} Catch {
			Set $namespace="%SYS"
			Return $$$ERROR($$$CSPNamespaceDoesNotExist,path,ns)
		}
	}

	#; REST request?
	Set cls=$$$GetSecurityApplicationsDispatchClass(app)
	If cls'="" {
		Set i%Service="REST",i%Class=cls
	} Else {
		#; Handle serving up static files if allowed, if so let the stream server do it
		If $case($zstrip($zconvert($piece(url,".",*),"l"),">W"),"csp":0,"cls":0,"csr":0,"zen":0,:1),update'=2 {
			#; UTF-8 encode the url as we decode url parameter later
			Set i%Data("FILE",1)=$zconvert(url,"O","UTF8"),i%Service="STREAM"
			Set url=$$CSPNormalizeURL^%SYS.cspServer($$$FileServerPage,url)
			Return ..UpdateURL(url,servername,"",2)
		}
		#; Now find the class associated with this page and for CSP files check if it is up to date (and if it needs compiling)
		Set ok=$$getClassName^%SYS.cspServer(url,path,app,.cls,match)
		If $$$ISERR(ok) Return ok
		Set i%Class=cls
	}

	#; Calculate the charset we need to apply to convert the input based on the page being dispatched to
	Try {
		Set nocharsetconvert=$parameter(cls,"NOCHARSETCONVERT"),charset=$parameter(cls,"CHARSET")
	} Catch {
		Set nocharsetconvert=0,charset=""
	}
	#; If no character set specified in the HTTP headers assume same as page we are now getting.
	Set i%ConvertCharSet=""
	If 'nocharsetconvert {
		If i%CharSet'="" Set charset=i%CharSet
		If charset="",$$$IsUnicode||('$get(^%SYS("CSP","8BitLocaleCharset"),0)) {
			Set i%ConvertCharSet="UTF8"
		} ElseIf charset'="" {
			Set tmpchar=$select($zconvert(charset,"l")="utf-8":"UTF8",1:$$MapCharset^%SYS.NLS(charset))
			If tmpchar="" Return $$$ERROR($$$CSPInvalidCharacterSet,charset)
			#; If the character set sent is the current one no conversion needed (and it generates an error to try).
			If tmpchar'="UTF8",tmpchar="RAW"||(tmpchar=$$GetCharset^%SYS.NLS()) Set tmpchar=""
			Set i%ConvertCharSet=tmpchar
		}
	}
	$$$CSPLogVar(2,"CSPServer", "[UpdateURL] Found cls: "_cls_" nocharsetconvert: "_nocharsetconvert_" charset:"_charset_" convert charset:"_i%ConvertCharSet, "", i%RequestId )
	
	Quit $$$OK
}

/// Returns the value of name-value pair <VAR>name</VAR>.
/// <P>If more than one value is associated with <VAR>name</VAR>, then the values 
/// are subscripted using <VAR>index</VAR> starting with 1. Note that any encrypted
/// parameters will have lower index values than any unencrypted parameters, and so
/// will come first when you loop through them.
/// <P>If the name-value pair is not defined, returns the value of <VAR>default</VAR>.
/// This is deprecated in favour of accessing the <property>Data</property> directly
/// because this is faster, for example this is equivalent to:
/// <example>
/// Set return=$Get(%request.Data(name,index),default)
/// </example>
Method Get(name As %String, default As %String = "", index As %Integer = 1) As %String [ CodeMode = expression, Final ]
{
$get(i%Data(name,index),default)
}

/// Set the name-value par <var>name</var> to <var>value</var>. As more than one value
/// can be associated with <var>name</var> you can specify an <var>index</var> which
/// is an integer subscript starting at 1 (the default). This is now deprecated in favour
/// of accessing the <property>Data</property> directly because this is faster, for
/// example this is equivalent to:
/// <example>
/// Set %request.Data(name,index)=value
/// </example>
Method Set(name As %String, value As %String, index As %Integer = 1) [ Final, Internal ]
{
	If $length(name)>254 Quit
	Set i%Data(name,index)=value
	QUIT
}

/// Insert the value of name-value pair <VAR>name</VAR> to <VAR>value</VAR>.
/// <P>If more than one value is associated with <VAR>name</VAR>, then the values 
/// are subscripted using <VAR>index</VAR> starting with 1. This is deprecated in
/// favour of accessing the <property>Data</property> directly because this is faster, for
/// example this is equivalent to:
/// <example>
/// Set %request.Data(name,$Order(%request.Data(name,""),-1)+1)=value
/// </example>
Method Insert(name As %String, value As %String) [ Final ]
{
	If $length(name)>254 Quit
	Set i%Data(name,$order(i%Data(name,""),-1)+1)=value
	Quit
}

/// Tests if a name-value pair <VAR>name</VAR> is defined. This is deprecated in
/// favour of accessing the <property>Data</property> directly because this is faster, for
/// example this is equivalent to:
/// <example>
/// Set return=$Data(%request.Data(name,index))
/// </example>
Method IsDefined(name As %String, index As %Integer = 1) As %Boolean [ CodeMode = expression, Final ]
{
$data(i%Data(name,index))
}

/// Returns the number of values associated with the name-value pair <VAR>name</VAR>.
Method Count(name As %String) As %Integer [ Final ]
{
	#Dim count,i
	Quit:'$data(i%Data(name)) 0
	Set count=0 Set i="" For  Set i=$order(i%Data(name,i)) Quit:i=""  Set count=count+1
	Quit count
}

/// Returns the index of the name-value pair for <VAR>name</VAR>
/// with <VAR>value</VAR>.  If not found, return "".
Method Find(name As %String, value As %String) As %Integer [ Final ]
{
	#Dim i
	Set i=$order(i%Data(name,""))
	While (i'="")&&(i%Data(name,i)'=value) { Set i=$order(i%Data(name,i)) }
	Quit i
}

/// Pass the <var>index</var> by reference and it updates it with the next index number for
/// the name-value pair <var>name</var>. The method returns the value at the new index number.
/// This is useful for looping through the index values. This is deprecated in
/// favour of accessing the <property>Data</property> directly because this is faster, for
/// example this is equivalent to:
/// <example>
/// Set index=$Order(%request.Data(name,index),1,return)
/// </example>
Method NextIndex(name As %String, ByRef index As %Integer = "") As %String [ Final ]
{
	Set index=$order(i%Data(name,index))
	Quit:index="" ""
	Quit i%Data(name,index)
}

/// Return true if the name-value pair <var>name</var> at <var>index</var> is encrypted in the
/// url and false if it is not. This is useful to check that a parameter value that should 
/// not be altered and so is generated and encrypted on the server has not been replaced by
/// the user by a 'http://machine/url.csp?PARAM=TEST' rather than the encrypted string produced
/// by the server. This is deprecated in favour of access the <property>Data</property> directly
/// because this is faster, for example this is equivalent to:
/// <example>
/// Set return=$Get(%request.Data(name,index,"encrypt"),0)
/// </example>
Method IsEncrypted(name As %String, index As %Integer = 1) As %Boolean [ CodeMode = expression, Final ]
{
$get(i%Data(name,index,"encrypt"),0)
}

/// Given an encrypted <var>string</var> that is a series of name-value pairs and a <var>key</var>
/// to decrypt it with this will insert them into the request and set the encrypted flag.
Method Decrypt(data As %String, key As %String) As %Status [ Final ]
{
	#Dim ok,i
	If '$data(data) {
		Set ok=$$$OK,i=""
		For  Set i=$order(i%Data("CSPToken",i),1,data) Quit:i=""  Set ok=..realDecrypt(data,key) Quit:$$$ISERR(ok)
		Quit ok
	} Else {
		Quit ..realDecrypt(data,key)
	}
}

/// Internal utility function for decryption.
Method realDecrypt(data As %String, key As %String) As %Status [ Final, Internal, Private ]
{
	#Dim query,i,tmp,value,k
	Try {
		Set query=$$$cspDecode(key,data)
		For i=1:1:$listlength(query) {
			Set tmp=$list(query,i)
			If $listlength(tmp)=1 {
				Set i%Data("CSPPAGE",1)=$list(tmp),i%Data("CSPPAGE",1,"encrypt")=1
			} Else {
				Set key=$listget(tmp),value=$listget(tmp,2)
				If key'="",key'="CSPToken" {
					#; The encrypted keys must appear before any non encrypted ones
					For k=$order(i%Data(key,""),-1):-1:1 Merge i%Data(key,k+1)=i%Data(key,k) Kill i%Data(key,k)
					Set i%Data(key,1)=value,i%Data(key,1,"encrypt")=1
				}
			}
		}
	} Catch {
		Return $select($zerror["<ILLEGAL VALUE>"||($zerror["<FUNCTION>"):$$$ERROR($$$InvalidDecrypt),1:$$$ERROR($$$CacheError,$zerror))
	}
	Quit $$$OK
}

/// Returns the next key in sequence. This is deprecated in favour of accessing the
/// <property>Data</property> directly because this is faster. The call is equivalent
/// to the code:
/// <example>
/// Set return=$Order(%request.Data(name))
/// </example>
Method Next(name As %String) As %String [ CodeMode = expression, Final ]
{
$order(i%Data(name))
}

/// Removes this key from the collection, returns true if the valued existed
/// and false if it never existed. This is deprecated in favour of accessing the
/// <property>Data</property> directly because this is faster. This call is
/// equivalent to the following:
/// <example>
/// ; If index=""
/// Kill %request.Data(name)
/// ; If index'=""
/// Kill %request.Data(name,index)
/// </example>
Method Delete(name As %String, index As %Integer = "") As %Boolean [ Final, Internal ]
{
	If index="" {
		If $data(i%Data(name)) Kill i%Data(name) Quit 1
	} ElseIf $data(i%Data(name,index)) {
		Kill i%Data(name,index)
		Quit 1
	}
	Quit 0
}

/// Retrieves the named cookie
Method GetCookie(name As %String, default As %String = "", index As %Integer = 1) As %String [ CodeMode = expression, Final ]
{
$get(i%Cookies(name,index),default)
}

/// Inserts a cookie name/value pair.
Method InsertCookie(name As %String, value As %String) [ Final, Internal ]
{
	If name="" Quit $$$OK
	Set i%Cookies(name,$order(i%Cookies(name,""),-1)+1)=value
	Quit
}

/// Returns true if the named cookie exists in the cookie collection, false otherwise.
Method IsDefinedCookie(name As %String, index As %Integer = 1) As %Boolean [ CodeMode = expression, Final ]
{
$data(i%Cookies(name,index))
}

/// Returns the count of cookies with this name.
Method CountCookie(name As %String) As %Integer [ Final ]
{
	#Dim count,i
	Quit:'$data(i%Cookies(name)) 0
	Set count=0 Set i="" For  Set i=$order(i%Cookies(name,i)) Quit:i=""  Set count=count+1
	Quit count
}

/// Retrieves the next cookie name in the sequence
Method NextCookie(name As %String) As %String [ CodeMode = expression, Final ]
{
$order(i%Cookies(name))
}

/// Removes this cookie from the collection, returns true if the cookie existed and
/// false if it never existed.
Method DeleteCookie(name As %String, index As %Integer = "") As %Boolean [ Final, Internal ]
{
	If index="" {
		If $data(i%Cookies(name)) Kill i%Cookies(name) Quit 1
	} ElseIf $data(i%Cookies(name,index)) {
		Kill i%Cookies(name,index)
		Quit 1
	}
	Quit 0
}

/// Retrieves the named multipart MIME stream.
Method GetMimeData(name As %String, default As %Stream.Object = "", index As %Integer = 1) As %Stream.Object [ CodeMode = expression, Final ]
{
$get(i%MimeData(name,index),default)
}

/// Inserts a multipart MIME stream by name into the collection.
Method InsertMimeData(name As %String, value As %Stream.Object) [ Final, Internal ]
{
	If value="" Quit
	Set i%MimeData(name,$order(i%MimeData(name,""),-1)+1)=value
	Quit
}

/// Returns true if the named multipart MIME stream exists in the collection, false otherwise.
Method IsDefinedMimeData(name As %String, index As %Integer = 1) As %Boolean [ CodeMode = expression, Final ]
{
$data(i%MimeData(name,index))
}

/// Returns the count of multipart MIME streams with this name.
Method CountMimeData(name As %String) As %Integer [ Final ]
{
	#Dim count,i
	
	Quit:'$data(i%MimeData(name)) 0
	Set count=0 Set i="" For  Set i=$order(i%MimeData(name,i)) Quit:i=""  Set count=count+1
	Quit count
}

/// Retrieves name of the next multipart MIME stream stored in the request object.
Method NextMimeData(name As %String) As %String [ CodeMode = expression, Final ]
{
$order(i%MimeData(name))
}

/// Return the index number of the next multipart MIME stream stored in the request object.
Method NextMimeDataIndex(name As %String, index As %Integer = "") As %String [ CodeMode = expression, Final ]
{
$order(i%MimeData(name,index))
}

/// Removes this multipart MIME stream from the collection. Returns the number
/// of nodes it has removed. If <var>name</var> is not defined then it will
/// remove the entire set of MimeData, if <var>name</var> is defined but <var>index</var>
/// is not then it will remove all items stored under <var>name</var>.
Method DeleteMimeData(name As %String = "", index As %Integer = "") As %Integer [ Final, Internal ]
{
	#Dim defined
	If name="" {
		Set defined=0
		Set name=$order(i%MimeData(""))
		While name'="" {
			Set index=$order(i%MimeData(name,""))
			While index'="" { Set defined=defined+1,index=$order(i%MimeData(name,index)) }
			Set name=$Order(i%MimeData(name))
		}
		Kill i%MimeData
		Quit defined
	} ElseIf index="" {
		Set defined=0
		Set index=$order(i%MimeData(name,""))
		While index'="" { Set defined=defined+1,index=$order(i%MimeData(name,index)) }
		Kill i%MimeData(name)
		Quit defined
	} ElseIf $Data(i%MimeData(name,index)) {
		Kill i%MimeData(name,index)
		Quit 1
	}
	Quit 0
}

/// Retrieves the named CGI environment variable.
Method GetCgiEnv(name As %String, default As %String = "") As %String [ CodeMode = expression, Final ]
{
$get(i%CgiEnvs(name),default)
}

/// Inserts a CGI environment variable by name into the collection.
Method InsertCgiEnv(name As %String, value As %String) [ Final, Internal ]
{
	Set i%CgiEnvs(name)=value Quit
}

/// Returns true if the named CGI environment variable exists in the collection, false otherwise.
Method IsDefinedCgiEnv(name As %String) As %Boolean [ CodeMode = expression, Final ]
{
$data(i%CgiEnvs(name))
}

/// Retrieves the next CGI environment variable name in the sequence
Method NextCgiEnv(name As %String) As %String [ CodeMode = expression, Final ]
{
$order(i%CgiEnvs(name))
}

/// Removes this CGI environment variable from the collection, returns true if the item
/// was defined and false if it was never defined.
Method DeleteCgiEnv(name As %String) As %Boolean [ Final, Internal ]
{
	If $data(i%CgiEnvs(name)) Kill i%CgiEnvs(name) Quit 1
	Quit 0
}

/// Resets this %CSP.Request object to its initial state
Method Reset() [ CodeMode = generator, Final ]
{
	#Dim set,kill,var,runtimetype,classtype,qvar
	Set %code=0,set="",kill=""
	Set var=$$$comMemberNext(%class,$$$cCLASSinstancevar,"")
	While var'="" {
		$$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,var,$$$cPROPruntimetype)
		Set classtype=$$$getClassType(runtimetype),qvar=$$$QN(var)
		If classtype'=$$$cCLASSCLASSTYPEDATATYPE {
			If var="Content"||(classtype=$$$cCLASSCLASSTYPEPERSISTENT)||(classtype=$$$cCLASSCLASSTYPESERIAL) {
				Set set=set_",r%"_qvar_"=$$$NULLOREF,i%"_qvar_"=$$$NULLOID" If $length(set)>80 $$$GENERATE("	Set "_$extract(set,2,*)) Set set=""
			} Else {
				Set set=set_",i%"_qvar_"=$$$NULLOREF" If $length(set)>80 $$$GENERATE("	Set "_$extract(set,2,*)) Set set=""
			}
		} ElseIf '$$$comMemberKeyGet(%class,$$$cCLASSproperty,var,$$$cPROPmultidimensional) {
			Set set=set_",i%"_qvar_"="_$$$comMemberKeyGet(%class,$$$cCLASSinstancevar,var,$$$cIVARinitialexpression) If $length(set)>80 $$$GENERATE("	Set "_$extract(set,2,*)) Set set=""
		} Else {
			Set kill=kill_",i%"_qvar
		}
		Set var=$$$comMemberNext(%class,$$$cCLASSinstancevar,var)
	}
	If set'="" $$$GENERATE("	Set "_$extract(set,2,*))
	If kill'="" $$$GENERATE("	Kill "_$extract(kill,2,*))
	$$$GENERATE(" Quit")
	
	Quit $$$OK
}

/// Internal function that resets some of the values in %CSP.Request object to its initial state.
/// Only for use by the CSP engine itself.
Method CSPGatewayReset() [ CodeMode = generator, Final, Internal ]
{
	#Dim set,kill,var,runtimetype,classtype,qvar
	
	Set %code=0,set="",kill=""
	Set var=$$$comMemberNext(%class,$$$cCLASSinstancevar,"")
	While var'="" {
		$$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,var,$$$cPROPruntimetype)
		Set classtype=$$$getClassType(runtimetype),qvar=$$$QN(var)
		If classtype'=$$$cCLASSCLASSTYPEDATATYPE {
			If var="Content"||(classtype=$$$cCLASSCLASSTYPEPERSISTENT)||(classtype=$$$cCLASSCLASSTYPESERIAL) {
				Set set=set_",r%"_qvar_"=$$$NULLOREF,i%"_qvar_"=$$$NULLOID" 
				If $length(set)>80 $$$GENERATE("	Set "_$extract(set,2,*)) Set set=""
			} Else {
				Set set=set_",i%"_qvar_"=$$$NULLOREF" 
				If $length(set)>80 $$$GENERATE("	Set "_$extract(set,2,*)) Set set=""
			}
		} ElseIf '$$$comMemberKeyGet(%class,$$$cCLASSproperty,var,$$$cPROPmultidimensional) {
			#; These variables are copied from cgi variables that are only sent by the gateway if they have changed
			If ",GatewayFunctions,UserAgent,Protocol,ContentType,CharSet,Secure,Method,GatewayApplication,GatewayConnectionName,GatewayTimeout,CSPGatewayRequest,GatewayBuild,GatewaySessionCookie,GatewayInstanceName,"'[(","_var_",") {
				Set set=set_",i%"_qvar_"="_$$$comMemberKeyGet(%class,$$$cCLASSinstancevar,var,$$$cIVARinitialexpression) 
				If $length(set)>80 $$$GENERATE("	Set "_$extract(set,2,*)) Set set=""
			}
		} ElseIf var'="CgiEnvs"&&(var'="Cookies") {
			Set kill=kill_",i%"_qvar
		}
		Set var=$$$comMemberNext(%class,$$$cCLASSinstancevar,var)
	}
	If set'="" $$$GENERATE("	Set "_$extract(set,2,*))
	Set str=""
	For var="URL","Method" {
		Set str=str_"If $data(i%store("""_var_"""),i%"_var_") {} "
	}
	$$$GENERATE("	"_$extract(str,1,*-1))
	If kill'="" $$$GENERATE("	Kill "_$extract(kill,2,*))
	$$$GENERATE("	Quit")
	
	Quit $$$OK
}

Method ProcessRequest(header As %String) [ Internal ]
{
	Do Request^%SYS.cspServer2(header)
}

Property ProcessedRequestType As %Boolean [ InitialExpression = 0, Internal ];

Property SoapAction As %String [ Internal, MultiDimensional ];

Method DetermineRequestType() [ Internal ]
{
	#; Determine if we are a web service
	Set i%ProcessedRequestType=1
	Kill i%SoapAction
	If '$data(i%CgiEnvs("HTTP_SOAPACTION"),i%SoapAction) {
		Set contenttype=$get(i%CgiEnvs("CONTENT_TYPE"))
		If ($zcvt($piece(contenttype,";",1),"L")="application/soap+xml") {
			If '##class(%Net.HttpRequest).ParseContent($piece(contenttype,";",2,*),.tmparray) {
				Set i%SoapAction=$c(1)_"SOAP1.2"
			}
		} ElseIf ($zcvt($piece(contenttype,";",1),"L")="multipart/related") {
			If '##class(%Net.HttpRequest).ParseContent($piece(contenttype,";",2,*),.tmparray),
			   $case($get(tmparray("type")),"application/xop+xml":1,"application/soap+xml":1,:0) {
				Set i%SoapAction=$c(1)_"SOAP1.2"
			}
		}
	}
	
	If ($zconvert($get(i%CgiEnvs("HTTP_UPGRADE")),"L")="websocket") {
		Set i%Service="WEBSOCKET"
	} ElseIf i%Service'="STREAM" {
		If $data(i%CgiEnvs("HTTP_ISCSOAP")) {
			If i%GatewayError'="" {
				Set i%Service="BINSOAP"
			} Else {
				Try {
					If $classmethod(i%Class,"%Extends","%SOAP.WebService") Set i%Service="BINSOAP"
				} Catch {
					#; If class does not exist we will assume BINSOAP so error reporting uses correct format
					Set i%Service="BINSOAP"
				}
			}
		} ElseIf $data(i%SoapAction) {
			If i%GatewayError'="" {
				Set i%Service="SOAP"
			} Else {
				Try {
					If $classmethod(i%Class,"%Extends","%SOAP.WebService") Set i%Service="SOAP"
				} Catch {
					#; If class does not exist we will assume SOAP so error reporting uses correct format
					Set i%Service="SOAP"
				}
			}
		}
	}
}

}
