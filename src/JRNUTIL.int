ROUTINE JRNUTIL [Type=INT]
JRNUTIL ; Extrinsic functs to manipulate journal file records ;$Change: 4521965 $
 ; Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/rtn/journal/jrnutil.mac#1 $
 /*
 +--------------------------------------------------------+
 | Copyright 1986-2015 by InterSystems Corporation,       |
 | Cambridge, Massachusetts, U.S.A.                       |
 | All rights reserved.                                   |
 |                                                        |
 | Confidential, unpublished property of InterSystems.    |
 |                                                        |
 | This media contains an authorized copy or copies       |
 | of material copyrighted by InterSystems and is the     |
 | confidential, unpublished property of InterSystems.    |
 | This copyright notice and any other copyright notices  |
 | included in machine readable copies must be reproduced |
 | on all authorized copies.                              |
 +--------------------------------------------------------+
 */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/_syJrninc.inc#1 $ ($Change: 4521965 $) */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/FILEINC.inc#1 $ ($Change: 4521965 $) */
 ;  Return values:
 ;
 ; Provides extrinsic functions to manipulate journal file records
 ; in a non-interactive fashion. One can open/use/close a journal 
 ; file, delete a journal file, switch journalling to another file
 ; as well as read /delete a record from an open journal file. 
 ;
 ;
 ;*******************************************************************
 ; $$GETREC(ADDR,.JRNODE)  : read a record 
 ;
 ;   Input: -  ADDR, address of the record to be read.
 ;          -  JRNODE, a local variable which should be passed by 
 ;             reference, so that it returns the information about the
 ;             record.
 ;   Output:   -13   ( cluster record, not supported )
 ;             -11   ( journal file empty )
 ;             -12   ( invalid address )
 ;             -9    ( journal file not open )
 ;              1    ( success )  which in this case:
 ;              JRNODE array: 
 ;              JRNODE(1,1)= pid/prev/next:type:collation:glo  ;LFT379 added collation
 ;                 pid  is the process id.
 ;                 prev/next are previous/next adjacent record addrs 
 ;                 type is "S", "K", "k", "ZK", "B", "C", "NS, "NK",
 ;                      "s" (for Set $BIT), "Ns" (for network Set $BIT), ;RAM990
 ;                      or "ZNK" designating the type of the record.
 ;                 glo is the complete global reference name.
 ;                              -or- (see note below)
 ;              JRNODE(1,1)= pid,remsysid/prev/next:type:collation:glo ;LFT379 added collation
 ;                 pid  is the process id on the remote system
 ;                 remsysid is the internal unique id of the remote
 ;                      system
 ;                 prev/next are previous/next adjacent record addrs 
 ;                 type is "S", "K", "k", "ZK", "B", "C", "NS, "NK",
 ;                      "s" (for Set $BIT), "Ns" (for network Set $BIT), ;RAM990
 ;                      or "ZNK" designating the type of the record.
 ;                 glo is the complete global reference name.
 ;                         
 ;              JRNODE(1,1,1) contains the old value if the global had
 ;              a previous value and this record is for a SET or KILL.
 ;              In the case of Set $BIT, the old value is in the form
 ;              bitpos^bitval, where bitpos is the 1-based integer bit
 ;              position of the bit and bitval is either 0 or 1.
 ; 
 ;              JRNODE(1,1,2) contains the new value if type is "S"
 ;                  (for SET) or "s" (for Set $BIT)         ;RAM990
 ;              In the case of Set $BIT, the new value is in the form
 ;              bitpos^bitval, where bitpos is the 1-based integer bit
 ;              position of the bit and bitval is either 0 or 1.
 ;
 ;              JRNODE(1,1,3) contains the timestamp in $H format
 ;              Note re two forms of JRNNODE(1,1):
 ;                  journal records are added to the local journal both
 ;                  by local processes and by server deamons on behalf
 ;                  of remote processes. When a record is generated by
 ;                  a local process the remote system id is zero and
 ;                  the 1st field of JRNNODE(1,1) is simply the local
 ;                  process' pid. When a record is added on behalf of
 ;                  a remote job the pid is the pid of the job on the
 ;                  remote machine and the remote system id is
 ;                  non-zero. To avoid confusion since the pid on the
 ;                  remote machine could match a local pid, the remote
 ;                  system id is returned in the pid field seperated 
 ;                  from the pid with a comma.
 ;*******************************************************************
GETREC(ADDR,JRNODE) ;read a record from a journal file, and put info. in JRNODE
 S $ZT="ERR^"_$ZN
 N TYPE,TRANS,PID,GLO,PREV,NEXT
 N REMSYSID
 ;
 I $G(%JFILE)="" Q "-9,Journal file has not been opened"  
 I ADDR=0 S ADDR=$zu(78,17,ADDR) I ADDR<1 Q "-11,Journal file is empty"
 ;
 S TYPE=$$GETYPE(ADDR)
 I TYPE="" Q "-12,Record address is not valid"
 I TYPE["N" Q "-13,Record is a cluster record"
 ;
 i TYPE="M" d  q 1
 . n markinfo s markinfo=$ZU(78,35,ADDR)
 . S PREV=$zu(78,18,ADDR)
 . S NEXT=$zu(78,17,ADDR)
 . S JRNODE(1,1,2)=$p(markinfo,",",4,$l(markinfo))
 . S JRNODE(1,1)=$p(markinfo,",",3)_"/"_PREV_"/"_NEXT_":"_TYPE_":"_$p(markinfo,",",2)_":"_$p(markinfo,",")
 . S JRNODE(1,1,3)=$zu(78,24,ADDR)
 S TRANS=$zu(78,9,ADDR)  ; was it in a transaction
 S PID=$zu(78,10,ADDR)
 S REMSYSID=+$ZU(78,25,ADDR)
 i REMSYSID S PID=PID_","_REMSYSID
 i TYPE="E" d  q 1
 . S PREV=$zu(78,18,ADDR)
 . S NEXT=$zu(78,17,ADDR)
 . S JRNODE(1,1)=PID_"/"_PREV_"/"_NEXT_":"_TYPE_"::"_$zu(78,45,ADDR)
 . S JRNODE(1,1,3)=$zu(78,24,ADDR)
 S GLO=$zu(78,13,ADDR)
 S PREV=$zu(78,18,ADDR)
 S NEXT=$zu(78,17,ADDR)
 S COLLATE=$ZU(78,27,ADDR)
 ;
 I TYPE="s" S JRNODE(1,1,2)=$zu(78,36,ADDR)_"^"_$zu(78,37,ADDR)
 I TRANS=1,TYPE="s" S JRNODE(1,1,1)=$zu(78,36,ADDR)_"^"_(1-$zu(78,37,ADDR))
 I TYPE="S" S JRNODE(1,1,2)=$zu(78,15,ADDR) ;Get new value
 I TRANS=1,"Kk"[TYPE,$zu(78,14,ADDR)>0 S JRNODE(1,1,1)=$zu(78,16,ADDR)
 I TRANS=1,TYPE="S",$zu(78,14,ADDR)>1 S JRNODE(1,1,1)=$zu(78,16,ADDR)
 S JRNODE(1,1)=PID_"/"_PREV_"/"_NEXT_":"_TYPE_":"_COLLATE_":"_GLO
 S JRNODE(1,1,3)=$zu(78,24,ADDR)
 Q 1
 ;********************************************************************
 ; $$DELREC(ADDR):  Delete a record from the currently being used file
 ;
 ;   Input:  - ADDR, is the address of the record to be deleted
 ;
 ;   Output:   -13  ( cluster record )
 ;             -12  ( invalid address )
 ;             -11  ( FILE IS EMPTY )
 ;             -9   ( file not open / used )
 ;              1   ( success )
 ;********************************************************************
DELREC(ADDR)   ; delete a record from a journal file
 S $ZT="ERR^"_$ZN
 N X,TYPE
 ;
 I $G(%JFILE)="" Q "-9,Journal file has not been opened"
 I 'ADDR S ADDR=$zu(78,17,ADDR) I ADDR<1 Q "-11,Journal file is empty"
 ;
 S TYPE=$$GETYPE(ADDR)
 I TYPE="" Q "-12,Record address is not valid"
 I TYPE["N" Q "-13,Record is a cluster record"  ; Cluster type
 ;
 S X=$zu(78,19,ADDR) ;Remove the record
 I X<0 Q "-15,Unsuccessful operation"
 ;
 Q 1
 ;*********************************************************************
GETYPE(ADDR) ; return record type, string format
 S $ZT="GetErr^"_$ZN
 N TYPE,TYPECODE
 S TYPE=$zu(78,8,ADDR)
 ;
 I TYPE=4 Q "B"   ; begin transaction
 I TYPE=5 Q "C"     ; commit transaction
 I TYPE=6 Q "S"       ; set a node
 I TYPE=7 Q "K"       ; kill a node
 I TYPE=8 Q "k"    ; kill of a decendent node
 I TYPE=9 Q "ZK"     ; zkill (kill only this node)
 I TYPE=10 Q "NS"      ; network set
 I TYPE=11 Q "NK"     ; network kill
 I TYPE=12 q "NZK"  ; network zkill
 i TYPE=13 q "M"       ; journal marker
 I TYPE=14 Q "s"     ; set a specified bit position in a node
 i TYPE=15 q "E"     ; ECP networking
 i TYPE=21 q "RB"  ; Rollback			// GK939
 i TYPE=16 q "BTL"     ; Begin Transaction level
 i TYPE=17 q "PTL"  ;Commit pending level
 i TYPE=18 q "CTL"     ; Commit isolated level
 ;
GetErr Q ""  ; in case of error
 ;*********************************************************************
 ; $$DELFILE^JRNUTIL(JRNFILE) :  Delete a journal file
 ;   
 ;   Input:  - name of the journal file to be deleted
 ;             if the file is open, it won't be deleted
 ;      
 ;   Output:    -15  ( unknown error )
 ;              -10  ( not a journal file )
 ;              -6   ( file locked by another user )
 ;               1   ( success )
 ;*********************************************************************
DELFILE(JRNFILE,PurgeTimeH,errmsg)  ; delete a journal file
 S $ZT="ERR^"_$ZN
 N X,FILE,Y
 i ($zversion(1)=1) S FILE=$ZU(12,JRNFILE)
 i '($zversion(1)=1) S FILE=JRNFILE
 ;
 S Y=$ZU(78,22,FILE) ;Make sure it's a journal file 
 I 'Y {
   s Y=$zu(140,1,FILE)
   i Y=-2 Q 1 ;a nonexisting file (already deleted??)
   Q "-7,Unable to open journal file" ;due to permission issue?
 }
 I Y<1 Q "-10,File is not a journal file"
 ;
 S X=$ZU(78,23,FILE) ;Delete the file
 i X<0 {
   n errcode s errcode=$ZU(140,5,FILE)
   i errcode<0 {  ;error code from failure
     s errmsg=$zu(209,-errcode)
     s ^%SYS("JOURNAL","PURGEF",FILE)=$zdt($g(PurgeTimeH,$h),3) 
     I X=-1 Q "-16,File not found or open by another user"  ;File not found or locked by another user
     Q "-15,Unsuccessful operation"
   }
 }
 D History("DELETE",FILE)
 s ^%SYS("JOURNAL","PURGED",FILE)=$zdt($g(PurgeTimeH,$h),3) 
 s ^||%ISC.PurgedJrnFiles($i(^||%ISC.PurgedJrnFiles))=FILE
 Q 1
History(TYPE,FILE1,FILE2) ;
 d:TYPE="DELETE" $zu(9,"",TYPE_": "_FILE1,(0>0),0)
 q
HISTORY(type,file,curdir,altdir,prefix,short,jrnhist) 
 d $zu(9,"",type_": "_file,(0>0),0)
 q
 ; 
 ; clean up old journal history entries (can be run as stand-alone)
 ; LIFESPAN = 0: automatic purge is disabled
 ; purge entries down to the last STOP'ed journal whose "DATE" subentry
 ;   has 2nd field (session end date) beyond LIFESPAN (=30 days), OR 
 ;   prior to the last START'ed entry whose "DATE" subentry has 1st field 
 ;   (session begin date) beyond LIFESPAN.
PURGE ; purge journal files and history
 g PPURGE
 q
okpurge(flifespan,hlifespan) ;flifespan/hlifespan: lifespan of journal file/history
 s flifespan=+$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 s hlifespan=$s(flifespan>30:flifespan,1:30)
 s ^%SYS("JOURNAL","LIFESPAN")=hlifespan
 q 1
PPURGE ;
 s $zt="etPPURGE"
 n flifespan
 Set flifespan=""
 if $d(^$ROUTINE("%ZJRNPURGE")) s flifespan=$$^%ZJRNPURGE()
 s:flifespan="" flifespan=$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 d Purge(flifespan)
 q
Purge(flifespan,CheckOnly,purgenode) ;internal entry point
 s CheckOnly=+$g(CheckOnly)
 n hlifespan,f,date,fdate
 n numbck,numday,limitbybck,limitbyday,limitbytran,limitall,limit
 n i,time,jrnf,jrnfbck,jrnftran,stat,prev
 L +^%SYS("JOURNAL","PURGE"):10 
 i '$t {
   d $zu(9,"","Skip journal purging as one is in progress by PID "_$g(^%SYS("JOURNAL","PURGE")),(0>0),0)
   q
 }
 s ^%SYS("JOURNAL","PURGE")=$j
 s $zt="etPPURGE"
 d PurgeInt
 k ^%SYS("JOURNAL","PURGE")
 L -^%SYS("JOURNAL","PURGE")
 q
PurgeInt ;
 n ret s time=$h
 n errmsg
 s jrnf="" f  { ;try purging any files that failed to get purged before
   s jrnf=$o(^%SYS("JOURNAL","PURGEF",jrnf)) q:jrnf=""  
   k errmsg s ret=$$DELFILE(jrnf,time,.errmsg) 
   i ret>0 k ^%SYS("JOURNAL","PURGEF",jrnf)
   e  d msglog("Unable to delete file "_jrnf_": "_$s($g(errmsg)="":ret,1:errmsg),1)
 }
 s numbck=$p(flifespan,",",2),numday=+flifespan,date=$p($h,",")
 s limitall=$zd(0,8)_".000J"  ;a limit that prevents any file from being purged
 i numday s limitbyday=$zd(date-numday,8)_".000J"
 e  s limitbyday=limitall  ;don't purge files by days
 i numbck d  i 1
 . s time=$$GetGoodBackups(numbck)
 . i time="" s limitbybck=limitall q  ;nothing meets the backup criterion
 . s jrnfbck=$g(^SYS("BUHISTORY",time,"JOURNAL"))
 . i jrnfbck="" s limitbybck=$zd(time\1000000,8)_".000J"
 . e  s limitbybck=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfbck,";"),0:$e(jrnfbck,*-8-$l($p(jrnfbck,".",$l(jrnfbck,"."))),*),:$e(jrnfbck,*-8-$l($p(jrnfbck,".",$l(jrnfbck,"."))),$f(jrnfbck,";")-2)),:jrnfbck)_"A"
 e  s limitbybck=limitall  ;don't purge files based on backups
 s limit=$s((($p(limitbyday,".")>$p(limitbybck,"."))||(($p(limitbyday,".")=$p(limitbybck,"."))&&($p(limitbyday,".",2)>$p(limitbybck,".",2)))):limitbyday,1:limitbybck) 
 n PurgedFiles,mirname,rc,Status
 n jrndatamove,limitbyDM,SQLCODE  ; The query will create SQLCODE variable.
 s rc=##class(DataMove.Data).GetEarliestJRNCUR(.jrndatamove)
 if (''rc),jrndatamove'="" {
	 s limitbyDM=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrndatamove,";"),0:$e(jrndatamove,*-8-$l($p(jrndatamove,".",$l(jrndatamove,"."))),*),:$e(jrndatamove,*-8-$l($p(jrndatamove,".",$l(jrndatamove,"."))),$f(jrndatamove,";")-2)),:jrndatamove)_"A"
	 if (($p(limit,".")>$p(limitbyDM,"."))||(($p(limit,".")=$p(limitbyDM,"."))&&($p(limit,".",2)>$p(limitbyDM,".",2)))) {
	   s limit=limitbyDM,limitbybck=limitbyDM,jrnfbck=jrndatamove
	   d msglog("Preserving journal files "_jrnfbck_" and later for DataMove",2)
	 }
 }
 i $SYSTEM.Mirror.IsAsyncMember(),$SYSTEM.Mirror.AsyncMemberType() {
	if limit=limitbybck {	;purging limited by #backups
		s mirfilecnt=(+$P($ZU(78,22,jrnfbck,13),",",2))
		i 'mirfilecnt {
			s limitx=jrnfbck ;path of a non-mirror or non-existing file
		} else {
			s limitx=(mirfilecnt-1)_"C"
		}
	} else {
		s limitx=limit
	}
 	d ##class(SYS.Mirror).PurgeAsyncMemberJournalFiles(.Status,CheckOnly,,,,.PurgedFiles,limitx)
	s mirname="" f  {
		s mirname=$o(Status(mirname),1,rc) q:mirname=""
		i ('rc) {
			d $zu(9,"","Error purging async mirror '"_mirname_"' journal files: "_$System.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		} elseif 'CheckOnly {
			d msglog("Mirror '"_mirname_"' journal files purged: OK",0)
		}
	}
	i 'CheckOnly m ^||%ISC.PurgedMirJrnFiles=PurgedFiles
 }
 i limit=limitall q  ;none to purge (neither files nor history)
 s limitbytran=$$GetTranLimit(.jrnftran) 
 n mirrjrnf,mirlimit,mirlimitbytran,mirfilecnt,StartFile
 i $SYSTEM.Mirror.IsMember()=1||($SYSTEM.Mirror.IsMember()=2&&($SYSTEM.Mirror.AsyncMemberType()=0)) {	;a failover member (NOT async member)
	s mirrjrnf="" ;the oldest mirror journal file NOT to be purged
	i $g(jrnftran)]"" {
	  s jrnf=$zu(78,3),prev="" f  {
	    s prev=$zu(78,22,jrnf,1) q:prev'>0  ;jrnf is non-existent or bad
	    s prev=$p(prev,",",2) ;path of previous journal file; could be ""
	    i (+$P($ZU(78,22,jrnf,13),",",2)) s mirrjrnf=jrnf
	    i jrnf=jrnftran q  ;done checking files needed for local recovery
	    i prev="" q  ;shouldn't happen, since jrnftran]""
	    s jrnf=prev
	  }
	}
	i mirrjrnf="" s mirlimitbytran=$zd($h+1,8)_".000J" ;all can be purged
	e  s mirlimitbytran=$case($ZBITGET($ZVERSION(0),46),0:$case($f(mirrjrnf,";"),0:$e(mirrjrnf,*-8-$l($p(mirrjrnf,".",$l(mirrjrnf,"."))),*),:$e(mirrjrnf,*-8-$l($p(mirrjrnf,".",$l(mirrjrnf,"."))),$f(mirrjrnf,";")-2)),:mirrjrnf)_"A"
	s mirlimit=limit ;keep limit intact as we use it to purge local files
        i (($p(limit,".")>$p(mirlimitbytran,"."))||(($p(limit,".")=$p(mirlimitbytran,"."))&&($p(limit,".",2)>$p(mirlimitbytran,".",2)))) {;purging limited by local recovery
	  s mirfilecnt=(+$P($ZU(78,22,mirrjrnf,13),",",2))
	  s StartFile=(mirfilecnt-1)_"C" 
          d msglog("Preserving mirror journal files "_mirrjrnf_" and later for local recovery",2)
	} elseif limit=limitbybck {	;purging limited by #backups
	  s mirfilecnt=(+$P($ZU(78,22,jrnfbck,13),",",2))
	  i 'mirfilecnt {
	    s StartFile=jrnfbck ;path of a non-mirror or non-existing file
	  } else {
	    s StartFile=(mirfilecnt-1)_"C"
	  }
	} else { ;$p(limit,".",2)="000J" (purging limited by a date)
	  s StartFile=limit\1_"D" ;a date (YYYYMMDD)
	}
 }
 i (($p(limit,".")>$p(limitbytran,"."))||(($p(limit,".")=$p(limitbytran,"."))&&($p(limit,".",2)>$p(limitbytran,".",2)))) {
   s limit=limitbytran,jrnf=jrnftran
   i jrnftran'=$zu(78,3),jrnftran'=$g(mirrjrnf) {
     d msglog("Preserving journal files "_jrnftran_" and later for journal recovery and transaction rollback",2)
   }
 } elseif limit=limitbybck {
   s jrnf=jrnfbck ;limitbytran]limit
 }
 i $p(limit,".",2)="000J" s jrnf=$$getfpurge(limit\1) i 1
 e  s stat=$$PREVJRN^JRNUTIL2(jrnf,.prev) d
 . i stat>0 s jrnf=prev q
 . s jrnf="" 
 s purgenode=$g(purgenode,$name(^||%ISC.JRN.PURGE)) k @purgenode
 ;store to-purge files in purgenode("-") (to distinguish it from mirrorname)
 i jrnf]"" d BuildPurgeList(jrnf,$s(CheckOnly:$name(@purgenode@("+")),1:purgenode))
 i $d(StartFile) { ;StartFile is set above on a failover member
 	s rc=##class(SYS.Mirror).PurgeJournalFiles(CheckOnly,StartFile,,,,,,.PurgedFiles)
	if ('rc) {
		k errtxt 
		Do DecomposeStatus^%apiOBJ(rc,.errtxt,"-d") 
		d $zu(9,"","Error purging mirror journal files up to '"_limit_"': "_errtxt(1),1 /* broadcast and log message*/,1  /* Warning */)
	}
	i 'CheckOnly m ^||%ISC.PurgedMirJrnFiles=PurgedFiles
 }
 i CheckOnly {
   s i="" f  {
     s i=$o(@purgenode@("+",i),1,file) q:i=""
     k @purgenode@("+",i)
     s @purgenode@("-",-i)=file
   }
   m @purgenode=PurgedFiles 
   q  ;done checking for files eligible for purging
 } 
 i $d(@purgenode) d FPURGE(purgenode)
 s hlifespan=$g(^%SYS("JOURNAL","LIFESPAN"),30) i 'hlifespan q
 s fdate=$zdh($s(jrnf="":limit,1:$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf))\1,8)
 i fdate>(date-hlifespan) s fdate=date-hlifespan
 e  s hlifespan=date-fdate
 s stat=##class(%SYS.Journal.System).PurgeHistory(hlifespan)
 i 'stat d msglog("Error purging journal history: "_$System.Status.GetErrorText(stat))
 ; Now that we may have deleted some journal files, open the oldest existing
 ; file and clean out the jobid's in SYS("PIDList") which preceed this file.
 do PurgePIDList(numday)   ;JO2322
 i $s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) d PURGE^JRNINFO(1)
 q
etPPURGE ;
 s $zt="" 
 k ^%SYS("JOURNAL","PURGE")
 L -^%SYS("JOURNAL","PURGE")
 d BACK^%ETN
 d $zu(9,"","ERROR in purging journal files: "_$ze,(0>0),0)
 q
GetGoodBackups(numbck) ;
 n time,bckcnt s time="",bckcnt=0 f  {
   s time=$o(^SYS("BUHISTORY",time),-1) q:time=""
   i $g(^SYS("BUHISTORY",time,"Complete"))'>0 s bckcnt=0 
   e  i $i(bckcnt)=numbck q
 }
 q time
GetTranLimit(jrnf) ;
 n limit,limitnone,jrninfo,jrninfo,fcnt,file,limitcnt,cnt,prev,stat
 s $zt="GetTranLimitE"
 s limitnone=$zd($h+1,8)_".000J"   ;NOT preventing any file from being purged
 s jrninfo=$zu(78,21)
 s fcnt=$p(jrninfo,",",3)
 s file=$p(jrninfo,",",2) ;fcnt = file counter of 'file'
 i file="" {
	 s file=$$GetPendingTransLimit(0)
	 if file '="" {
		 s jrnf=file
		 quit $case($ZBITGET($ZVERSION(0),46),0:$case($f(file,";"),0:$e(file,*-8-$l($p(file,".",$l(file,"."))),*),:$e(file,*-8-$l($p(file,".",$l(file,"."))),$f(file,";")-2)),:file)_"A"
	 }
	 q limitnone           ;journaling is off: no file to preserve
 }
 s limitcnt=$zu(78,21,1) ;file count of the oldest OPEN transaction
 i limitcnt>fcnt s limitcnt=fcnt ;oldest file count for crash recovery
 s limitcnt=$$nettranfile(limitcnt)  ;oldest file count with net transactions
 s jrnf=$$GetPendingTransLimit(limitcnt)
 if jrnf="" {
 	s cnt=fcnt
 	s jrnf=file 
 	f  {
	 	q:cnt=limitcnt  
	 	s stat=$zu(78,22,jrnf,1) 
	 	q:stat'>0  
	 	s prev=$p(stat,",",2) 
	 	q:prev=""  
	 	s cnt=cnt-1,jrnf=prev 
	 	q:cnt=limitcnt
 	}
 }
 q $case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf)_"A"  ;the full path 'jrnf' is returned by reference
GetTranLimitE s $zt="" d BACK^%ETN
 ztrap $ze
GetPendingTransLimit(limitcnt) {
 	s limit=""
	try {
 		s id=""
 		for  {
	 		s id=$O(^SYS("ROLLBACK","PENDING",id))
	 		quit:id=""
	 		s fileindex=+$G(^SYS("ROLLBACK","PENDING",id,"FileList"))
	 		if fileindex'=0 {
		 		s file=$G(^SYS("ROLLBACK","PENDING",id,"FileList",fileindex))
		 		if file'="" {
			 		; FileList is organized 1..n as newest->oldest so this is
			 		; the oldest file for this pending rollback
			 		s info=$zu(78,22,file,99)
			 		if +info=1 {
				 		s jrnfilecnt=$P(info,",",12+1)
					    if 'limitcnt || (jrnfilecnt<limitcnt) {
						    s limitcnt=jrnfilecnt
						    s limit=file
					    }
			 		}
		 		}
	 		}
 		}
	} catch {
		d BACK^%ETN
		ztrap $ze  ;resignal error
	}
	quit limit ; null or jrnfile required for pending trollback
}
 ; input: 
 ;   f - full name of the a journal file (because we need to call PREVJRN)
 ;   purge - the node for a list of (non-mirror) files to be purged 
BuildPurgeList(f,purge) ;
 n ret,pf,i
 s $zt="BuildPurgeListErr"
 ; First we build a list of files to purge so that we can purge the oldest one first.
 ; This is better than purging the latest one first in case we are interrupted.
 i $ZU(78,22,f)'>0,$g(^%SYS("JOURNAL","PURGED",f))]"" d loginfo1(f) q
 n jrnflist s jrnflist=$name(^||JrnFileList($i(^||JrnFileList))) k @jrnflist
 f i=1:1 {
	 s ret=$$PREVJRN^JRNUTIL2(f,.pf) 
	 q:ret'>0  
	 q:pf=""
 	 s @jrnflist@(f)=""
     if '(+$P($ZU(78,22,f,13),",",2)) {
        s @purge@(i)=f  ;f is guaranteed to be a journal file
     }
     s f=pf
     q:$d(@jrnflist@(f))
 }
 k @jrnflist
 ; Log possible errors and proceed to delete whatever we deem proper
 n errhead s errhead="Error in purging journal files: "
 i ret>0!(ret=-1) {
    if '(+$P($ZU(78,22,f,13),",",2)) {
	   s @purge@(i)=f  ;pf="" or no previous file
	}
 } else {
    d:ret msglog(errhead_$$ERNXPVJRN^JRNUTIL2(ret,f),0)  ;ret=0: f is gone probably because it has been deleted
 }
 q
BuildPurgeListErr ;
 s $zt=""
 i $d(purge) k @purge
 d msglog("BuildPurgeList: "_$ze_"; purging may have been stopped prematurely")
 q
 ; input: 
 ;   purge - a list of files to be purged       
FPURGE(purge) ;to purge the given list of files
 n ret,pf,i
 s $zt="etFPURGE"
 n time,errmsg s time=$h s i="",ret=1 f  {
   s i=$o(@purge@(i),-1) q:i=""  
   k errmsg s ret=$$DELFILE(@purge@(i),time,.errmsg) 
   i ret>0 continue  ;success
   d msglog("Unable to delete file "_@purge@(i)_": "_$s($g(errmsg)="":ret,1:errmsg),1)
 }
 k @purge
 q
etFPURGE 
 s $zt=""
 i $d(purge) k @purge
 d msglog("fpurge: "_$ze_"; purging may have been stopped prematurely")
 q
PurgePIDList(daysold = 0) PUBLIC {  ;JO2322
	s $zt="err"
	; Cleans out older entries in the jobid->PID translation table
	; in ^SYS("PIDList"). Must be called while in the %SYS namespace
	; If daysold is specified then we simply clean out any PIDList entries
	; which are old than this value. 
	; If daysold is 0 then we find the oldest journal file on the system
	; and clean out entries in the PIDList which are more than one day older
	; than the earliest timestamp in this journal file. We don't want to clean 
	; out all the entries which are simply 'older' because some of those jobid's 
	; might be in the file which remains. The 'one day' limit is a bit arbitrary
	; but is designed to leave behind entries which are still valid for
	; the oldest remaining file.
	quit:'$ZBITGET($ZVERSION(0),40)   ;quit if not USETID
	i $d(^SYS("PIDList"))<10 k ^SYS("PIDList") q
	s msgtag="PurgePIDList^"_$ZN  ;for console log messages
	s cnt=0
	if daysold'=0 {
		s purgeday=$H-daysold 
		goto purgeentries
	} 
	;Get the 1st journal file from both the current and the alternate journal
	; directory and then use which ever is older. We don't use PREVJRN^JRNUTIL2
	; because that can return journal files that don't exist and we want the oldest
	; file which still exists.
	s cdir=$G(^%SYS("JOURNAL","CURDIR"),"")
	s cjrnf=""
	if cdir'="" {
		s cjrnf=$ZSEARCH(cdir_"*.*")
		if ($zversion(1)=3) {
			/* $zsearch() on Unix does not return ordered results so we need
			   to go through the entire directory and find the */
		   s minjrnf=""
		   s minval="99999999.001"  /* an impossibly large date */
		   while (cjrnf'="") {
			   s sname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(cjrnf,";"),0:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),*),:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),$f(cjrnf,";")-2)),:cjrnf)
			   if sname?8N1"."3.10N {
				   if sname<minval {
				      s minjrnf=cjrnf
				      s minval=sname
				   }
			   }
			   s cjrnf=$ZSEARCH("")
		   }
		   if minjrnf'="" {
			   s cjrnf=minjrnf
		   } 
		} else {
		   while (cjrnf'="") && '($case($ZBITGET($ZVERSION(0),46),0:$case($f(cjrnf,";"),0:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),*),:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),$f(cjrnf,";")-2)),:cjrnf)?8N1"."3.10N) {
			   s cjrnf=$ZSEARCH("")
		   }
		}
	}
	s ajrnf=""
	s dir=$G(^%SYS("JOURNAL","ALTDIR"),"")
	if dir'=cdir {
	   s ajrnf=$ZSEARCH(dir_"*.*")
		if ($zversion(1)=3) {
			/* $zsearch() on Unix does not return ordered results so we need
			   to go through the entire directory and find the */
		   s minval="99999999.001"  /* an impossibly large date */
		   s minjrnf=""
		   while (ajrnf'="") {
			   s sname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(ajrnf,";"),0:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),*),:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),$f(ajrnf,";")-2)),:ajrnf)
			   if sname?8N1"."3.10N {
				   if sname<minval {
				      s minjrnf=ajrnf
				      s minval=sname
				   }
			   }
			   s ajrnf=$ZSEARCH("")
		   }
		   if minjrnf'="" {
			   s ajrnf=minjrnf
		   } 
		} else {
	       while (ajrnf'="") && '($case($ZBITGET($ZVERSION(0),46),0:$case($f(ajrnf,";"),0:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),*),:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),$f(ajrnf,";")-2)),:ajrnf)?8N1"."3.10N) {
		      s ajrnf=$ZSEARCH("")
	       }
	   }
	}
	if ajrnf="" {
		s jrnf=cjrnf
	} elseif cjrnf="" {
		s jrnf=ajrnf
	} else {	// (ajrnf '= "") && (cjrnf '= "")
		s a1=$case($ZBITGET($ZVERSION(0),46),0:$case($f(ajrnf,";"),0:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),*),:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),$f(ajrnf,";")-2)),:ajrnf)
		s c1=$case($ZBITGET($ZVERSION(0),46),0:$case($f(cjrnf,";"),0:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),*),:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),$f(cjrnf,";")-2)),:cjrnf)
		if (($p(c1,".")>$p(a1,"."))||(($p(c1,".")=$p(a1,"."))&&($p(c1,".",2)>$p(a1,".",2)))) {
			s jrnf=ajrnf
		} else {
			s jrnf=cjrnf
		}
	}
	if jrnf="" do $ZU(9,"",msgtag_": Unable to locate any journal files in current or alternate journal directory") quit
	;
	; jrnf is now the oldest journal file on the system we could find. 
	s cretime=$ZU(78,22,jrnf,4)  ;returns "4,time(0)" journal file was created for success
	if +cretime'=4 do $ZU(9,"",msgtag_": Unable to determine creation time of journal: "_jrnf) quit
	s cretime=$P(cretime,",",2)
	s purgetime=cretime-(24*60*60)  ;cretime is in seconds, subtract one day
	;The format of PIDList is: ^SYS("PIDList",<jobid>,<day from $H>,<time from $H>)=<pid>
	s purgeday=+$zdth(purgetime,-2)  ;day portion of $H representing purgetime
purgeentries ;	
	s today=+$h  ; Also clean out entries from the future
	set jobid=$O(^SYS("PIDList",""))
	while (jobid'="") {
	   s lastpid=""
	   s day=$O(^SYS("PIDList",jobid,""))
	   while (day'="") && (day <= purgeday) {
		  s lastday=day
		  s lasttime=$O(^SYS("PIDList",jobid,day,""),-1,lastpid)
		  k ^SYS("PIDList",jobid,day)
	  	  s day=$O(^SYS("PIDList",jobid,"")) 
		  s cnt=cnt+1
	   }
 	   ; If this is the only record for the day, check whether
	   ; this job is still active on the system. For systems which
	   ; do not restart there will be some jobs which live across
	   ; journal file purges and we don't want to lose the translation
	   ; for them. jobid#65536 is the job # of the job. If that job
	   ; has the same jobid and pid as this one we recreate the most 
	   ; recent record.
	   s jobnum=$zb(+jobid,65535,1)  ;low 16 bits is the job #
	   if lastpid'="",($ZU(61,30,jobnum)=jobid),($ZU(61,jobnum)=lastpid) {
		   s ^SYS("PIDList",jobid,lastday,lasttime)=lastpid
		   s cnt=cnt-1  ;reduce the # of records killed
	   }
	   ; Sometimes when people play with the system clock we get
	   ; entries from the future
	   s day=$O(^SYS("PIDList",jobid,today)) 
	   while (day'="") {
		  s x=day
	  	  s day=$O(^SYS("PIDList",jobid,day)) 
		  k ^SYS("PIDList",jobid,x)
		  s cnt=cnt+1
	   }
       s jobid=$O(^SYS("PIDList",jobid))
	}
	s ^SYS("PIDList")=$H_"^"_cnt  ;Purge stats for last cleanup
	quit
err ;
	s $zt=""
	do $ZU(9,"",msgtag_": Unexpected error "_$ZE)	
	quit
}								
getfpurge(date) ;
 n jrnlogfile,filepath,dateh,dtutc
 s dateh=$zdh(date,8) ;(local) date in $H format
 s dtutc=$zu(193,dateh,1) ;UTC date/time in $H format
 s jrnlogfile=$zu(12)_"journal.log"
 i $zu(78,79,0,1,0)
 s $zt="ErPostLockLog"
 o jrnlogfile:($s(($zversion(1)=1):"rh",1:"r"):/IOT="UTF8"):0 e  d  q ""
 . i $zu(78,79,0,0,0)
 . d msglog("getpurge: failed to open journal log "_jrnlogfile) 
 n rc,zeofset,prevfile,lastfile,logline,utc
 s rc=##class(%SYS.Journal.System).GetHistoryHeader(jrnlogfile) ;skip header
 i 'rc c jrnlogfile d $zu(78,79,0,0,0),msglog("getfpurge: "_rc) q -1_","_rc
 s zeofset=$zu(68,40,1),filepath="",prevfile="",lastfile=""
 s $zt="ErPostOpenLog"
 f  {
   u jrnlogfile r logline 
   i $ZEOF s filepath="" q  ;jrnfile not found
   i logline="" continue  ;skip blank lines
   s lastfile=prevfile,prevfile=filepath,filepath=$p(logline,",",2)
   s utc=$p(logline,",",6) ;creation time in UTC
   i $zu(193,$zdth(utc,3),0)'<dateh q  ;the 1st file created on/after 'date'
 }
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q lastfile ;could be ""
ErPostLockLog s $zt="" d BACK^%ETN
 d msglog("getpurge: "_$ze)
 i $zu(78,79,0,0,0)
 q ""
ErPostOpenLog s $zt="" d BACK^%ETN
 d msglog("getpurge: "_$ze)
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q ""
getftime(jrnfile) [] public {
 s timeinfo=$zu(78,22,jrnfile,4)
 i timeinfo>0 { ;file exists
   s time0=$p(timeinfo,",",2) ;in time(0) format
   s timeh=$zdth(time0,-2) ;local time in $H format
   s timeutc=$zu(193,timeh,1) ;UTC time in $H format
   q $zdt(timeutc,3) ;YYYY-MM-DD HH:MM:SS
 }
 s jrnlogfile=$zu(12)_"journal.log"
 i $zu(78,79,0,1,0)
 s $zt="ErPostLockLog"
 o jrnlogfile:($s(($zversion(1)=1):"rh",1:"r"):/IOT="UTF8"):0 e  d  q ""
 . i $zu(78,79,0,0,0)
 . d msglog("getftime: failed to open journal log "_jrnlogfile) 
 s rc=##class(%SYS.Journal.History).GetHeader(jrnlogfile) ;skip header
 i 'rc c jrnlogfile d $zu(78,79,0,0,0),msglog("getftime: "_rc) q -1_","_rc
 s zeofset=$zu(68,40,1)
 s $zt="ErPostOpenLog"
 f  {
   u jrnlogfile r logline 
   i $ZEOF q  ;jrnfile not found
   i logline="" continue  ;skip blank lines
   i $p(logline,",",2)=jrnfile s timeutc=$p(logline,",",6) q  ;found it
 }
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q $g(timeutc) ;could be "" if jrnfile not found
ErPostLockLog s $zt="" d BACK^%ETN
 d msglog("getftime: "_$ze)
 i $zu(78,79,0,0,0)
 q ""
ErPostOpenLog s $zt="" d BACK^%ETN
 d msglog("getftime: "_$ze)
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q ""
}
getmfpurge(limit,mirrorname,err) [] public {
 i limit?8N1"D" { ;a (local) date boundary
   s loch=$zdh(+limit,8) ;(local) date in $H format
   s utch=$zu(193,loch,1) ;
   s timeutc=$zdt(utch,3)
 } elseif limit?8N1"."3.10N1"J" {
   ; a limit file name of the form yyyymmdd.000J
   s loch=$zdh($p(limit,"."),8) ; yyyymmdd -> $H format
   s utch=$zu(193,loch,1) ;
   s timeutc=$zdt(utch,3)
 } else { ;a local journal file presumably
   s timeutc=$$getftime(limit)
 }
 s $zt="getmfpurgeErr"
 s open=0,locked=0
 if timeutc="" {
	 s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(limit,";"),0:$e(limit,*-8-$l($p(limit,".",$l(limit,"."))),*),:$e(limit,*-8-$l($p(limit,".",$l(limit,"."))),$f(limit,";")-2)),:limit)  ;yyyymmdd.nnn
	 if shortname'?8N1"."3.10N {
	   s err=$$Error^%apiOBJ(2098,limit)
   	   quit ""
	 }
	 s loch=$zdh($p(shortname,"."),8) ; yyyymmdd -> $H format
   	 s utch=$zu(193,loch,1) ;
   	 s timeutc=$zdt(utch,3)
 }
 s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirrorname,0)
 i miridx<0 s miridx=0
 s miridx=miridx+1
 s logf=$zu(12)_"mirrorjrn-"_mirrorname_".log"
 s checksum=$zu(78,83,logf,miridx)
 if checksum=-1 {
	s rc=##class(SYS.Mirror).BuildJournalLog(mirrorname,0,"",,1)
	if ('rc) s err=rc g getmfpurgeExit
 }
 do $zu(78,79,0,1,miridx)
 s locked=1
 s zusav=$zu(68,40,1)
 o logf:"RSK\UTF8\":5
 if '$T {
   s err=$$Error^%apiOBJ(2004,mirrorname)
   goto getmfpurgeExit
 }
 s open=1
 s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
 i 'rc {
	s err=$$Error^%apiOBJ(2004,mirrorname)
	goto getmfpurgeExit
 }
 s prevline="",lastfile=""
 f  {
   use logf 
   read line
   q:$zeof
   s time=$p(line,",",4)
   i time]timeutc q  ;prevfile is the oldest file NOT to purge
   s lastfile=prevline,prevline=line
 }
 s mirfile=$p(lastfile,",")
getmfpurgeExit ;
 if open close logf s open=0
 if locked do $zu(78,79,0,0,miridx) s locked=0
 do $ZU(68,40,zusav)
 q $g(mirfile)
getmfpurgeErr s $zt="" s err=$$Error^%apiOBJ(5002,$ze) g getmfpurgeExit
}
SETLIFESPAN(flifespan,glifespan) 
 n oldfls s oldfls=$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 s:$d(flifespan) ^%SYS("JOURNAL","LIFESPAN","FILE")=flifespan
 s:$d(glifespan) ^%SYS("JOURNAL","LIFESPAN")=glifespan
 q oldfls
Time(s) N h,m,a S a=" am",h=s\3600,m=s\60#60 S:h>11 a=" pm",h=h-12 S:'h h=12
 Q ($J(h,2)_":"_$E(100+m,2,3)_a)                 
 ;********************************************************************
 ; $$OPENJRN^JRNUTIL(JRNFILE)  : Open a journal file
 ;   
 ;   Input: - name of the file to be opened.
 ;
 ;            Each process can open multiple files at a time, but each
 ;            file can be open by just one process at a time.
 ;            A local array %JFILE(file) keeps track of a process's 
 ;            open files. When a process opens a file, to prevent other
 ;            from opening it, a lock on ^%JOURNAL(file) is made.
 ;            When the process closes the file, this lock is removed.
 ;
 ;   Output:  -8   ( file is the current journal file )
 ;            -7   ( cannot open the file )
 ;            -6   ( file locked by another user )
 ;             1   ( success )
 ;********************************************************************
OPENJRN(JRNFILE) ; open a journal file for exclusive access 
 S $ZT="ERR^"_$ZN
 N FILE,FD,Y,CUR
 i ($zversion(1)=1) S FILE=$ZU(12,JRNFILE)
 i '($zversion(1)=1) S FILE=JRNFILE
 ;
 I $D(%JFILE(FILE)) Q "-14,Journal file is already open"  ;Already opened by caller
 ;
 L +^%JOURNAL(FILE):1 I '$T Q "-6,Journal file open by other user"  
 S FD=$zu(78,5,FILE,0)          ;open it
 I FD<0 L -^%JOURNAL(FILE) Q "-7,Unable to open journal file"
 S %JFILE(FILE)=FD    ;Set your local document
 Q 1
 ;********************************************************************
 ; $$CLOSEJRN^JRNUTIL(JRNFILE) : Close a journal file
 ;
 ;   Input: - name of the journal file to be closed
 ;
 ;   Output:  -15   ( unknown error )
 ;             -9   ( file has not been opened )
 ;              1   ( success )
 ;********************************************************************
CLOSEJRN(JRNFILE) ; close a journal file
 S $ZT="ERR^"_$ZN
 N FILE,X,FD
 i ($zversion(1)=1) S FILE=$ZU(12,JRNFILE)
 i '($zversion(1)=1) S FILE=JRNFILE
 ;
 I '$D(%JFILE(FILE)) Q "-9,Journal file has not been opened"  ; You haven't opened this file
 ;
 S FD=%JFILE(FILE)
 S X=$zu(78,7,FD)
 I X<0 Q "-15,Unsuccessful operation"
 ; 
 K %JFILE(FILE)
 L -^%JOURNAL(FILE)
 I $G(%JFILE)=FILE S %JFILE=""
 Q 1
 ;********************************************************************
 ; $$USEJRN^JRNUTIL(JRNFILE) :  to use an already opened journal file
 ;
 ;   Input: - name of the file
 ;    
 ;   Output:  -15    ( unknown error )
 ;             -9    ( file has not been opened )
 ;              1    ( success )  which in this case:
 ;              local variable %JFILE is set to this file name
 ;********************************************************************
USEJRN(JRNFILE)  ;set JRNFILE to be used for next read/delete journal records 
 s $ZT="ERR^"_$ZN
 N FILE,X,FD
 i ($zversion(1)=1) S FILE=$ZU(12,JRNFILE)
 i '($zversion(1)=1) S FILE=JRNFILE
 ;
 I '$D(%JFILE(FILE)) Q "-9,Journal file has not been opened"    ;Not open
 ;
 S FD=%JFILE(FILE)
 S X=$zu(78,6,FD) I X>-1 S %JFILE=FILE Q 1
 Q "-15,Unsuccessful operation"
 ;*********************************************************************
 ; $$JRNSWCH^JRNUTIL(newdir) :  switch journalling (to a new directory)  
 ;   Input: - newdir, new directory into which journal is written
 ;            newdir="": switch journalling in the same directory
 ;   Output:  -5  ( journalling is not active now )
 ;            -3  ( unable to create journal file )
 ;            -2  ( JRNSWCH currently in use )
 ;            -1  ( cannot cease updates )
 ;             1  ( success )
 ;*********************************************************************
JRNSWCH(newdir,reason) ; switch journalling to new directory newdir
 S $ZT="ERRSWCH^"_$ZN
 s reason=$g(reason,1)
 i $g(newdir)="" {
   s Status=##class(%SYS.Journal.System).RollToNextFile(reason)
   i Status q 1
   s errmsg=$System.Status.GetErrorText(Status)
   i $System.Status.GetErrorCodes(Status)'=1142 q -99_","_errmsg
   i $p(errmsg,":",2)[$get(^%qCacheMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1818997795"),"Journal disabled") q "-5,Journaling not enabled"
   i $p(errmsg,":",2)[$get(^%qCacheMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2297478059"),"Another journal switch in progress") q "-2,Journal file being switched by another job"
   q -99_","_errmsg
 }
 n switched,err,msg
 s switched=$$INT^JRNSWTCH(newdir,"",.err,/*io*/,/*maxsiz*/,/*jrnall*/,/*chkshdw*/,reason)
 q:switched 1
 s msg=$p(err,",",2,$l(err,",")),err=$p(err,",")
 q $s(err=-3:"-5,Journaling not enabled",err=-2:"-2,Journal file being switched by another job",err=-4:+"-17,Invalid journal directory name"_","_msg,1:-99_","_msg)        
ERRSWCH ;
 s $zt=""
 q $ze
 ;**************************************************************
ERR S $ZT="" Q $ZE 
NXTMIRJRN(jrnfile,mirname,err) ;
 n jrninfo,filecnt,nextjrn,status
 s jrninfo=$zu(78,22,jrnfile,13)
 i jrninfo'>0 {
   s err=jrnfile_$s('jrninfo:" does not exist",1:" is not a journal file")
   q ""
 }
 s filecnt=$p(jrninfo,",",2)+1
 s nextjrn=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
 i nextjrn<0 {
   s err=nextjrn_",Error searching mirror journal log "_mirname
   q ""
 }
 q $p(nextjrn,",",2)
NEXTJRN1(fd,mgdir) 
 ;mgdir = where to find journal history for this system.
 ;        normally omitted except for clustered systems
 s $zt="etNEXTJRN"
 n err,nextfd
 i '$d(mgdir) s mgdir=$ZU(12)
 s err=$$NEXTJRN^JRNUTIL2(fd,.nextfd,1,mgdir)
 i +err>0 q nextfd
 d msglog("NEXTJRN: "_err_","_fd_","_$g(nextfd)_","_mgdir)
 q ""
NEXTJRN0(fd,mgdir,usejrnloginfo,rc,mironly,mirname="") ;
 i ($zversion(1)=2) s fd=$zu(12,fd)
 ;mgdir = where to find journal history for this system.
 ;        normally omitted except for clustered systems
 s $zt="etNEXTJRN"
 n err,nextfd
 if $ZBITGET($ZVERSION(0),46) {
 	 s nextfd=$zu(78,22,fd,2) ;
	 if +nextfd=2 {
	    s nextfd=$p(nextfd,",",2)
	    ;nextfd might be "" if there's no next file, that's ok
	    s rc="1,"_nextfd
	    quit nextfd
	 }
	 if +nextfd=0 {
		 s rc="-1,"_fd_" does not exist"
	 } elseif +nextfd=-1 {
		 s rc="-1,"_fd_" is not a journal file"
	 } else {
		 s rc="-1,Unknown error code: "_nextfd_" for file "_fd
	 }
	 quit ""  ;not found
}
 s mironly=+$g(mironly)
 if 'mironly,(+$P($ZU(78,22,fd,13),",",2)) {
	 s nextfd=$zu(78,22,fd,2) ;
	 if +nextfd=2 {
	    s nextfd=$p(nextfd,",",2)
	    if nextfd'="" {
		    s rc="1,"_nextfd
		    quit nextfd
	    }
	 }
	 s nextfd=$$NextJournalFromJournalLog(fd,.rc)
	 if +rc<0 d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) 
	 quit nextfd  ;could be "" if no next file or the name of the file we found
 }
 i +$g(usejrnloginfo) d  q nextfd
 . s rc=$$query^JRNINFO(,"JRNNEXT,"_fd,)
 . i +rc<0 d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) s nextfd="" q
 . s nextfd=$p(rc,",",2,$l(rc))
 i '$D(mgdir) s mgdir=$ZU(12)
 s rc=$ZU(78,81,fd)
 if 'mironly,rc>-1 s nextfd=rc quit nextfd
 s rc=$$NEXTJRN^JRNUTIL2(fd,.nextfd,0,mgdir,mironly,mirname)
 n prevnextfd 
 i rc>0,nextfd]"" s prevnextfd=$P($zu(78,22,nextfd,1),",",2) i prevnextfd]"",($zversion(1)=2) s prevnextfd=$zu(12,prevnextfd)
 i +rc>0 {
   i nextfd]"",prevnextfd]"",prevnextfd'=fd,'mironly {
     s rc="-98,'"_nextfd_"' appears to be the next file of '"_fd_"' but contains a pointer to a different previous file from '"_prevnextfd_"' and thus couldn't be the next file"
     d msglog("NEXTJRN: "_rc)
     q ""
   }
   q nextfd
 }
 s err=$$ERNXPVJRN^JRNUTIL2(rc,fd,1) ;error message translated from error code
 s rc=$s(rc:+rc,1:-99)_","_err
 d msglog("NEXTJRN: "_rc_","_$g(nextfd)_","_mgdir)
 q ""
etNEXTJRN 
 s $zt=""
 d msglog("Error: "_$ze)
 q ""
msglog(msg,severity)
 s severity=$G(severity,1) ;defaults to 1 if not specified
 d $zu(9,"",msg,(severity>0),severity) q
loginfo(jrnfname) ;
 q
loginfo1(jrnfname) ;
 q
loginfo2(jrnfname) ;
 q
nettranfile(fcnt) ;
 n fc,sys,dmn
 s fcnt=$g(fcnt,2**32),sys="" f  s sys=$O(^NET("TPLOG",sys)) q:sys=""  d
 . s dmn="" f  s dmn=$O(^NET("TPLOG",sys,dmn)) q:dmn=""  d
 . . s fc=$p(^NET("TPLOG",sys,dmn),"^",2) i fc<fcnt s fcnt=fc
 q fcnt
OldestOpenTransTime() public {
 s $zt="exit"
 s wijjrninfo=$zu(78,21)
 s jrnfile=$p(wijjrninfo,",",2)
 s jrnfcnt=$p(wijjrninfo,",",3)
 s tranfcnt=$p(wijjrninfo,",",4)
 s tranindx=$p(wijjrninfo,",",5)
 i jrnfile="" q -4 ;journaling is off or data is unavailable
 s tranfile=jrnfile
 i tranfcnt<jrnfcnt {
   s fcnt=jrnfcnt f  {
     s prevfile=$P($zu(78,22,tranfile,1),",",2)
     i $ZU(78,22,prevfile)'=1 q 
     s tranfile=prevfile
     i $i(fcnt,-1)=tranfcnt q
   }
   i tranfcnt<fcnt q -2 ;or return the creation time of tranfile??
 }
 s dev=$zu(78,5,tranfile,0) i dev<0 q -3 ;shouldn't happen
 d $zu(78,6,dev)
 s rc=$zu(78,24,tranindx)
exit s $zt="" i $ze'="" s rc=$$Error^%apiOBJ(5002,$ze)
 i $g(dev)'="",dev'<0 d $zu(78,7,dev)
 q $g(rc) 
}
NextJournalFromJournalLog(fd,rc) PUBLIC {								
 ;rc is passed by reference and returns:
 ;    <status>,<text>
 ;    where <status>: 1 = success, <text> = next journal file name (could be "" if no next file)
 ;                   <0 = failed, <text> = error message
 ;    returns "" if no next file or error
 ;            <name> = name of next journal file
	 s nextfd=$ZU(78,81,fd)
	 if nextfd=-2 {
		s rc="-2,Journal file "_fd_" not found in journal log"
        d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) 
        q "" 
	 }
	 if nextfd=-1 {
		s rc="-1,Error locating journal file "_fd_" in journal log"
        d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) 
        q "" 
	 }
	 s rc="1,"_nextfd
	 quit nextfd  ;could be "" if no next file or the name of the file we found
}
CheckCurJrnfile() PUBLIC {
	/*  CheckCurJrnfile:
	       Called from %MONAPP as part of checking whether the
	       current journal file has been deleted. If so we switch
	       to a new journal file and hope that no one needs to open
	       the deleted file for something such as transaction rollback.
	     Returns 
           0 - everything was ok (including journaling is not enabled)
           1 - Problem detected, switched to a new journal file
           2 - Problem detected, failed to switch to a new journal file
 	*/
	s $zt="err"	
	s curfile=$zu(78,3)
	if curfile="" {
		quit 0
	}
	if '$p($zu(78,22),"^") {
		; Journaling isn't enabled, nothing to do
		quit 0
	}
tryAgain ;	
	s exists=$ZU(140,4,curfile)
	if exists=0 {
		quit 0  ;file exists, we're done
	}
	if '$p($zu(78,22),"^") {
		quit 0  ;success, journaling is no longer running
	}
	; Check to make sure that the current file is the
	; same as it was before
	s file=$zu(78,3)
	if file'=curfile {
		s curfile=file
		goto tryAgain
	}
	d $zu(9,"","Missing current journal file: "_file_" - Rolling to new file",1 /* broadcast and log message*/,2  /* Severe error */)
	s switched=##class(%SYS.Journal.System).RollToNextFile(12,.newfile)
	i ('switched) {
		s err=$System.Status.GetErrorText(switched)
		d $zu(9,"","Failed to switch journaling to new file: "_err,1 /* broadcast and log message*/,1  /* Warning */)
		quit 2  ; failed to switch to a new file
	}
	quit 1
err ;
	s $zt=""
	d $zu(9,"","Journal file monitor logged error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 2  ;Failed, assume we failed before we switched
}	
%swstat(sw,detail) ; Return the status of Switch (sw)...
 s sw=+$g(sw),detail=+$g(detail)
 i sw<0 q $s(detail:-1_$c(1)_"Illegal Switch",1:-1)
 n bit,i,info,job10
 s info=""
 s $zt="%swerr^"_$zn,$ze=""
 Set i=$System.Util.GetSwitch(sw)
 i +i=0 q $s(detail:0_$c(1)_"Switch "_sw_" is NOT set.",1:0)
 i sw=10 s job10=$p(i,",",2),info=" Set by JOB #: "_job10_"  ("_$v(-1,job10)_")"
 q $s(detail:1_$c(1)_"Switch "_sw_" IS set."_info,1:1)
%swerr   ; Some error occured when doing a Switch 10 Status...
 s $zt=""
 q $s(detail:-1_$c(1)_$ze,1:-1)
%swset(sw,val,detail) ; Set Switch (sw) to (val - {0,1})...
 s sw=+$g(sw),val=+$g(val),detail=+$g(detail)
 i sw<0 q $s(detail:-1_$c(1)_"Illegal Switch",1:-1)
 i val'=0,val'=1 q $s(detail:-1_$c(1)_"Illegal Switch Value",1:-1)
 s $zt="%swseter^"_$zn,$ze=""
 If +$System.Util.GetSwitch(sw)=val q 1
 Do $System.Util.SetSwitch(sw,val)  ;Also maintains job # for job 10
 If +$System.Util.GetSwitch(sw)=val q 1
 q 0
%swseter ; Some error occured when Setting Switch (sw) to (val)...
 s $zt=""
 q $s(detail:-1_$c(1)_$ze,1:-1)
 ; BITWISE.INC, DPB139 07/09/93
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 i ($zversion(1)=1) d
 . n x
 . s x=$$ChkDirVALID(dir)
 . i x'="" s dir=x
 i '($zversion(1)=1) Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))
 i '($zversion(1)=1) s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 i ($zversion(1)=1) d  q dir
 . n x
 . s x=$$ChkDirVALID(dir)
 . i x'="" s dir=x
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 i ($zversion(1)=1) S $E(d1,$L(d1))="."_d2_"]"
 i '($zversion(1)=1) S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 i ($zversion(1)=1) q:$$ChkDirVALID(dir)="" 1  ; dir is invalid, return failure
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
%msub() New x Set x=$I(^mtemp) Kill ^mtemp(x) Quit x