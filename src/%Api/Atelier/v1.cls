/// %Api.Atelier.v1 provides version 1 APIs for Atelier
Class %Api.Atelier.v1 Extends %Atelier.REST
{

XData UrlMap [ XMLNamespace = "http://www.intersystems.com/urlmap" ]
{
<Routes>

<!-- Run the debugger -->
<Route Url="/%SYS/debug"                        Method="GET" Call="RunDebugger"/>

<!-- Get a list of running jobs -->
<Route Url="/%SYS/jobs"                         Method="GET" Call="GetJobs"/>

<!-- Api for delivering meta data -->
<Route Url="/%SYS/metadata/:database"           Method="GET" Call="GetMetaData"/>

<!-- Get a list of defined csp apps -->
<Route Url="/%SYS/cspapps"                      Method="GET" Call="GetCSPApps"/>

<!-- Get a list of csp apps for a namespace -->
<Route Url="/%SYS/cspapps/:namespace"           Method="GET" Call="GetCSPApps"/>

<!-- Return informations about a specific namespace -->
<Route Url="/:namespace"                        Method="GET" Call="GetNamespace"/>

<!-- Apis to retrieve document meta data -->
<Route Url="/:namespace/docnames"               Method="GET"    Call="GetDocNames"/>
<Route Url="/:namespace/docnames/:cat"          Method="GET"    Call="GetDocNames"/>
<Route Url="/:namespace/docnames/:cat/:type"    Method="GET"    Call="GetDocNames"/>
 
<Route Url="/:namespace/modified/:type"         Method="POST"   Call="GetModifiedDocNames"/>

<!-- Apis to retrieve,save and delete individual documents -->
<Route Url="/:namespace/doc/(.*)"               Method="PUT"    Call="PutDoc"/> 
<Route Url="/:namespace/doc/(.*)"               Method="GET"    Call="GetDoc"/>
<Route Url="/:namespace/doc/(.*)"               Method="DELETE" Call="DeleteDoc"/>
<Route Url="/:namespace/doc/(.*)"               Method="HEAD"   Call="HeadDoc"/>

<!-- Apis to retrieve and delete list of documents -->
<Route Url="/:namespace/docs"                   Method="POST"   Call="GetDocs"/>
<Route Url="/:namespace/docs"                   Method="DELETE" Call="DeleteDocs"/>

<!-- Apis to compile documents -->
<Route Url="/:namespace/action/compile"         Method="POST"   Call="Compile"/>

<!-- index one or more classes -->
<Route Url="/:namespace/action/index"           Method="POST"   Call="Index"/>

<!-- run a query -->
<Route Url="/:namespace/action/query"           Method="POST"   Call="Query"/>

<!-- Apis to support long-running requests -->
<Route Url="/:namespace/work"                   Method="POST"   Call="QueueAsync"/>
<Route Url="/:namespace/work/:id"               Method="GET"    Call="PollAsync"/>
<Route Url="/:namespace/work/:id"               Method="DELETE" Call="CancelAsync"/>

<!-- Ensemble support -->
<Route Url="/:namespace/ens/classes/:type"      Method="GET" Call="GetEnsClassType"/>
<Route Url="/:namespace/ens/adapter/:name"      Method="GET" Call="GetAdpInputOutputClass"/>

<!-- Apis for conversion (Will Be Deprecated: Customers should not call from own code) -->
<Route Url="/:namespace/cvt/doc/xml"            Method="POST"   Call="CvtClientDocToXml"/>
<Route Url="/:namespace/cvt/xml/doc"            Method="POST"   Call="CvtXmlToClientDoc"/>

</Routes>
}

/// This method returns the text for the named document and namespace.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 304 if the document has not been modified (see https://en.wikipedia.org/wiki/HTTP_ETag)
/// <br/>HTTP 400 if the named resource is not a valid document name
/// <br/>HTTP 404 if the document does not exist
/// <br/>HTTP 500 if an unxpected error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will contain a document object.
/// <br/>Errors pertaining to the document will be in the status property of the document object.
/// If source control hooks are enabled for the namespace any console output generated by the hook
/// will be captured and returned as an array of lines in the 'console' array.
/// <br/>
/// <br/>The result contains the name of the requested file, the database where it is stored, its
/// timestamp and category (CLS - class, RTN -routine, CSP - csp file, OTH - other), as well as
/// the document contents which are returned in an array. 
/// <br/>
/// <br/>For text files this will be an array of strings and the 'enc' json field will be set to false.
/// <br/>For binary files this will be an array of base64 encoded chunks and the 'enc' field will be set to true.
/// <br/>
/// <br/>The URL parameter ?binary=1 can be passed to force the document to be encoded as binary.
/// <br/>
/// <br/>The URL parameter ?storageOnly=1 can be passed to return only the storage portion of a class.
/// <br/>
/// <br/>If a 'soft' error occurs such as a 'document does not exist', additional information can be found in
/// the 'status' field of the result. Examples of other soft errors are 'file is locked' etc.
/// <br/>
/// <br/>Here is an example of the result of asking for %Activate.Enum.cls
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "name": "%Activate.Enum.cls",
///     "db": "CACHELIB",
///     "ts": "2016-01-04 14:00:04.000",
///     "cat": "CLS",
///     "status": "",
///     "enc": false,
///     "content": [
///       "/// This class is the superclass for all enumerated types generated from",
///       "/// a type library",
///       "Class %Activate.Enum Extends %Integer [ Not ProcedureBlock, System = 3 ]",
///       "{",
///       "",
///       "}",
///       ""
///     ]
///   }
/// }
/// </pre>
/// <br/>
/// <br/>and here is the result with ?binary=1
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "name": "%Activate.Enum.cls",
///     "db": "CACHELIB",
///     "ts": "2016-01-04 14:00:04.000",
///     "cat": "CLS",
///     "status": "",
///     "enc": true,
///     "content": [
///       "Ly8vIFRoaXMgY2xhc3MgaXMgdGhlIHN1cGVyY2xhc3MgZm9yIGFsbCBlbnVtZXJhdGVkIHR5cGVzIGdlbmVyYXRlZCBmcm9tCi8vLyBhIHR5cGUgbGlicmFyeQpDbGFzcyAlQWN0aXZhdGUuRW51bSBFeHRlbmRzICVJbnRlZ2VyIFsgTm90IFByb2NlZHVyZUJsb2NrLCBTeXN0ZW0gPSAzIF0KewoKfQo="
///     ]
///   }
/// }
/// </pre>
/// 
ClassMethod GetDoc(pNamespace As %String, pDocName As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tClientServerHash,tServerServerHash As %String = ""
    #dim tCookie,tTextArray As %String
    #dim tBinary As %Boolean = 0
    #dim tUpToDate As %Boolean 
    #dim tI,tFlags As %Integer
    #dim tMsgArray As %DynamicArray = []
    
    #dim %SourceControl As %Studio.SourceControl.Base
    
    Try {
        
        #; Capture output
        Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
        If $$$ISERR(tSC) Quit

        #; Validate
        If ##class(%Atelier.v1.Utils.General).ValidateDocName(pDocName,.tSC,,.tBinary) = 0 {
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        #; If force binary
        If +%request.Get("binary") Set tBinary=1
     
        #; Normalize
        Set pDocName=##class(%Atelier.v1.Utils.General).NormalizeDocName(pDocName)
        
        #; Exists?
        If '##class(%Atelier.v1.Utils.General).ExistsDoc(pDocName,.tSC) {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        #; Get the clients version of the server hash
        Set tClientServerHash=..GetClientServerHash()
        
        #; Now set the server hash (from the server)
        Set tServerServerHash=##class(%Atelier.v1.Utils.General).TS(pDocName,.tUpToDate)
     
        If tClientServerHash = tServerServerHash {
            
            If tServerServerHash = ""{
                Set %response.Status=..#HTTP404NOTFOUND
            }
            Else {
                Set %response.Status=..#HTTP304NOTMODIFIED
            }
            Quit
        }
     
        #; Check if storage only is required?
        Set tFlags=0 If +%request.Get("storageOnly") Set tFlags=32
         
        #; Kill any previously existing instance of source control class
        Kill %SourceControl

        #; Create the source control class (if any)
        Set tSC=..CreateSourceControlClass()
        If $$$ISERR(tSC) Quit

        #; Get the document text
        Set tSC=##class(%Atelier.v1.Utils.TextServices).GetTextAsArray(pDocName,tFlags,.tTextArray,tBinary)
        If $$$ISERR(tSC) {
           If $Piece($System.Status.GetErrorCodes(tSC),",")=5920 {
               #; Should report a 404
               Set %response.Status=..#HTTP404NOTFOUND
           }
           Quit
        } 
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; MUST close the redirect whatever happens
    If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
    #; Serve the status and text
    Quit ..ServeDoc(pDocName,tSC,tMsgArray,.tTextArray,tServerServerHash,.tUpToDate)
}

/// This method returns the text for the all the specified documents in the namespace.
/// <br/>A list of documents to be fetched is passed in the body of the http request.
/// <br/>The request body is simply a JSON array of names of documents you want to fetch [ "%Activate.Enum.cls", ... ]
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 415 if the we are not passed application/json as the content type
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be an array of document objects. Errors pertaining to a document
/// <br/>will be in the status property of each document object.
/// <br/>
/// <br/>See the 'GetDoc' description above for a detailed explanation of the individual fields returned.
/// <br/>This method does NOT support the storageOnly flag. Neither does it do ETAG checking (and therefore
/// <br/>will NOT return an HTTP 304 under any circumstances).
/// 
ClassMethod GetDocs(pNamespace As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    #dim tCookie,tRenderList As %String
    #dim tDocNameArray As %DynamicArray
    #dim tBinary As %Boolean
    #dim tResPart As %DynamicObject
    #dim tMsgArray As %DynamicArray = []
    
    #; Document atributes
    #dim tDB,tName,tTS,tCat As %String
    #dim tUpToDate As %Boolean 
    
    #dim tI As %Integer
    #dim tExistsStatus As %Status
    
    Try {
       
        #; Ensure we are only passed json
        If %request.ContentType'="application/json" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
            
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit    
        }
        
        #; Parse the content (JSON array)
        Try {
            Set tDocNameArray=##class(%DynamicArray).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit

        If 'tDocNameArray.%IsA("%DynamicArray") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        Try {
            
            #; Capture output
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
        
            #; Kill any previously existing instance of source control class
            Kill %SourceControl
            
            #; Create the source control class (if any)
            Set tSC=..CreateSourceControlClass()
            If $$$ISERR(tSC) Quit
            
            #; For each document
            For tI=0:1:tDocNameArray.%Size()-1 {
                
                #; Get the name
                Set tName=tDocNameArray.%Get(tI)
               
                #; Validate Name (hard error if not valid)
                If '##class(%Atelier.v1.Utils.General).ValidateDocName(tName,.tSC,.tCat,.tBinary) Quit
        
                #; If force binary
                If +%request.Get("binary") Set tBinary=1
                
                #; Normalize
                Set tName=##class(%Atelier.v1.Utils.General).NormalizeDocName(tName)
                
                #; Exists?
                If ##class(%Atelier.v1.Utils.General).ExistsDoc(tName,.tExistsStatus)
                If $$$ISERR(tExistsStatus) {
                    
                    #; If the document doesn't exist we don't know the
                    #; database or the timestamp (naturally)
                    Set (tDB,tTS,tUpToDate)=""
                    
                } else {
                   
                    #; Get the database
                    Set tDB=""
                    Set tSC=##class(%Atelier.v1.Utils.General).GetDbForDoc(tName,.tDB)
                    If $$$ISERR(tSC) Quit
                    
                    #; Get the timestamp
                    Set tTS=##class(%Atelier.v1.Utils.General).TS(tName,.tUpToDate)
                }
                      
                #; Add to the RenderList
                Set tRenderList(tName)=##class(%Atelier.v1.Utils.LazyDocument).%New(tName,tDB,tTS,tExistsStatus,tCat,tBinary,tUpToDate)
            }
        
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
        #; NOW check error status
        If $$$ISERR(tSC) Quit
            
        #; Create a collection of documents
        Set tResPart=##class(%Atelier.v1.Utils.General).CreateDocumentCollection(.tRenderList)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
        
    #; Render the response body
    Quit ..RenderResponseBody(tSC,tMsgArray,.tResPart)
}

/// This method returns the indices for the all the specified documents in the namespace.
/// <br/>A list of documents to be indexed is passed in the body of the http request.
/// <br/>The request body is simply a JSON array of names of documents you want to index [ "%Activate.Enum.cls", ... ]
/// <br/>
/// <br/>NOTE: Currently we only support the indexing of classes
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 415 if the we are not passed application/json as the content type
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be an array of index document objects. Errors pertaining to a document
/// <br/>will be in the status property of each document object. The index contains information relating
/// <br/>to the structure and documentation of documents on the server and will vary by the category to
/// <br/>which the document belongs. Below is an example for a class.
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": [
///       {
///         "name": "%Activate.GenericObject.cls",
///         "db": "CACHELIB",
///         "ts": "2016-01-04 14:00:04.000",
///         "gen": false,
///         "others": [
///           "%Activate.GenericObject.1.INT"
///         ],
///         "cat": "CLS",
///         "content": {
///           "desc": "This class provides functionality to create an ActiveX object, invoke its methods\nand Get/Set its properties by name.",
///           "depl": false,
///           "depr": false,
///           "final": false,
///           "hidden": false,
///           "super": [
///             "%Activate.IDispatch"
///           ],
///           "methods": [
///             {
///               "name": "CreateObject",
///               "desc": "This method is used to create a generic object given only its progid. If the object\ncannot be found an exception is thrown. The return value should be tested against\n$$$NULLOREF  in the usual manner to ensure that the object has been successfully\ncreated",
///               "depr": false,
///               "final": true,
///               "internal": false,
///               "private": false,
///               "scope": "class",
///               "returntype": "%Library.RegisteredObject",
///               "args": [
///                 {
///                   "name": "Progid",
///                   "type": "%Library.String"
///                 }
///               ]
///             },
///             {
///               "name": "GetObject",
///               "desc": "This method is used to create a generic object from a moniker. If the object\ncannot be found an exception is thrown. The return value should be tested against\n$$$NULLOREF  in the usual manner to ensure that the object has been successfully\ncreated.",
///               "depr": false,
///               "final": true,
///               "internal": false,
///               "private": false,
///               "scope": "class",
///               "returntype": "%Library.RegisteredObject",
///               "args": [
///                 {
///                   "name": "Moniker",
///                   "type": "%Library.String"
///                 }
///               ]
///             }
///           ],
///           "parameters": [],
///           "properties": []
///         },
///         "status": ""
///       }
///     ]
///   }
/// }
/// </pre>
ClassMethod Index(pNamespace As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie,tRenderList As %String
    #dim tDocNameArray As %DynamicArray
    #dim tResPart As %DynamicObject
    #dim tMsgArray As %DynamicArray = []
    
    #; Document atributes
    #dim tDB,tName,tTS,tGen,tOne,tOth,tTemp,tCat As %String = ""
    #dim tUpToDate As %Boolean
    
    #dim tI As %Integer
    #dim tDocStatus As %Status
    
    #dim tRoutineMgr As %RoutineMgr
    
    Try {
     
        #; Ensure we are only passed json
        If %request.ContentType'="application/json" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
            
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit    
        }

        #; Parse the content (JSON array)
        Try {
            Set tDocNameArray=##class(%DynamicArray).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit

        If 'tDocNameArray.%IsA("%DynamicArray") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        Try {
            
            #; Need an instance of routine mgr
            Set tRoutineMgr=##class(%RoutineMgr).%New()
             
            #; Capture output
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
        
            #; For each document
            For tI=0:1:tDocNameArray.%Size()-1 {
                
                #; Get the name
                Set tName=tDocNameArray.%Get(tI)
                
                #; We don't know the database or the timestamp yet
                Set (tDB,tTS,tUpToDate)="",tDocStatus=$$$OK
                    
                #; Validate Name (hard error if not valid)
                If ##class(%Atelier.v1.Utils.General).ValidateDocName(tName,.tDocStatus,.tCat) {
                
                    #; Normalize
                    Set tName=##class(%Atelier.v1.Utils.General).NormalizeDocName(tName)
                    
                    #; Exists?
                    If ##class(%Atelier.v1.Utils.General).ExistsDoc(tName,.tDocStatus) {
                       
                        #; Get the database
                        Set tDB=""
                        Set tSC=##class(%Atelier.v1.Utils.General).GetDbForDoc(tName,.tDB)
                        If $$$ISERR(tSC) Quit
                        
                        #; Get the timestamp
                        Set tTS=##class(%Atelier.v1.Utils.General).TS(tName,.tUpToDate)
                        
                        #; Get the generated flag
                        Set tGen=+tRoutineMgr.IsGenerated(tName)
                        
                        #; We will use an array to eliminate duplicates
                        Kill tTemp
                        
                        #; Get the 'others' array (both descendents and ancestors)
                        Set tOth=tRoutineMgr.GetOther($Piece(tName,".",1,*-1),$Piece(tName,".",*),1)
                        If tOth'="" {
                            For tOne=1:1:$Length(tOth,",") Set tTemp($Piece(tOth,",",tOne))=""
                        }
                        Set tOth=tRoutineMgr.GetOther($Piece(tName,".",1,*-1),$Piece(tName,".",*),-1)
                        If tOth'="" {
                            For tOne=1:1:$Length(tOth,",") Set tTemp($Piece(tOth,",",tOne))=""
                        }
                        
                        #; Must eliminate duplicates, reconstruct string
                        #; and normalize the type to lower case because that is what
                        #; all our other apis do
                        Set (tOth,tOne)="" For {
                            Set tOne=$Order(tTemp(tOne)) If tOne="" Quit
                            Set tOth=tOth_$Piece(tOne,".",1,*-1)_"."_$zcvt($Piece(tOne,".",*),"l")_","
                        }
                        
                        #; Remove final ','
                        If tOth'="" Set $Extract(tOth,$Length(tOth))=""
                    }
                }
                   
                #; Add to the RenderList
                Set tRenderList(tName)=##class(%Atelier.v1.Utils.LazyIndex).%New(tName,tDB,tTS,tDocStatus,tCat,tGen,tOth,tUpToDate)
            }
        
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
        
        #; NOW check error status
        If $$$ISERR(tSC) Quit
            
        #; Create a collection of documents
        Set tResPart=##class(%Atelier.v1.Utils.General).CreateDocumentCollection(.tRenderList)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; Render the response body
    Quit ..RenderResponseBody(tSC,tMsgArray,.tResPart)
}

/// This method returns the results of running the specified query in the specified namespace.
/// <br/>The request body is simply a JSON object which specifies the query
/// <br/>{
/// <br/>    "query":"call %studio.debugger_processlist()",
/// <br/>    "parameters" : []
/// <br/>}
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 415 if the we are not passed application/json as the content type
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be an array of  objects. Errors will be in the status property of each document object.
/// <br/>The objects contain information relating to each row returned by the query.
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": [
///     ]
///   }
/// }
/// </pre>
ClassMethod Query(pNamespace As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie,tValue,tParams As %String
    #dim tQuery,tResPart As %DynamicObject
    #dim tResult,tInnerResult As %SQL.StatementResult
    #dim tArray As %DynamicArray
    #dim tMsgArray As %DynamicArray = []
    #dim tIterator
    #dim tI As %Integer
    #dim tParamIter
    
    Try {
     
        #; Ensure we are only passed json
        If %request.ContentType'="application/json" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
            
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit    
        }
        
        #; Parse the query spec into a JSON object
        Try {
            Set tQuery=##class(%DynamicObject).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit

        If 'tQuery.%IsA("%DynamicObject") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        Try {
            
            #; Capture output
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
        
            #; Previously used document database; perhaps could again in the future
            #; to keep things simple. For now, some duplication of what it will do.
            Set tStmt=##class(%SQL.Statement).%New()
            If (tQuery.%GetTypeOf("parameters") = "array") {
                Set tParamIter = tQuery.parameters.%GetIterator()
                While tParamIter.%GetNext(,.tValue) {
                    Set tParams($i(tParams)) = tValue
                }
            }
            Set tSC=tStmt.%Prepare(tQuery.query)
            If $$$ISERR(tSC) Quit
            
            Set tResult=tStmt.%Execute(tParams...)
            
            Set tArray=[]
            
            If (tResult.%SQLCODE < 0) {
                Throw ##class(%Exception.SQL).CreateFromSQLCODE(tResult.%SQLCODE,tResult.%Message)
            }
            
            If (tResult.%StatementType = 1) {
                #; SELECT ...
                Set tSC = ..AppendResultSet(tArray,tResult)
            } ElseIf (tResult.%StatementType = 45) {
                #; CALL ...
                Set tInnerResult=tResult.%NextResult()
                While (tInnerResult '= "") {
                    Set tSC = ..AppendResultSet(tArray,tInnerResult)
                    If $$$ISERR(tSC) Quit
                    Set tInnerResult=tResult.%NextResult()
                }
            }
            If $$$ISERR(tSC) Quit
            
            Set tResPart={},tResPart.content=tArray
        
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; Render the response body
    Quit ..RenderResponseBody(tSC,tMsgArray,.tResPart)
}

/// Helper method for Query
/// Appends result set (%SQL.StatementResult) to an array.
/// Largely copied from %DataModel.Document.Server.SQL.Query
ClassMethod AppendResultSet(pArray As %DynamicArray, pResult As %SQL.StatementResult) As %Status [ Internal, Private ]
{
    #dim tSC As %Status
    #dim e,setException As %EXception.AbstractException
    
    #dim tRSMD As %SQL.StatementMetadata
    #dim tColObj As %SQL.StatementColumn
    #dim tRow,tJSONValue As %DynamicObject
    #dim tColumns,tCellVal
    #dim tCol As %Integer
    
    Set tSC = $$$OK
    Try {
        #; Get statement metadata
        #; From %DataModel.Document.Server.SQL.Query:$fromResultSet
        #; See that method for more information on datatype numbers.
        Set tRSMD=pResult.%GetMetadata()
        Set tColumns=tRSMD.columns.Count()
        For tCol=1:1:tColumns {
            Set tColObj = tRSMD.columns.GetAt(tCol)
            Set tColumns(tCol) = tColObj.colName
            
            //All date/time types are formatted as strings.
            Set tColumns(tCol,1) = $Case(tColObj.clientType,
                2   : "datetime",
                3   : "number",
                4   : "oref",
                5   : "number",
                14  : "number",
                15  : "number",
                16  : "boolean",
                18  : "number",
                21  : "number",
                    : "string"
            )
        }
        
        While pResult.%Next(.tSC) {
            If $$$ISERR(tSC) Quit
            
            Set tRow = {}
            For tCol=1:1:tColumns {
                Set tCellVal = pResult.%GetData(tCol)
                If (tCellVal '= "") && (tColumns(tCol,1) = "string") && ($Find("{[",$Extract(tCellVal))) {
                    Set tJSONValue = ##class(%DynamicAbstractObject).%FromJSON(tCellVal)
                    If $IsObject(tJSONValue) {
                        Do tRow.%Set(tColumns(tCol),tJSONValue)
                    } Else {
                        Do tRow.%Set(tColumns(tCol),tCellVal,"string")
                    }
                } Else {
                    Try {
                        Do tRow.%Set(tColumns(tCol),tCellVal,tColumns(tCol,1))
                    } Catch setException {
                        If setException.Name = "<ILLEGAL VALUE>" {
                            Do tRow.%Set(tColumns(tCol),tCellVal,"string")
                        } Else {
                            Throw setException
                        }
                    }
                }
            }
                            
            Do pArray.%Push(tRow)
        }
    } Catch (e) {
        Set tSC = e.AsStatus()
    }
    Quit tSC
}

/// This method returns the HttpHeader for the named document and namespace.
/// <br/>This information primarily contains the timestamp and can be used to detect
/// <br/>discrepancies between server and client version
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the resource name is an invalid document name
/// <br/>HTTP 404 if the resource is not found
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// 
ClassMethod HeadDoc(pNamespace As %String, pDocName As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie,tHash,tTextArray As %String
    #dim tI As %Integer
    
    Try {

        #; Capture output (we don't care about this in a head call)
        Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
        If $$$ISERR(tSC) Quit
            
        #; Validate
        If ##class(%Atelier.v1.Utils.General).ValidateDocName(pDocName,.tSC) = 0 {
            Set %response.Status=..#HTTP400BADREQUEST,tSC=$$$OK
            Quit
        }
        
        #; Normalize
        Set pDocName=##class(%Atelier.v1.Utils.General).NormalizeDocName(pDocName)
        
        #; Exists?
        If '##class(%Atelier.v1.Utils.General).ExistsDoc(pDocName) {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        #; Get the latest timestamp for hash
        Set tHash=##class(%Atelier.v1.Utils.General).TS(pDocName)
        
        #; Set the header
        Do ..SetClientServerHash(tHash)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; MUST close the redirect whatever happens
    If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie)

    Quit tSC
}

/// This method saves the supplied document
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 201 if created
/// <br/>HTTP 400 if the resource name is an invalid document name
/// <br/>HTTP 404 if the resource is not found
/// <br/>HTTP 409 if a conflict between server and client versions is detected
/// <br/>HTTP 415 if not passed text/plain as content type
/// <br/>HTTP 425 if the document is locked and cannot be written to
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be a document object.
/// <br/>Errors pertaining to the document will be in the status property of the document object.
/// <br/>
/// <br/>The URL parameter ?ignoreConflict=1 can be passed to bypass ETAG checking (see reference
/// <br/>above in 'GetDoc') and force the document to be written on the server.
/// <br/>
/// <br/>Note that if the text on the server is changed during the save process (for example
/// <br/>by a source control hook) the new text will be returned in the content array
/// <br/>of the returned document.
/// <br/>
/// <br/>Here is an example of a PUT for the document xyz.mac
/// <br/>
/// <pre>
/// {
///  "enc": false,
///  "content": [
///    "ROUTINE xyz",
///    "xyz ;",
///    "   w \"hello\""
///    ]
/// }
/// </pre>
/// <br/>
/// <br/>and the corresponding response :-
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [
///   ],
///   "result": {
///     "name": "xyz.mac",
///     "db": "CACHESYS",
///     "ts": "2016-01-12 17:18:29.332",
///     "cat": "RTN",
///     "status": "",
///     "enc": false,
///     "content": []
///   }
/// }
/// </pre>
ClassMethod PutDoc(pNamespace As %String, pDocName As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie,tKeywords,tLines,tName,tTextArray,tCategory As %String
    #dim tMsgArray As %DynamicArray = []
    
    #dim %SourceControl As %Studio.SourceControl.Base

    #dim tJsonObj As %DynamicObject
    #dim tJsonArray As %DynamicArray
    #dim tBinary,tEnc As %Boolean
    #dim tUpToDate As %Boolean 
    #dim tI As %Integer = 0
    #dim tExists As %Boolean = 0
    #dim tFlags As %Integer = 0
    #dim tLocked As %Integer = -1
    #dim tResponseStatus As %String
    
    #; Hashes
    #dim tPreSaveHash,tPostSaveHash,tClientServerHash,tServerServerHash As %String = ""
    
    #; Assume the worst
    Set tResponseStatus=..#HTTP500INTERNALSERVERERROR
    
    Try {

        Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
        If $$$ISERR(tSC) Quit
            
        #; Validate the type of content
        If %request.ContentType'="application/json" {
            Set tResponseStatus=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
            
        #; Need to make sure that we have some content
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set tResponseStatus=..#HTTP400BADREQUEST
            Quit
        }
        
        #; Validate
        If ##class(%Atelier.v1.Utils.General).ValidateDocName(pDocName,.tSC,.tCategory,.tBinary)=0 {
            Set tResponseStatus=..#HTTP400BADREQUEST
            Quit
        }
        
        #; Ensure we are at the begining of the stream and read in the document
        Set tSC=%request.Content.Rewind()
        If $$$ISERR(tSC) Quit
        
        Try {
            Set tJsonObj=##class(%DynamicObject).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set tResponseStatus=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit
        
        If 'tJsonObj.%IsA("%DynamicObject") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set tResponseStatus=..#HTTP400BADREQUEST
            Quit
        }
        
        Set tEnc=tJsonObj.enc
        If (tEnc="false")||(tEnc=0) {
            Set tBinary=0
        } ElseIf (tEnc="true")||(tEnc=1) {
            Set tBinary=1
        } Else {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set tResponseStatus=..#HTTP400BADREQUEST
            Quit
        }
        
        Set tJsonArray=tJsonObj.content
        If '$IsObject(tJsonArray) || 'tJsonArray.%IsA("%DynamicArray") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set tResponseStatus=..#HTTP400BADREQUEST
            Quit
        }
        
        For tI=1:1:tJsonArray.%Size() Set tTextArray(tI)=tJsonArray.%Get(tI-1)
        If $Data(tTextArray) Set tTextArray(0)=tI
        Kill tJsonArray
    
        #; Optimistically set HTTP code according to pre-existing document
        If ##class(%Atelier.v1.Utils.General).ExistsDoc(pDocName) {
            
            #; Set the exists flag
            Set tExists=1
            
            #; If it already exists then we are replacing the contents
            Set tResponseStatus=..#HTTP200OK
            
        } else {
            
            #; Otherwise we are creating the contents
            Set tResponseStatus=..#HTTP201CREATED
        }
    
        #; Lock the item
        Set tSC=##class(%RoutineMgr).LockItem(pDocName)
        
        If $$$ISERR(tSC) {
            #; Must check for actually being locked
            If $Piece($System.Status.GetErrorCodes(tSC),",")=5864 {
                Set tResponseStatus=..#HTTP423LOCKED
                Quit
            } ElseIf tCategory="OTH" &&
                    (tSC["<METHOD DOES NOT EXIST>") &&
                    (tSC["*Lock,") {
                #; User type might not support Lock
                Set tLocked=0
            } Else {
                
                #; Need to mark as a bad request
                Set tResponseStatus=..#HTTP400BADREQUEST
                Quit
            }
        }
        
        #; Note the document has been locked, unless there was no Lock method
        Set:tLocked<0 tLocked=1
       
        Kill %SourceControl
        
        #; Create the source control class (if any)
        Set tSC=..CreateSourceControlClass()
        If $$$ISERR(tSC) Quit
        
        #; Indicate that we want to know about source modifications
        If $IsObject($Get(%SourceControl)) {
            Kill %SourceControl.Modified
            Set %SourceControl.Modified=1
        }
        
        #; Get the overwrite flag
        If +%request.Get("ignoreConflict") {
            
            #; Check if source control allows the save
            If $IsObject($Get(%SourceControl)) {
                Set tSC=..CheckSourceControlEdit(pDocName)
                If $$$ISERR(tSC) {
                    Set tResponseStatus=..#HTTP200OK
                    Quit
                }
            }
            
            Set tSC=##class(%Atelier.v1.Utils.TextServices).SetTextFromArray(.tTextArray,tFlags,pDocName,tCategory,tBinary)
            If $$$ISERR(tSC) {
                Set tResponseStatus=..#HTTP200OK
                Quit
            }
            
            #; Now get the updated server hash
            Set tServerServerHash=##class(%Atelier.v1.Utils.General).TS(pDocName,.tUpToDate)
            
        } else {
            
            #; Get the server hash (from the client)
            Set tClientServerHash=..GetClientServerHash()
            
            #; Now get the server hash (from the server)
            Set tServerServerHash=##class(%Atelier.v1.Utils.General).TS(pDocName,.tUpToDate)
            
            #; If the server document doesn't exist (could have been manually deleted)
            #; or the hashes match then the text can be saved
            If (tExists=0 || (tClientServerHash=tServerServerHash)) {
            
                #; Yes, we concur on the document we are replacing, save it
                
                #; But first check whether source control allows it
                If $IsObject($Get(%SourceControl)) {
                    Set tSC=..CheckSourceControlEdit(pDocName)
                    If $$$ISERR(tSC) {
                        Set tResponseStatus=..#HTTP200OK
                        Quit
                    }
                }
                
                Set tSC=##class(%Atelier.v1.Utils.TextServices).SetTextFromArray(.tTextArray,tFlags,pDocName,tCategory,tBinary)
                If $$$ISERR(tSC) {
                    #; We will give status OK because it was a valid request, but the
                    #; client will see the error condition in tSC.
                    Set tResponseStatus=..#HTTP200OK
                    Quit
                }
                
                #; Now get the updated server hash
                Set tServerServerHash=##class(%Atelier.v1.Utils.General).TS(pDocName,.tUpToDate)
                
            } else {
                
                #; Return a conflict HTTP status
                Set tResponseStatus=..#HTTP409CONFLICT
                
                #; Get the conflicted source
                Kill tTextArray
                Set tSC=##class(%Atelier.v1.Utils.TextServices).GetTextAsArray(pDocName,tFlags,.tTextArray,tBinary)
                
                Quit
            }
        }
        
        If $$$ISERR(tSC) Quit
        
        Set tExtensionContent = ""
        
        #; Only bother to add source control output if there's a source control class configured.
        If $IsObject($Get(%SourceControl)) {
            Set tExtensionContent = []
            If 'tExists {
                // User has created a new document and saved it (successfully) for the first time.
                // Fire both "User has created
                For tActionName = 1,7 {
                    Set tSC = ##class(%Atelier.v1.Utils.Extension).UserActionExecute(.tExtensionItem,1,tActionName,pDocName,"")
                    If $$$ISERR(tSC) Quit
                    If $IsObject(tExtensionItem) {
                        Do tExtensionContent.%Push(tExtensionItem)
                    }
                }
            }
            If $$$ISERR(tSC) Quit
        }
        
        #; Don't need the input any more
        Kill tTextArray
        
        #; Need to check the modified indicator
        #; Source control uses upper case extension
        If $IsObject($Get(%SourceControl)) &&
            $Get(%SourceControl.Modified($Piece(pDocName,".",1,*-1)_"."_$zcvt($Piece(pDocName,".",*),"U")))=1 {
            
            #; Source was modified by source control hook, need to return to client
            Set tSC=##class(%Atelier.v1.Utils.TextServices).GetTextAsArray(pDocName,tFlags,.tTextArray,tBinary)
            If $$$ISERR(tSC) {
                Quit
            }
            
            #; Need to get the updated timestamp too
            Set tServerServerHash=##class(%Atelier.v1.Utils.General).TS(pDocName,.tUpToDate)
            
        }
        
        If $IsObject($Get(%SourceControl)) {
            Kill %SourceControl.Modified
        }
        
        #; For a persistent class, always return the Storage definition. The user may have done
        #; some bad things that were corrected by the serialization. We can not determine if that
        #; happens, so always send it back so the client can sort it out.
        If tCategory="CLS",'$Data(tTextArray) {
            Set tSC=##class(%Atelier.v1.Utils.TextServices).GetTextAsArray(pDocName,32,.tTextArray)
            If $$$ISERR(tSC) Quit
            If $Get(tTextArray(0))>1 {
                Set tTextArray("flags")=1 ; text is Storage only
            } Else {
                #; The class has no Storage
                Kill tTextArray
            }
        }
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; No matter what happened we want to unlock here (if we locked)
    If tLocked>0 Do ##class(%RoutineMgr).LockItem(pDocName,0)
    
    Set %response.Status=tResponseStatus
    
    #; MUST close the redirect whatever happens
    If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
    #; Serve the doc
    Quit ..ServeDoc(pDocName,tSC,tMsgArray,.tTextArray,tServerServerHash,.tUpToDate,.tExtensionContent)
}

ClassMethod CheckSourceControlEdit(pName As %String) As %Status [ Internal ]
{
    #; code copied from %RoutineMgr.Lock()
    Set edit=0,isinsourcecontrol=0,ischeckedout=0,user="",name=##class(%Studio.SourceControl.Interface).normalizeName(pName)
    Set tmp=%SourceControl New %SourceControl
    If tmp.IsReadOnly(name) {
        Set tSC=$$$ERROR($$$RoutineSourceRO,name)
    } Else {
        Set tSC=tmp.GetStatus(name,.isinsourcecontrol,.edit,.ischeckedout,.user)
        If $$$ISOK(tSC),'edit Set tSC=##class(%RoutineMgr).ConstructEditError(name,isinsourcecontrol,ischeckedout,user)
    }
    Quit tSC
}

/// This method deletes the named document in the specified namespace
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the resource name is an invalid document name
/// <br/>HTTP 404 if the resource is not found
/// <br/>HTTP 423 if the resource is locked
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be a document object.
/// <br/>errors pertaining to the document will be in the status property of the document object
/// <br/>
/// <br/>Example Output :-
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [
///   ],
///   "result": {
///     "name": "xyz.mac",
///     "db": "CACHESYS",
///     "ts": "",
///     "cat": "RTN",
///     "status": "",
///     "enc": false,
///     "content": []
///   }
/// }
/// </pre>
ClassMethod DeleteDoc(pNamespace As %String, pDocName As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie As %String
    #dim tDocStatus As %Status = $$$OK
    #dim tLocked As %Boolean = 0
    #dim tMsgArray As %DynamicArray = []
    
    #dim %SourceControl As %Studio.SourceControl.Base
    
    Try {

        #; Validate
        If ##class(%Atelier.v1.Utils.General).ValidateDocName(pDocName,.tSC) = 0 {
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        #; Normalize
        Set pDocName=##class(%Atelier.v1.Utils.General).NormalizeDocName(pDocName)
        
        #; Perform the deletion (and capture output)
        Try {
            
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
            
            Kill %SourceControl
            
            Set tSC=..CreateSourceControlClass()
            If $$$ISERR(tSC) Quit
            
            #; If the document doesn't exist, just report it's not found
            If ##class(%Atelier.v1.Utils.General).ExistsDoc(pDocName)=0 {
                
                #; Doesn't exist
                Set %response.Status=..#HTTP404NOTFOUND
                Quit
            }
            
            #; Lock the item, no Source Control checks
            Set tSC=##class(%RoutineMgr).LockItem(pDocName,1,0)
            If $$$ISERR(tSC) {
                
                #; Must check for actually being locked
                If $Piece($System.Status.GetErrorCodes(tSC),",")=5864 {
                    Set %response.Status=..#HTTP423LOCKED
                    Set tSC=$$$OK
                }
                Quit
            }
            
            #; Note that the document is locked
            Set tLocked=1
            
            #; Error messages will be output and captured
            Set tDocStatus=##class(%RoutineMgr).Delete(pDocName)
        
            If $$$ISOK(tDocStatus) {
                // If the doc was actually deleted, notify the Studio extension.
                Set tSC = ##class(%Atelier.v1.Utils.Extension).UserActionExecute(.tExtensionContent,1,2,pDocName,"")
            }
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; MUST unlock if has been locked
    If tLocked Do ##class(%RoutineMgr).LockItem(pDocName,0)
    
    #; If there was an error
    If $$$ISERR(tSC) Quit tSC
    
    #; Serve the document
    Quit ..ServeDoc(pDocName,tDocStatus,tMsgArray,,,,.tExtensionContent)
}

/// This method deletes the list of named documents which is passed in the body of the http request.
/// <br/>as a JSON array [ "%Activate.Enum.cls", ... ]
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the posted data does not contain a JSON array
/// <br/>HTTP 415 if the we are not passed application/json as the content type
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be an array of document objects. Errors pertaining to a each document
/// <br/>will be in the status property of each document object. If the status is an empty string then 
/// <br/>the document was deleted sucessfully. Otherwise the document was NOT deleted. For deleted docs
/// <br/>the db entry will indicate from which database the doc was deleted.
/// <br/>
/// <br/>POSTED: ["xyz.mac","notexist.cls"]
/// <br/>
/// <br/>Result :-
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [
///   ],
///   "result": [
///     {
///       "name": "xyz.mac",
///       "db": "",
///       "status": ""
///     },
///     {
///       "name": "notexist.cls",
///       "db": "",
///       "status": "ERROR #5001: Document Does Not Exist: User.notexist.cls [zExistsDoc+3^%Atelier.v1.Utils.General.1:%SYS]"
///     }
///   ]
/// }
/// </pre>
ClassMethod DeleteDocs(pNamespace As %String) As %Status
{
    #dim tSC,tDeleteStatus As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie As %String
    #dim tDocNameArray As %DynamicArray
    #dim tObject As %DynamicObject
    
    #; Document atributes
    #dim tDB,tName As %String
    
    #dim tI As %Integer
    #dim tDocStatus As %Status
    #dim tMsgArray As %DynamicArray = []
    #dim tResult As %DynamicArray = []
    
    Try {
        
        #; Ensure we are only passed json
        If %request.ContentType'="application/json" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
            
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        #; Parse the content (JSON array)
        Try {
            Set tDocNameArray=##class(%DynamicArray).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit

        If 'tDocNameArray.%IsA("%DynamicArray") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        Try {
            
            #; Capture output
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
        
            Kill %SourceControl
                
            #; Create the source control class
            Set tSC=..CreateSourceControlClass()
            If $$$ISERR(tSC) Quit
            
            #; For each document
            For tI=0:1:tDocNameArray.%Size()-1 {
                
                #; Get the name
                Set tName=tDocNameArray.%Get(tI)
               
                #; Create an object for the document
                Set tObject = {}
                Set tObject.name=tName
                Set tDB=""
                
                Kill tExtensionContent
                
                #; If the name is valid
                If ##class(%Atelier.v1.Utils.General).ValidateDocName(tName,.tDocStatus) {
                    
                    #; Normalize
                    Set tName=##class(%Atelier.v1.Utils.General).NormalizeDocName(tName)
                    
                    #; If the document exists
                    If ##class(%Atelier.v1.Utils.General).ExistsDoc(tName,.tDocStatus) {
                    
                        Set tSC=##class(%Atelier.v1.Utils.General).GetDbForDoc(tName,.tDB)
                        If $$$ISERR(tSC) Quit
                        
                        #; Error messages will be output and capture
                        Set tDocStatus=##class(%RoutineMgr).Delete(tName)
        
                        If $$$ISOK(tDocStatus) {
                            // If the doc was actually deleted, notify the Studio extension.
                            Set tSC = ##class(%Atelier.v1.Utils.Extension).UserActionExecute(.tExtensionContent,1,2,tName,"")
                        }
                    }
                }
                
                #; Fill in the db (may not be known, if doc didn't exist)
                Set tObject.db=tDB
               
                If $$$ISERR(tDocStatus) {
                    Set tObject.status=$System.Status.GetOneErrorText(tDocStatus)
                } else {
                    Set tObject.status=""
                }
                
                If $IsObject($Get(tExtensionContent)) {
                    Set tObject.ext=tExtensionContent
                }
                
                #; And add it to the result
                Do tResult.%Push(tObject)
            }
        
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; Render the response body
    Quit ..RenderResponseBody(tSC,tMsgArray,tResult)
}

/// This method permits the compilation of more than one document at a time.
/// <br/>The method expects a content body to be encoded in JSON and contain an
/// <br/>array of items (document names) to be compiled.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the resource name is an invalid document name
/// <br/>HTTP 404 if the resource is not found
/// <br/>HTTP 423 if the document is locked
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be an array of document objects.
/// <br/>Errors pertaining to the document will be in the status property of the document object.
/// <br/>
/// <br/>The URL parameter 'flags' can be passed (default 'cuk') which will be passed to the compiler.
/// <br/>The URL parameter 'source' can be passed with a value of 0 if you don't want the source of the
/// <br/>compiled document to be returned.
/// <br/>
/// <br/>POSTED: ["Atelier.NewClass1.cls"]
/// <br/>
/// <br/>Example Output :-
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [
///     "Compilation started on 01/12/2016 17:44:00 with qualifiers 'cuk'",
///     "Compiling class Atelier.NewClass1",
///     "Compiling table Atelier.NewClass1",
///     "Compiling routine Atelier.NewClass1.1",
///     "Compilation finished successfully in 0.067s.",
///     ""
///   ],
///   "result": {
///     "content": [
///       {
///         "name": "Atelier.NewClass1.cls",
///         "status": "",
///         "content": [
///           "Storage Default",
///           "{",
///           "<Data name=\"NewClass1DefaultData\">",
///           "<Value name=\"1\">",
///           "<Value>%%CLASSNAME</Value>",
///           "</Value>",
///           "</Data>",
///           "<DataLocation>^Atelier.NewClass1D</DataLocation>",
///           "<DefaultData>NewClass1DefaultData</DefaultData>",
///           "<IdLocation>^Atelier.NewClass1D</IdLocation>",
///           "<IndexLocation>^Atelier.NewClass1I</IndexLocation>",
///           "<StreamLocation>^Atelier.NewClass1S</StreamLocation>",
///           "<Type>%Library.CacheStorage</Type>",
///           "}",
///           ""
///         ],
///         "db": "CACHESYS",
///         "ts": "2016-01-12 17:44:00.053",
///         "enc": false
///       }
///     ]
///   }
/// }
/// </pre>
ClassMethod Compile(pNamespace As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    #dim tDocNameArray,tMsgArray As %DynamicArray
    #dim tResult As %DynamicObject
    
    #dim tI As %Integer
    #dim tFlags,tGetSource,tCookie,tDocName,tItemArray As %String
    
    Set tMsgArray = []
    
    Try {

        #; Ensure we are only passed json
        If %request.ContentType'="application/json" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }

        #; Ensure that the request has content
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit    
        }

        #; Get any compilation flags
        Set tFlags=%request.Get("flags","cuk")
        If $E(tFlags)="""",$E(tFlags,*)="""" Set tFlags=$E(tFlags,2,*-1)
        
        #; See if modified source is requested
        Set tGetSource=+%request.Get("source",1)

        #; Parse the content (JSON array)
        Try {
            Set tDocNameArray=##class(%DynamicArray).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit

        If 'tDocNameArray.%IsA("%DynamicArray") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }

        For tI=0:1:tDocNameArray.%Size()-1 {
            Set tDocName=tDocNameArray.%Get(tI)
            Set tItemArray(tDocName)=""
        }

        Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
        If $$$ISERR(tSC) Quit

        Set tSC=##class(%Atelier.v1.Utils.General).Compile(.tItemArray,tFlags,tGetSource,.tResult)

    } Catch (e) {
        Set tSC=e.AsStatus()
    }

    #; MUST close the redirect whatever happens
    If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
    Set:'$Data(tResult) tResult = {}
    Quit ..RenderResponseBody(tSC,tMsgArray,tResult)
}

/// This method returns a list of document names. Cat and Type constrain the types of documents,
/// <br/>whilst the URL parameter 'generated' determines whether generated documents should be included 
/// <br/>and the 'filter' parameter provides a SQL filter that can be used to match the names.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Return content will be an array of document descriptors :-
/// <br/>
/// <pre>
/// {
///     "status": {
///         "errors": [],
///         "summary": ""
///     },
///     "console": [],
///     "result": {
///         "content": [{
///             "name": "%Activate.Enum.cls",
///             "cat": "CLS",
///             "ts": "2016-01-04 14:00:04.000",
///             "db": "CACHELIB",
///             "gen": false
///         }]
///     }
/// }
/// </pre>
ClassMethod GetDocNames(pNamespace As %String, pCat, pType)
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
   
    #dim tCat,tCls,tType,tlType,tCookie,tDB,tExt,tFilter,tFullName,tName,tTimeStamp As %String
    #dim tShowGenerated As %Boolean
    #dim tUpToDate As %Boolean 
    #dim tArray As %DynamicArray
    #dim tObject,tResult As %DynamicObject
    #dim tMsgArray As %DynamicArray = []
    #dim tRoutineMgr As %RoutineMgr
    #dim cspLoop As %Integer
    #dim cspArray,cspType,cspApp,document As %String
    #dim app1,app2 As %String
    #dim tI As %Integer

    Try {
        
        #; This is the array of results
        Set tArray = []
        
        If '$data(pCat) {
            #; Get everything
            Set pCat="*", pType="*"
        } Else {
            Set pCat=$zcvt(pCat,"U")
            If ",*,CLS,RTN,CSP,OTH,"'[(","_pCat_",") {
                Set %response.Status=..#HTTP400BADREQUEST
                Quit
            }
        }
        
        If '$data(pType) {
            Set pType="*"
        }
        
        If pCat="CLS" {
            If pType'="*" {
                Set %response.Status=..#HTTP400BADREQUEST
                Quit
            }
            Set pType="cls"
            
        } ElseIf pCat="RTN" {
            If pType="*" {
                Set pType="mac,int,inc,bas,mvi,mvb"
            } else {
                For tI=1:1:$length(pType,",") {
                    Set tType=$zcvt($piece(pType,",",tI),"l")
                    If ",mac,int,inc,bas,mvi,mvb,"'[(","_tType_",") {
                        Set %response.Status=..#HTTP400BADREQUEST
                        Set tI=0
                        Quit
                    }
                }
                Quit:tI=0
            }
            
        } ElseIf pCat="OTH" {
            Do StudioDocument^%SYS.cspServer2(.document)
            #; Let regular CSP searching find the javascript documents
            Kill document("%Studio.JavaScriptRoutine")
            #; Let Routines handle MVB documents
            Kill document("%MV.StudioRoutines")
            
            #; Collect the types
            Set tCls=""
            For  {
                Set tCls=$order(document(tCls)) Quit:tCls=""
                Set tType=""
                For {
                    Set tType=$order(document(tCls,tType)) Quit:tType=""
                    Set tType(tType)="", tlType($zcvt(tType,"l"))=""
                }
            }
            
            If pType="*" {
                Set pType="",tType=""
                For {
                    Set tType=$order(tType(tType)) Quit:tType=""
                    Set pType=pType_tType_","
                }
                Set $Extract(pType,*)=""
            } Else {
                For tI=1:1:$length(pType,",") {
                    If '$data(tlType($zcvt($piece(pType,",",tI),"l"))) {
                        #; Just remove an invalid type
                        Set pType=$piece(pType,",",1,tI-1)_","_$piece(pType,",",tI+1,*)
                    }
                }
                Set tI=1
                For  Set tI=$find(pType,",,",tI) Quit:tI=0  Set $extract(pType,tI-1)="", tI=tI-2
                Set:$extract(pType,*)="," pType=$extract(pType,1,*-1)
                Set:$extract(pType,1)="," pType=$extract(pType,2,*)
            }
        }
        
        #; Convert the raw type into a Query parameter
        If pType'="*" {
            For tI=1:1:$length(pType,",") {
                Set $piece(pType,",",tI) = "*."_$piece(pType,",",tI)
            }
        }
        
        If pCat="CSP" {
            
            #; Get a list of all the CSP applications for this namespace
            Do CSPAppList^%SYS.cspServer2(.cspArray)
        
            #; Was a specific cspapp specified?
            Set cspApp=%request.Get("app")
            
            #; See if the app belongs to this namespace
            If cspApp'="" {
                If '$Data(cspArray(cspApp)) {
                    Set %response.Status=..#HTTP404NOTFOUND
                    Quit
                }
                #; Set the query argument
                Set pType=cspApp_"/"_pType
            }
        }
        
        #; Capture any output
        Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
        If $$$ISERR(tSC) Quit
        
        #; Get parameters
        Set tFilter=%request.Get("filter")
        If tFilter'="" Set tFilter="Name Like '%"_tFilter_"%'"
        
        #; Include Generated?
        Set tShowGenerated=+%request.Get("generated")
        
        If pCat="CSP", cspApp="" {
            Set cspLoop=1, cspType=pType
            
            #; First we must filter out any applications that are a
            #; subset of another application. Otherwise those files
            #; will appear twice.
            Set app1=""
            For {
                Set app1=$Order(cspArray(app1)) Quit:app1=""
                Set app2=""
                For {
                    Set app2=$Order(cspArray(app2)) Quit:app2=""
                    If $Extract(app2,$Find(app2,app1))="/" Kill cspArray(app2)
                }
            }
            
            #; For each application, run the query to get all its files
            #; The application name is the "type" for the query
cspnext
            Set cspApp=$Order(cspArray(cspApp))
            If cspApp="" {
                Goto cspend
            }
            Set pType=cspApp_"/"_cspType
            
        } Else {
            Set cspLoop=0
        }
        
        #; We are using the StudioOpenDialog ResultSet for consistency
        Set tRS = ##class(%ResultSet).%New("%RoutineMgr:StudioOpenDialog")
        
        Set tSC=tRS.Prepare()
        If $$$ISERR(tSC) Quit
        
        #; These are parameters to the query
        #define Direction       1
        #define OrderBy         1 /* File name */
        #define Flat            1
    
        Set tSC=tRS.Execute(pType,$$$Direction,$$$OrderBy,1,$$$Flat,0,tShowGenerated,tFilter)
        If $$$ISERR(tSC) Quit
        
        #; Perform the fetch
        Try {

            Set tRoutineMgr=##class(%RoutineMgr).%New()
            
            While tRS.Next() {
                
                #; This is each object
                Set tObject = {}
                
                Set tFullName=tRS.Data("Name"), tExt=$Piece(tFullName,".",*)
                Set tName=$Piece(tFullName,".",1,*-1)
                Set tCat=..getDlgCat(tRS.Data("Type"))
                
                Set tObject.name=tFullName
                Set tObject.cat=tCat
                
                Set tTimeStamp=tRS.Data("Date")
                
                If tTimeStamp'="" {
                    If tTimeStamp'["." Set tTimeStamp=tTimeStamp_"."
                    Set $Piece(tTimeStamp,".",*)=$Extract($Piece(tTimeStamp,".",*)_"000",1,3)
                }
                        
                Set tObject.ts=tTimeStamp
                Do tRoutineMgr.TS(tObject.name,,.tUpToDate)
                Do tObject.%Set("upd",tUpToDate,"boolean")
                
                Set tDB="",tSC=##class(%Atelier.v1.Utils.General).GetDbForDoc(tObject.name,.tDB)
                If $$$ISERR(tSC) Quit
                
                Set tObject.db=tDB
                Do tObject.%Set("gen",+tRoutineMgr.IsGenerated(tObject.name),"boolean")
                
                Do tArray.%Push(tObject)
            }
            
        } Catch (e) {
            
            Set tSC=e.AsStatus()
        }
        
        If cspLoop,$$$ISOK(tSC) {
            Goto cspnext
        }
cspend
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; MUST close the redirect whatever happens
    If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
    Set tResult = {}, tResult.content = tArray
    
    Quit ..RenderResponseBody(tSC,tMsgArray,tResult)
}

/// This method converts a client Doc to the corresponding XML.
/// <br/>Note: This is NOT a public API and will be retired in a future version
/// <br/>Customers SHOULD NOT call this API from their own code
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the posted content is empty
/// <br/>HTTP 415 if content type is not application/json
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is XML.
/// 
ClassMethod CvtClientDocToXml(pNamespace As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie,tLines,tName,tTextArray,tErrorLog As %String
    #dim tGblSubscript,tKeywords As %String
    #dim tMsgArray As %DynamicArray = []
 
    #dim tI As %Integer = 0
    #dim tFlags As %Integer = 0
    #dim tXmlStream As %Stream = $$$NULLOREF
    
    #; Flag to indicate that the incoming document should not be stored
    #dim tTemporaryStoreFlagSet As %Boolean = 0
  
    #dim tDocName As %String = ""
    
    Try {
        
        #; Ensure we are only passed plain text
        If %request.ContentType'="text/plain" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
        
        #; Need to make sure that we have some content
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        #; Ensure we are at the begining of the stream and read in the document
        Set tSC=%request.Content.Rewind()
        If $$$ISERR(tSC) Quit
        
        #; Ensure that the terminator is newline
        Set %request.Content.LineTerminator=$Char(10)
        
        #; While data remains
        While '%request.Content.AtEnd {
            
            #; Read a line of text and place it in the document array
            Set tI=tI+1,tTextArray(tI)=%request.Content.ReadLine(,.tSC)
            If $$$ISERR(tSC) Quit
        }
        
        #; If we have errored, then exit early
        If $$$ISERR(tSC) Quit
        
        #; Fill in the line count
        Set tTextArray(0)=tI
    
        Set tSC=##class(%Atelier.v1.Utils.General).GetNameFromDocArray(.tTextArray,.tDocName)
        If $$$ISERR(tSC) Quit
    
        #; Validate
        If ##class(%Atelier.v1.Utils.General).ValidateDocName(tDocName,.tSC)=0 {
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
    
        #; Optimistically set HTTP code
        Set %response.Status=..#HTTP200OK
            
        Try {
            
            #; Capture output
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
            
            #; According to extension
            If $Piece(tDocName,".",*)="CLS" {
            
                #; Need to indicate (via a global unfortunately) that this text must NOT be saved to the
                #; database, only stored in a temporary area from which the Xml can be generated
                Set tGblSubscript=$Piece(tDocName,".",1,*-1),^||%oddDEF(tGblSubscript)="",tTemporaryStoreFlagSet=1
                
                #; Now serialize
                Set tSC=##class(%Atelier.v1.Utils.TextServices).SetTextFromArray(.tTextArray,tFlags)
                If $$$ISERR(tSC) {
                    Set %response.Status=..#HTTP400BADREQUEST
                    Quit
                }
                
                #; Now export the document as XML (use prefix to indicate temporary storage)
                Set tXmlStream=##class(%Library.FileCharacterStream).%New()
                Set tSC=$System.OBJ.ExportToStream("|"_tDocName,.tXmlStream,"/displaylog=0/displayerror=0",.tErrorLog)
                
                If $$$ISERR(tSC) {
                    Set %response.Status=..#HTTP400BADREQUEST
                    Quit
                }
        
            } else {
                
                #; Just need to wrap the text in XML
                Set tSC=##class(%Atelier.v1.Utils.General).WrapRtnDocWithXML(.tTextArray,.tXmlStream)
                If $$$ISERR(tSC) Quit
            }
            
        } Catch (e) {
            
            Set tSC=e.AsStatus()
        }
        
        #; It's important to clean this up whatever happens
        If tTemporaryStoreFlagSet=1 Kill ^||%oddDEF(tGblSubscript)
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; Serve the xml
    Quit ..ServeXml(tDocName,tSC,.tMsgArray,tXmlStream)
}

/// This method converts a XML to the corresponding client document format.
/// <br/>Note: This is NOT a public API and will be retired in a later version
/// <br/>Customers SHOULD NOT call this API from their own code
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the posted content is empty
/// <br/>HTTP 415 if content type is not application/xml
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is plain text.
/// 
ClassMethod CvtXmlToClientDoc(pNamespace As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tCookie,tDB,tDocName,tLoadedList,tErrorLog,tName As %String
    #dim tRenderList,tTS,tCat As %String
    #dim tUpToDate As %Boolean 
    
    #; Flag to indicate that the incoming document should not be stored
    #dim tTemporaryStoreFlagSet As %Boolean = 0
    
    #dim tMsgPart As %DynamicArray = []
    #dim tMsgArray As %DynamicArray = []
    
    #; This will efficiently manage a collection of documents
    #dim tResPart As %DynamicObject
    
    Try {
         
        #; Ensure we are only passed xml
        If %request.ContentType'="application/xml" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
        
        #; Need to make sure that we have some content
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        #; Ensure we are at the begining of the stream and read in the document
        Set tSC=%request.Content.Rewind()
        If $$$ISERR(tSC) Quit
        
        #; Ensure that the terminator is newline
        Set %request.Content.LineTerminator=$Char(10)
        
        #; Optimistically set HTTP code
        Set %response.Status=..#HTTP200OK
        
        #; This flag alters the behavior of import
        Kill ^||%oddDEF Set ^||%oddDEF=1,tTemporaryStoreFlagSet=1
            
        Try {
            
            #; Capture output
            Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
            If $$$ISERR(tSC) Quit
        
            #; LoadStream(stream,qspec,&errorlog,&loadedlist,listonly,selecteditems,displayname,charset)
            Set tSC=$System.OBJ.LoadStream(%request.Content,"/displaylog=0/displayerror=0",.tErrorLog,.tLoadedList)
        
            If $$$ISERR(tSC) {
                Set %response.Status=..#HTTP400BADREQUEST
                Quit
            }
        
            #; For each document
            Set tName="" For {
                
                #; Get the name
                Set tName=$Order(tLoadedList(tName)) If tName="" Quit
                
                #; Validate Name (hard error if not valid)
                If '##class(%Atelier.v1.Utils.General).ValidateDocName(tName,.tSC,.tCat) Quit
                
                #; Normalize
                Set tDocName=##class(%Atelier.v1.Utils.General).NormalizeDocName(tName)
        
                #; We didn't load into the database so we don't know the database
                #; or timestamp
                Set (tDB,tTS,tUpToDate)=""
                    
                #; Add to the RenderList
                Set tRenderList(tName)=##class(%Atelier.v1.Utils.LazyDocument).%New(tDocName,tDB,tTS,$$$OK,tCat,0,tUpToDate)
            }
        
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        #; MUST close the redirect whatever happens
        If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
        #; NOW check error status
        If $$$ISERR(tSC) Quit
            
        #; Create a collection of documents
        Set tResPart=##class(%Atelier.v1.Utils.General).CreateDocumentCollection(.tRenderList)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }

    Try {        
       
        #; Render the response body
        Set tSC=..RenderResponseBody(tSC,.tMsgArray,.tResPart)
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; It's important to clean this up whatever happens
    If tTemporaryStoreFlagSet=1 Kill ^||%oddDEF
    
    Quit tSC
}

/// This method is passed a list of database keys and hashes as a json array.
/// <br/>The hash values are used to determine if anything has changed in the database defined by the key.
/// <br/>The first call to this api necessarily POSTS an empty array. Subsequent posts can post the dbname
/// <br/>and dbhash to discover which documents have been modified on the server since the last call
/// <br/>
/// <br/>Input format :- 
/// <br/>
/// <br/>[ { "dbname" : "USER", "dbhash" : "KWAGbOdnRblPzANaiv1Oiu0BZLI" }, ... ]
/// <br/>
/// <br/>Output format :- 
/// <br/>
/// <br/>[ { "dbname" : "USER", "dbhash" : "Qx1zuNaulq3b_1yR9ahZAfjkc-", "crhash" : "47763751EC",
/// <br/>    "docs" : [{ "name": "User.NewClass1.cls", "ts" : "2015-05-29 17:24:30.156", "gen": false }, ... ]
/// <br/>  }, ... ]
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 400 if the posted content is empty or type is anything other than CLS
/// <br/>HTTP 415 if content type is not application/json
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// 
ClassMethod GetModifiedDocNames(pNamespace As %String, pType As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException  
    
    #dim tI As %Integer
    #dim tName,tContent,tDocName,tHave,tOrigHave As %String
    #dim tType,tGbl As %String
    #dim tId As %String
    #dim tDoc,tDb,tMsgPart As %DynamicObject
    #dim tShowGenerated As %Boolean
    #dim tHaveArray As %DynamicArray
    #dim tModifiedDbs,tResPart
    
    Try {
        
        #; Ensure we are only passed json
        If %request.ContentType'="application/json" {  
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
        
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit    
        }
        
        #; Include Generated?
        Set tShowGenerated=+%request.Get("generated")
        
        #; Parse the content (JSON array)
        Try {
            Set tHaveArray=##class(%DynamicArray).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit
        
        #; Check for an array of objects
        If 'tHaveArray.%IsA("%DynamicArray") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit 
        }
    
        #; Create the 'Have' Array
        For tI=0:1:tHaveArray.%Size()-1 {
            Set tName=tHaveArray.%Get(tI).dbname
            Set tHave(tName)=tHaveArray.%Get(tI).dbhash
        }
        
        #; Save a copy of the original db list
        Merge tOrigHave=tHave
        
        #; Get the list of Documents
        Set tSC=##class(%Atelier.v1.Utils.General).GetModifiedDocuments(.tHave,pType,.tGbl,tShowGenerated)
        If $$$ISERR(tSC) Quit
        
        Try {
            
            #; Now walk the list and create an output object
            Set tId="" For {
                
                #; Get the db name
                Set tId=$Order(@tGbl@(tId)) If tId="" Quit
                
                #; Create a new object to represent the 'db'
                Set tDb = ##class(%Atelier.v1.Utils.LazyModifiedDb).%New(tGbl,tId,tHave(tId),tHave(tId,"crhash"))
                Set tModifiedDbs(tId)=tDb
                
                #; Remove the db from the original list
                Kill tOrigHave(tId)
                
            }
            
            #; Is there any db in the original list for which there
            #; were no documents returned, but the hash is not current?
            #; If so, return the current hash.
            Set tId=""
            For {
                Set tId=$Order(tOrigHave(tId)) Quit:tId=""
                If tOrigHave(tId)'=tHave(tId) {
                    Set tDb = ##class(%Atelier.v1.Utils.LazyModifiedDb).%New(tGbl,tId,tHave(tId),tHave(tId,"crhash"))
                    Set tModifiedDbs(tId)=tDb
                }
            }
            
        } Catch (e) {
            Set tSC=e.AsStatus()
        }
        
        If $$$ISERR(tSC) Quit

        #; Create a collection of "documents"
        Set tResPart=##class(%Atelier.v1.Utils.General).CreateDocumentCollection(.tModifiedDbs)

    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit ..RenderResponseBody(tSC,,.tResPart)
}

/// Determine the source control class and get an instance of it. The instance is stored in
/// <br/>the public variable %SourceControl and is used by various system utilities.
/// 
ClassMethod CreateSourceControlClass() As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tReload,tCreated As %Boolean = 0
    #dim tFlags,tIconStatus,tMainJob As %Integer = 0
    #dim tUserName,tVersion As %String = ""
    
    Try {
        #; Need to indicate that source control is being created by Atelier and Not Studio.
        Set tVersion="Atelier (REST)"
        Set tSC=##class(%Studio.SourceControl.Interface).SourceControlCreate($username,"",.tCreated,.tFlags,.tUserName,tVersion,.tReload,tMainJob,.tIconStatus)   
        If $$$ISERR(tSC) Quit
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    Quit tSC
}

/// This method returns a list of namespaces for this server.
/// <br/>
/// <br/>GET http://localhost:57772/api/atelier/v1/%25SYS/namespaces
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is an array of namespaces.
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": [
///       "%SYS",
///       "DOCBOOK",
///       "SAMPLES",
///       "USER"
///     ]
///   }
/// }
/// </pre>
ClassMethod GetNamespaces() As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tNS,tFilteredArray As %String
    #dim tContent As %DynamicObject = {}
    #dim tArray As %DynamicArray = []
    
    Try {
        
        #; Filter the accessible namespace
        Do ##class(%Atelier.v1.Utils.General).AccessibleNamespaces(.tFilteredArray)

        Set tNS="" For  {
            Set tNS=$Order(tFilteredArray(tNS)) If tNS="" Quit
            Do tArray.%Push(tNS)
        }
  
        Set tContent.content=tArray

    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit ..RenderResponseBody(tSC,,tContent)
}

/// This method returns information about a specific namespace
/// <br/>
/// <br/>GET http://localhost:57772/api/atelier/v1/:namespace
/// <br/>
/// <br/>GET http://localhost:57772/api/atelier/v1/DOCBOOK
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is information about a namespace
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": {
///       "name": "DOCBOOK",
///       "db": [
///         { "name": "DOCBOOK", "crhash": "5046B9BF0DE", "default": true },
///         { "name": "CACHESYS", "crhash": "47763751EC", "default": false },
///         { "name": "CACHE", "crhash": "4776EDD1C3", "default": false },
///         { "name": "CACHELIB", "crhash": "5023332D0A7", "default": false }
///       ],
///       "features": [
///         {
///           "name": "ENSEMBLE",
///           "enabled": false
///         }
///       ],
///     }
///   }
/// }
/// </pre>
ClassMethod GetNamespace(pNamespace) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim %response As %CSP.Response
    
    #dim tAccessibleNamespaces,tRtnDir As %String
    #dim tContent As %DynamicObject = {}
    #dim tFeature,tResult As %DynamicObject
    #dim tDbObj As %DynamicObject
    #dim tDbArr As %DynamicArray
    #dim tDblist,tDbName,tDefault,tHash,info As %String
    #dim tEnsembleEnabled As %Boolean
    
    Try {
       
        #; Check for empty namespace
        If pNamespace="" {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        Set pNamespace=$ZCVT(pNamespace,"U")
            
        #; Now filter by accessible namespaces
        Do ##class(%Atelier.v1.Utils.General).AccessibleNamespaces(.tAccessibleNamespaces)
        
        If '$Data(tAccessibleNamespaces(pNamespace)) {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        Set tContent.name=pNamespace
        
        Set tRtnDir=##class(%SYS.Namespace).GetRoutineDest(pNamespace)
        Set tDefault=##class(%Atelier.v1.Utils.General).GetDbNameFromDir("^"_tRtnDir)
        Set tSC=##class(%Atelier.v1.Utils.General).GetDbdirCrhash("^"_tRtnDir,.tHash)
        If $$$ISERR(tSC) Set tHash=0
        
        #; Get all other databases that the namespace is mapped to
        Set tSC=##class(%Atelier.v1.Utils.General).NamespaceDbList(pNamespace,.tDblist)
        If $$$ISERR(tSC) Quit
        
        #; Make sure default db only appears once
        Kill tDblist(tDefault)
        
        Set tDbArr = []
        
        Set tDbObj = { "name":(tDefault), "crhash":(tHash) }
        Do tDbObj.%Set("default",1,"Boolean")
        Do tDbArr.%Push(tDbObj)
        
        Set tDbName="" For {
            Set tDbName=$Order(tDblist(tDbName)) Quit:tDbName=""
            Set tDbObj = { "name":(tDbName), "crhash":($get(tDblist(tDbName,"crhash"),0)) }
            Do tDbObj.%Set("default",0,"Boolean")
            Do tDbArr.%Push(tDbObj)
        }
        
        Set tContent.db=tDbArr
        
        Set tContent.features = []
        
        Set tEnsembleEnabled=##class(%EnsembleMgr).IsEnsembleNamespace(pNamespace)
        Set tFeature = {}
        Set tFeature.name="ENSEMBLE"
        Do tFeature.%Set("enabled",tEnsembleEnabled,"boolean")
        Do tContent.features.%Push(tFeature)
       
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Set tResult = {}, tResult.content = tContent
    
    Quit ..RenderResponseBody(tSC,,tResult)
}

/// This method returns a list csp apps defined on the server (or namespace)
/// <br/>
/// <br/>GET http://localhost:57772/api/atelier/v1/%25SYS/cspapps
/// <br/>GET http://localhost:57772/api/atelier/v1/%25SYS/cspapps/DOCBOOK
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is an array of csp application descriptors.
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": [
///       "/csp/broker",
///       "/csp/docbook",
///       "/csp/documatic",
///       "/csp/samples",
///       "/csp/samples/docserver",
///       "/csp/sys",
///       "/csp/sys/bi",
///       "/csp/sys/exp",
///       "/csp/sys/mgr",
///       "/csp/sys/op",
///       "/csp/sys/sec",
///       "/csp/user",
///       "/isc/pki",
///       "/isc/studio/rules",
///       "/isc/studio/templates",
///       "/isc/studio/usertemplates"
///     ]
///   }
/// }
/// </pre>
/// <br/>
/// <br/>passing the URL parameter ?detail=1 will return an array containing objects which describe
/// <br/>the application in more detail :-
/// <br/>
/// <pre>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": [
///       {
///         "default": false,
///         "name": "/csp/broker"
///       },
///       {
///         "default": true,
///         "name": "/csp/sys"
///       },
///       {
///         "default": false,
///         "name": "/csp/sys/bi"
///       },
///       {
///         "default": false,
///         "name": "/csp/sys/exp"
///       },
///       {
///         "default": false,
///         "name": "/csp/sys/mgr"
///       },
///       {
///         "default": false,
///         "name": "/csp/sys/op"
///       },
///       {
///         "default": false,
///         "name": "/csp/sys/sec"
///       },
///       {
///         "default": false,
///         "name": "/isc/pki"
///       },
///       {
///         "default": false,
///         "name": "/isc/studio/rules"
///       },
///       {
///         "default": false,
///         "name": "/isc/studio/templates"
///       },
///       {
///         "default": false,
///         "name": "/isc/studio/usertemplates"
///       }
///     ]
///   }
/// }
/// </pre>
ClassMethod GetCSPApps(pNamespace As %String = "") As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tArray As %DynamicArray
    #dim tContent,tObject As %DynamicObject
    #dim tDetail As %Boolean
    #dim tApps,tAppName,tAppData As %String
    #dim tNamespaces,tNsp As %String
   
    Try {
        
        #; Should return additional detail?
        Set tDetail=+%request.Get("detail")
          
        #; Create the content
        Set tContent = {}
                
        #; Create the array
        Set tArray = []
        
        If pNamespace="" {
            #; Want all namespaces
            Do ##class(%Atelier.v1.Utils.General).AccessibleNamespaces(.tNamespaces)
        } Else {
            Set tNamespaces(pNamespace)=""
        }

        Set tNsp=""
        For {
            Set tNsp=$Order(tNamespaces(tNsp))
            Quit:tNsp=""
            
            #; Must switch to target namespace to get the app list 
            #; Invalid namespace just returns empty list       
            Do
            . New $Namespace
            . Try { Set $Namespace=tNsp } Catch {}
            . Quit:$Namespace'=tNsp
            . Kill tApps Do CSPAppList^%SYS.cspServer2(.tApps)
            
            #; Do not return applications that do not have a file path
            #; Do not return applications that have a dispatch class
            Set tAppName=""
            For {
                Set tAppName=$Order(tApps(tAppName),1,tAppData)
                Quit:tAppName=""
                Continue:$$$GetSecurityApplicationsPath(tAppData)=""
                Continue:$$$GetSecurityApplicationsDispatchClass(tAppData)'=""
                
                If (tDetail) {
                    
                    Set tObject = {"name":(tAppName)}
                    Do tObject.%Set("default",$$$GetSecurityApplicationsIsNameSpaceDefault(tAppData),"boolean")
                    
                    Do tArray.%Push(tObject)
                    
                } Else {
                    Do tArray.%Push(tAppName)
                }
            }
        }
    
        Set tContent.content=tArray

    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit ..RenderResponseBody(tSC,,tContent)
}

/// The delimiter string used by ##class(%Studio.Debugger).GetInfo
Parameter DELIMITER = {$C(19) _ "^" _ $C(1)};

/// This method returns a list of running jobs in the Cache instance.
/// <br/>
/// <br/>GET http://localhost:57772/api/atelier/v1/%25SYS/jobs?system=1
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is an array of job descriptors.
/// <br/>
/// {
///   "status": {
///     "errors": [],
///     "summary": ""
///   },
///   "console": [],
///   "result": {
///     "content": [
///       {
///         "pid": 1394,
///         "namespace": "%SYS",
///         "routine": "%Studio.Debugger.1",
///         "state": "RUN",
///         "device": "|TCP|1972|1394"
///       },
///       {
///         "pid": 1345,
///         "namespace": "%SYS",
///         "routine": "RECEIVE",
///         "state": "HANG",
///         "device": "/dev/null"
///       },
///       {
///         "pid": 1364,
///         "namespace": "%SYS",
///         "routine": "%SYS.TaskSuper.1",
///         "state": "SELECTW",
///         "device": "/dev/null"
///       },
///       {
///         "pid": 1396,
///         "namespace": "%SYS",
///         "routine": "%SYS.cspServer3",
///         "state": "READ",
///         "device": "|TCP|1972|1396"
///       },
///       {
///         "pid": 1346,
///         "namespace": "%SYS",
///         "routine": "ECPWork",
///         "state": "RUNW",
///         "device": "/dev/null"
///       },
///       {
///         "pid": 1417,
///         "namespace": "%SYS",
///         "routine": "%SYS.BINDSRV",
///         "state": "READ",
///         "device": "|TCP|1972|1417"
///       }
///     ]
///   }
/// }
/// 
ClassMethod GetJobs() As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    #dim tJob As %DynamicObject
    #dim tArray As %DynamicArray
    #dim tPid As %Integer
    #dim tInfo,tNameSpace,tRName,tSystem As %String
    #dim tShowSystem As %Boolean
    #dim tResult As %DynamicObject = {}
      
    Try {

        Set tShowSystem=+%request.Get("system")
            
        Set tArray = []

        #; build PIDs into JSON array

        #; getinfo returns the following info
        #; info(1) = jobnumber (always 0 in ..GetJobStatus)
        #; info(2) = pid
        #; info(3) = unused
        #; info(4) = namespace
        #; info(5) = routine
        #; info(6) = lines executed (not used in ..GetJobStatus)
        #; info(7) = global references (not used in ..GetJobStatus)
        #; info(8) = process state
        #; info(9) = prinicipal device
        #; info(10) = process can be examined
        #; info(11) = process is being debugged (4 or 0)

        #; Horrible but true, we have to manually maintain this list
        Set tSystem="|ECPWork|RECEIVE|%SYS.BINDSRV|%SYS.cspServer2|%SYS.cspServer3|%SYS.TaskSuper.1|%Studio.Debugger.1|%Debugger.System.1|%Atelier.v1.XDebugAgent.1|shell|"
        
        #; Get first pid number then loop through all the pids
        Set tPid = $Zjob("")
        While (tPid '= "") {
            
            Set tInfo = ##class(%Studio.Debugger).GetInfo(0,tPid)
                     
            #; Only want debuggable processes
            If ($Piece(tInfo,..#DELIMITER,10)=0) || 
               ($Piece(tInfo,..#DELIMITER,11)'=0) {
                Set tPid=$Zjob(tPid) Continue
            }
            
            #; Render info into pid, namespace, routine, state, device
            #; NameSpace of job
            Set tNameSpace = $Piece(tInfo,..#DELIMITER,4)
            
            #; Get routine name
            Set tRName = $Piece(tInfo,..#DELIMITER,5)
            
            #; If we aren't showing system routines then lets not
            If tShowSystem=0,tSystem[("|"_tRName_"|") Set tPid=$Zjob(tPid) Continue
            
            #; Special case MVB.n format names
            if ($Piece(tRName,".",1)= "MVB") Do MVBNameMap(.tRName,tNameSpace)

            #; Place job info into an object
            Set tJob = {}
            Set tJob.pid=tPid
            Set tJob.namespace=tNameSpace
            Set tJob.routine=tRName
            Set tJob.state=$Piece(tInfo,..#DELIMITER,8)
            Set tJob.device=$Piece(tInfo,..#DELIMITER,9)
            
            #; Insert Job info into array
            Do tArray.%Push(tJob)
            
            #; Get next pid number
            Set tPid = $Zjob(tPid)
        }

        #; Put Array of Jobs into the content field of the result
        Set tResult.content=tArray
       
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit ..RenderResponseBody(tSC,,tResult)

MVBNameMap(tRName,NameSpace)

    #dim temp,mvName,NameSpace
    
    ; Correction for MVB.n name (where n is canonical number)
    #; Fetch n piece of Name and test for canonical number
    Set temp = $Piece(tRName,".",2,*)
    if (temp = +temp) {
        #; Switch to namespace used by job using tRName
        new $namespace
        set $namespace = NameSpace
        #; Translate MVB.n tRName into the corresponding mvb routine name
        set mvName = ##class(%RoutineMgr).GetOther(tRName,"MVI") 
        #; Replace tRName string with translated routine name
        if (mvName '= "") set tRName = mvName
    }
}

ClassMethod RunDebugger() As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
   
    Try {
        
        Do ##class(%Library.Device).ReDirectIO(0)
        
        Set tSC=##class(%Atelier.v1.XDebugAgent).Page(0)
       
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    Quit tSC
}

/// This method returns a list of Ensemble class names.
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Returned content is an array of selected Ensemble class names.
/// <br/>
/// <br/>These are the query types:
/// <br/>Adapters           1
/// <br/>InboundAdapters    2
/// <br/>OutboundAdapters   3
/// <br/>Messages           4
/// <br/>Requests           5
/// <br/>Responses          6
/// <br/>BusinessServices   7
/// <br/>BusinessProcesses  8
/// <br/>BusinessOperations 9
/// <br/>DataTransformation 10
/// <br/>Production         11
/// <br/>BusinessHost       12
/// <br/>Dashboard          13
/// <br/>Rule               14
/// <br/>
/// <br/>Example response:
/// <br/>
/// <pre>
/// {
///   status: {
///     errors: []
///     summary: ""
///   }
///   console: []
///   result: {
///     content: [
///         "Ens.Enterprise.MsgBank.BankTCPAdapter"
///         "Ens.Enterprise.MsgBank.ClientTCPAdapter"
///         "Ens.InboundAdapter"
///         "Ens.OutboundAdapter"
///     ]
///   }
/// }
/// </pre>
ClassMethod GetEnsClassType(pNamespace As %String = "", pClassType As %Integer = 0) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tRS As %ResultSet
    #dim tArray As %DynamicArray
    #dim tContent As %DynamicObject
   
    Try {

        #; Create the content
        Set tContent = {}
                
        #; Create the array
        Set tArray = []
        
        #; We will use Ens.StudioManager
        Set tRS=##class(%ResultSet).%New("Ens.StudioManager:ClassList")
    
        If $IsObject(tRS) {
        
            #; Execute
            Set tSC=tRS.Execute(pClassType)
            If $$$ISERR(tSC) Quit
            
            #; Walk the result list
            While tRS.Next(.tSC) {
                If $$$ISERR(tSC) Quit
                Do tArray.%Push(tRS.Data("Name"))
            }
            
            If $$$ISERR(tSC) Quit
        }
        Set tContent.content=tArray

    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit ..RenderResponseBody(tSC,,tContent)
}

/// Data("Type") values returned for the %RoutineMgr:StudioOpenDialog result set are:<br>
/// 0:"MAC",1:"INT",2:"INC",3:"BAS",4:"CLS",5:"CSP",6:"CSR",7:"GBL",8:"PRJ",11:"MVB",12:"MVI",13:"OBJ",100:"DFI"
/// 
ClassMethod getDlgCat(pType As %Integer) As %String [ CodeMode = expression, Internal ]
{
$Case(pType,0:"RTN",1:"RTN",2:"RTN",3:"RTN",4:"CLS",5:"CSP",6:"CSP",7:"OTH",8:"OTH",9:"OTH",10:"OTH",11:"RTN",12:"RTN",:"OTH")
}

/// Change external type values to our category
ClassMethod getTypeCat(pType As %String) As %String [ CodeMode = expression, Internal ]
{
$Case($zcvt(pType,"U"),"MAC":"RTN","INT":"RTN","INC":"RTN","BAS":"RTN","MVB":"RTN","MVI":"RTN","CLS":"CLS","CSP":"CSP","CSR":"CSP",:"OTH")
}

/// This method returns the input and output type for the adapter.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 404 if the adapter does not exist
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// <br/>
/// <br/>Example response:
/// <br/>
/// <pre>
/// {
///   status: {
///     errors: []
///     summary: ""
///   }
///   console: []
///   result: {
///     content: {
///       input: "%Stream.Object"
///       output: "%String"
///     }
///   }
/// }
/// </pre>
ClassMethod GetAdpInputOutputClass(pNamespace As %String = "", pAdpName As %String = "") As %Status
{
        
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    #dim tI As %Integer
    #dim param As %String
    #dim tContent As %DynamicObject = {}
    #dim tResult As %DynamicObject = {}
   
    Try {
            
        #; We will use %Dictionary.ClassDefinition
        Set pdef = ##class(%Dictionary.ClassDefinition).%OpenId(pAdpName)
        If pdef="" {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        Set pdef=pdef.Parameters
        For tI = 1:1:pdef.Count() {
            Set param = pdef.GetAt(tI)
            If (param.Name = "SERVICEINPUTCLASS") {
                Set tContent.input = param.Default
            }
            ELSEIf (param.Name = "SERVICEOUTPUTCLASS") {
                Set tContent.output = param.Default
            }
            If ((tContent.input '= "") && (tContent.output '= "")) {
                Quit
            }
        }
        
        If (tContent.input = "") {
            Set tContent.input = "%RegisteredObject"
        }
        If (tContent.output = "") {
            Set tContent.output = "%RegisteredObject"
        }       
    
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    set tResult.content = tContent
    Quit ..RenderResponseBody(tSC,,tResult)
}

/// This method returns the binary contents of the AtelierMetaData.zip file for the named database
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if OK
/// <br/>HTTP 404 if the document does not exist
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// 
ClassMethod GetMetaData(pDataBaseName As %String) As %Status
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim tDB,tDir,tFileName As %String
    
    Try {
       
        #; Check database name
        If pDataBaseName="" 
        {
            #; It may be common for the file not to be found
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
            
        #; upcase
        Set pDataBaseName=$ZCVT(pDataBaseName,"U")
    
        #; Form installation directory
        Set tDir=##class(%File).ParentDirectoryName($System.Util.ManagerDirectory())
        Set tDir=##class(%File).NormalizeDirectory("dev",tDir)
        Set tDir=##class(%File).NormalizeDirectory("atelier",tDir)
        Set tDir=##class(%File).NormalizeDirectory(pDataBaseName,tDir)
    
        #; Get a binary file stream
        Set tFileStream=##class(%FileBinaryStream).%New()
        
        #; Find the filename
        Set tFileName=##class(%File).NormalizeFilename("METADATA.zip",tDir)
        If tFileName="" {
             #; It may be common for the file not to be found
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        ; Link to the file
        Set tSC=tFileStream.LinkToFile(tFileName)
        If $$$ISERR(tSC) {
            
            #; It may be common for the file not to be found
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        Set %response.ContentType="application/octet-stream"
        Do %response.SetHeader("Content-Disposition", "attachment; filename="""_ tFileName _ """" )
        
        #; No char set please
        Set %response.CharSet=""
        
        #; Want to send this out in raw mode
        Set %response.NoCharSetConvert=1
        
        #; Write out the file
        Do tFileStream.OutputToDevice()
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    Quit tSC
}

/// <br/> This call queues an item for work. On success it returns 202 and sets the 'Location' header
/// <br/> to indicate where the results can be retrieved from with an HTTP GET.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 202 if Accepted
/// <br/>HTTP 404 if the request type does not exist
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// 
ClassMethod QueueAsync(pNameSpace As %String) As %Status [ Internal ]
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim %request As %CSP.Request
    #dim %response As %CSP.Response
    
    #dim tMsgArray As %DynamicArray = []
    #dim tCookie As %String
    #dim tID,tJob As %Integer
    #dim tRequest,tResPart As %DynamicObject
    
    #; Initialize
    Set tResPart={},tResPart.content={}
     
    Try {
        
        Set tSC=##class(%Atelier.v1.Utils.General).BeginCaptureOutput(.tCookie)
        If $$$ISERR(tSC) Quit
        
        #; Validate the type of content
        If %request.ContentType'="application/json" {
            Set %response.Status=..#HTTP415UNSUPPORTEDMEDIATYPE
            Quit
        }
        
        #; Need to make sure that we have some content
        If '$IsObject(%request.Content) {
            Set tSC=$$$ERROR($$$PostedDataNoContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        Set tSC=%request.Content.Rewind()
        If $$$ISERR(tSC) Quit
        
        Try {
            Set tRequest=##class(%DynamicObject).%FromJSON(%request.Content)
        } Catch (e) {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
        }
        If $$$ISERR(tSC) Quit

        If 'tRequest.%IsA("%DynamicObject") {
            Set tSC=$$$ERROR($$$InvalidJSONContent)
            Set %response.Status=..#HTTP400BADREQUEST
            Quit
        }
        
        If tRequest.request'="compile",tRequest.request'="testrtn" {
            Set tSC=$$$ERROR($$$UnknownRequestType,tRequest.request)
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        #; Lock the work queue
        Lock +^ISC.AsyncQueue("work")
        
        #; Get a new id
        Set tID=$Increment(^ISC.AsyncQueue)
        
        #; Set up the work queue
        Set ^ISC.AsyncQueue(tID,"request")=tRequest.%ToJSON()
        Set ^ISC.AsyncQueue(tID,"time")=$ztimestamp
        
        #; Set up the console output queue counters
        Set ^ISC.AsyncQueue(tID,"cout","i")=1
        Set ^ISC.AsyncQueue(tID,"cout","o")=1
        
        #; Start the monitor job if it is not already running
        Lock +^ISC.AsyncQueue("monitor"):0
        If $Test {
            #; Got the lock, so it's not running. Start it.
            Job ..Monitor()
            Lock -^ISC.AsyncQueue("monitor")
        }
        
        #; Release the lock
        Lock -^ISC.AsyncQueue("work")
        
        #; Set the location to get results from
        Do %response.SetHeader("Location",tID)
        
        #; Refer to named item
        Set %response.Status=..#HTTP202ACCEPTED
        
    } Catch (e) {
        Lock -^ISC.AsyncQueue("monitor"),-^ISC.AsyncQueue("work")
        Set tSC=e.AsStatus()
    }
    
    #; MUST close the redirect whatever happens
    If $Data(tCookie) Do ##class(%Atelier.v1.Utils.General).EndCaptureOutput(tCookie,.tMsgArray)
    
    Quit ..RenderResponseBody(tSC,tMsgArray,tResPart)
}

/// <br/> This call polls a queued item for console output and results. On success it returns 200. 
/// <br/> Console output and results are found in the standard locations for Atelier REST APIs.
/// <br/> If there is more output expected the server will set the 'Retry-After' header. The client
/// <br/> should read this header to determine if another call should be made.
/// <br/> When the result of processing is available (or the work is finished) a GET to this API 
/// <br/> will return any results in the 'content' field and (crucially) will NOT set the 'Retry-After'
/// <br/> header. This is an indication that processing is finished.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if Accepted
/// <br/>HTTP 404 if the document does not exist
/// <br/>HTTP 410 if the results have been purged (client never retrieved after lengthy delay)
/// <br/>HTTP 423 if the queue is locked
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// 
ClassMethod PollAsync(pNameSpace As %String, pID As %Integer) As %Status [ Internal ]
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim %request As %CSP.Request
    #dim %response As %CSP.Response
    
    #dim tI,tIn,tOut As %Integer
    #dim tResult As %String
    #dim tMsgArray As %DynamicArray = []
    #dim tResPart As %DynamicObject
    
    Set tResPart = { "content":{} }
    
    Try {
        
        #; Lock this input node
        Lock +^ISC.AsyncQueue("work",pID):1
        Else  Set %response.Status=..#HTTP423LOCKED Quit
        
        #; Exists?
        If '$Data(^ISC.AsyncQueue(pID)) {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        #; Response should be ok
        Set %response.Status=..#HTTP200OK
        
        Set tIn=^ISC.AsyncQueue(pID,"cout","i"),tOut=^ISC.AsyncQueue(pID,"cout","o")
        While tOut<tIn {
            Do tMsgArray.%Push($Get(^ISC.AsyncQueue(pID,"cout",tOut)))
            Set tOut=tOut+1
        }
        Set ^ISC.AsyncQueue(pID,"cout","o")=tOut
        
        #; Is the request finished?
        If $Data(^ISC.AsyncQueue(pID,"done")) || $Data(^ISC.AsyncQueue(pID,"cancel")) {
            #; Check for a final incomplete output line
            If $Data(^ISC.AsyncQueue(pID,"cout",tOut),tResult) {
                Do tMsgArray.%Push(tResult)
                Set ^ISC.AsyncQueue(pID,"cout","o")=tOut+1
            }
            
            #; Is a result present?
            If $Data(^ISC.AsyncQueue(pID,"result"),tResult)#2 {
                Set tResPart=##class(%DynamicObject).%FromJSON(tResult)
            }
            
            #; If there was an error, copy it into tSC
            If $Data(^ISC.AsyncQueue(pID,"error"),tSC)
            
            #; Clean it all, it's an error to ask again
            Kill ^ISC.AsyncQueue(pID)
            
        } else {
        
            #; No result yet
            #; Client needs to ask again (arbitrary wait time)
            Do %response.SetHeader("Retry-After",3)
        }
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    #; Release the lock
    Lock -^ISC.AsyncQueue("work",pID)
    
    #; Restart monitor job if it is gone (crashed?) and there is
    #; work waiting to be done
    Try {
        Lock +^ISC.AsyncQueue("monitor"):0
        If '$Test {
            #; It's running, nothing to do here
            Quit
        }
        
        #; Lock the work queue
        Lock +^ISC.AsyncQueue("work")
        
        #; and check again
        Lock +^ISC.AsyncQueue("monitor"):0
        If '$Test {
            #; It's running, nothing to do here
            Lock -^ISC.AsyncQueue("work")
            Quit
        }
        
        #; Look for pending work
        Set tI=""
        For {
            Set tI=$Order(^ISC.AsyncQueue(tI))
            Quit:tI=""
            Quit:'$Data(^ISC.AsyncQueue(tI,"start"))
        }

        If tI'="" {
            #; There is pending work so start the monitor
            Job ..Monitor()
        }
        
    } Catch (e) {
        Set tSC=$$$ADDSC(tSC,e.AsStatus())
    }
        
    #; Release the locks
    Lock -^ISC.AsyncQueue("work")
    Lock -^ISC.AsyncQueue("monitor")
    
    Quit ..RenderResponseBody(tSC,tMsgArray,tResPart)
}

/// <br/> This call cancels a work request that has been previously queued.
/// <br/>
/// <br/>HTTP Codes returned:-
/// <br/>
/// <br/>HTTP 200 if Cancelled
/// <br/>HTTP 202 if Accepted and Cancel issued
/// <br/>HTTP 404 if the request does not exist
/// <br/>HTTP 500 if an error occurs (details will be in status error array)
/// 
ClassMethod CancelAsync(pNameSpace As %String, pID As %Integer) As %Status [ Internal ]
{
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    #dim monjob,killrc
    
    #dim tResPart As %DynamicObject = {}
    
    Try {
        If '$Data(^ISC.AsyncQueue(pID)) {
            Set %response.Status=..#HTTP404NOTFOUND
            Quit
        }
        
        #; Response should be ok
        Set %response.Status=..#HTTP200OK
        
        Lock +^ISC.AsyncQueue("work",pID)
        If '$Data(^ISC.AsyncQueue(pID,"start")) {
            #; Not started yet, so just remove it
            Kill ^ISC.AsyncQueue(pID)
            Quit
        }
        If $Data(^ISC.AsyncQueue(pID,"done")) {
            #; It's finished, so just clean it up
            Kill ^ISC.AsyncQueue(pID)
            Quit
        }
        #; It has "start" but not "done" so it should
        #; be running in the Monitor right now.
        If $Get(^ISC.AsyncQueue("monitor","run"))'=pID {
            #; We're out of sync somehow, just clean up
            Kill ^ISC.AsyncQueue(pID)
            Quit
        }
        
        Lock +^ISC.AsyncQueue("monitor"):0
        If $Test {
            #; Monitor is not running! Did the request crash it?
            #; Nothing to do but clear it out
            Kill ^ISC.AsyncQueue(pID)
            Lock -^ISC.AsyncQueue("monitor")
            Quit
        }
        Set ^ISC.AsyncQueue(pID,"cancel")=$ztimestamp
        Set monjob=$Get(^ISC.AsyncQueue("monitor"))
        If monjob'="",$ZUtil(61,30,$ZUtil(67,$List(monjob,1)))=$List(monjob,2) {
            
            Set ^ISC.AsyncQueue("monitor","cancel")=$ztimestamp
            Set killrc=$SYSTEM.Process.Terminate($List(monjob,1))
            
            If killrc=1 {
                #; The RESJOB was started
                Set %response.Status=..#HTTP202ACCEPTED
            } ElseIf killrc=-4 {
                #; The process is in ROLLBACK, so request was ignored.
                #; Should try again in a bit.
                Do %response.SetHeader("Retry-After",3)
                Quit
            } Else {
                #; This is serious, the Monitor job can't be killed.
                #; How will we recover the lock so another can start?
                Set tResPart.TerminateErrorCode=killrc
            }
            
        } Else {
            #; The monitor process just now changed!
            Kill ^ISC.AsyncQueue(pID)
            Quit
        }
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit ..RenderResponseBody(tSC,,tResPart)
}

/// This is a background job that monitors the queue for work to do
ClassMethod Monitor() [ Internal ]
{
    #dim tID,tIdle As %Integer
    #dim tRequest As %DynamicObject
    #dim e As %Exception.AbstractException
    #dim tSC As %Status
    #dim tFlags,tGetSource,tItemArray,tI
    #dim tResult As %DynamicObject
    
    #; We hold this lock for as long as we are running
    Lock +^ISC.AsyncQueue("monitor"):15
    If '$Test {
        #; Can't lock, another monitor must be already running
        Halt
    }
    Set ^ISC.AsyncQueue("monitor")=$ListBuild($Job,$ZUtil(61,30,$ZUtil(61)))
    Kill ^ISC.AsyncQueue("monitor","cancel")
    Set ^ISC.AsyncQueue("monitor","run")=""
    #; This prevents "monitor" from being selected for work
    Set ^ISC.AsyncQueue("monitor","start")=$ztimestamp
    
    Set tIdle=0
    
    For {
        #; Lock the work queue
        Lock +^ISC.AsyncQueue("work")
        
        #; Find something to do
        Set tID=""
        For {
            Set tID=$Order(^ISC.AsyncQueue(tID)) Quit:tID=""
            Quit:'$Data(^ISC.AsyncQueue(tID,"start"))
        }
        
        If tID="" {
            #; No work
            Set tIdle=tIdle+1
            If tIdle>20 {
                Kill ^ISC.AsyncQueue("monitor")
                Lock -^ISC.AsyncQueue("monitor")
                Lock -^ISC.AsyncQueue("work")
                Set $HALT=""
                Halt
            }
            Lock -^ISC.AsyncQueue("work")
            Hang 3
            Continue
        }
        
        #; Claim the request
        Set ^ISC.AsyncQueue(tID,"start")=$ztimestamp
        Set ^ISC.AsyncQueue("monitor","run")=tID
        Lock -^ISC.AsyncQueue("work")
        Set tIdle=0
        
        Try {
            Set $HALT="done"
            
            Set tRequest=##class(%DynamicObject).%FromJSON(^ISC.AsyncQueue(tID,"request"))
            
            If tRequest.request="compile" {
                
                If tRequest.%IsDefined("flags") {
                    Set tFlags=tRequest.flags
                } Else {
                    Set tFlags="cuk"
                }
                
                If tRequest.%IsDefined("source") {
                    Set tGetSource=tRequest.source
                } Else {
                    Set tGetSource=1
                }
                
                For tI=0:1:tRequest.documents.%Size()-1 {
                    Set tItemArray(tRequest.documents.%Get(tI))=""
                }
                
                Try {
                    
                    Set tSC=..MonitorBeginCapture(tID)
                    If $$$ISERR(tSC) Quit
                    
                    Set tResult = {}
                    Set tSC=##class(%Atelier.v1.Utils.General).Compile(.tItemArray,tFlags,tGetSource,.tResult)
                    
                    #; Lock the node while we set the result
                    Lock +^ISC.AsyncQueue("work",tID):10
                    #; If we can't lock, something must be wrong with the polling,
                    #; but what can we do?
                    
                } Catch (e) {
                    Set tSC=e.AsStatus()
                    Set:'$Data(tResult) tResult = {}
                }
                
                Do ..MonitorEndCapture(tID)
                
                Set ^ISC.AsyncQueue(tID,"result")=tResult.%ToJSON()
                
            } ElseIf tRequest.request="testrtn" {
                
                If tRequest.%IsDefined("tag") {
                    Set tFlags=tRequest.tag
                } Else {
                    Set tSC=$$$ERROR($$$GeneralError,"No Entry Point tag")
                    Quit
                }
                If tRequest.%IsDefined("routine") {
                    Set tI=tRequest.routine
                } Else {
                    Set tSC=$$$ERROR($$$GeneralError,"No Entry Point routine")
                    Quit
                }
                
                Try {
                    
                    Set tSC=..MonitorBeginCapture(tID)
                    If $$$ISERR(tSC) Quit
                    
                    Set tSC=$$@(tFlags)^@(tI)(.tResult)
                    
                    #; Lock the node while we set the result
                    Lock +^ISC.AsyncQueue("work",tID):10
                    #; If we can't lock, something must be wrong with the polling,
                    #; but what can we do?
                
                } Catch (e) {
                    Set tSC=e.AsStatus()
                }
                
                Set:'$Data(tResult) tResult = {}
                Do ..MonitorEndCapture(tID)
                
                Set ^ISC.AsyncQueue(tID,"result")=tResult.%ToJSON()
                
            } Else {
                Set tSC=$$$ERROR($$$UnknownRequestType,tRequest.request)
            }
            
        } Catch e {
            Set tSC=e.AsStatus()
        }
        
        If $$$ISERR(tSC) {
            Set ^ISC.AsyncQueue(tID,"error")=tSC
        }
        
done ;
        Set ^ISC.AsyncQueue(tID,"done")=$ztimestamp
        Set ^ISC.AsyncQueue("monitor","run")=""
        Lock -^ISC.AsyncQueue("work",tID)
    }
}

ClassMethod MonitorBeginCapture(pID As %String) As %Status [ Internal, ProcedureBlock = 0 ]
{
    New tSC,e

    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    Try {
        #; Use this routine for redirection
        Use $io::("^"_$ZNAME)
        
        #; Set the node
        Set ^||ISC.AsyncQueueNode=pID

        #; Switch redirection on
        Do $zutil(82,12,1)

    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    
    Quit tSC
    
rstr(sz,to) [rt] public {
    New rt Set vr="rt"
    Set rd=$zutil(82,12,0)
    Set:$data(sz) vr=vr_"#"_sz Set:$data(to) vr=vr_":"_to
    Read @vr
    Do:$data(to) $zutil(96,4,$t)
    Do $zutil(82,12,rd)
    Quit rt
}
wchr(s) Do write($char(s)) Quit
wff() Do write($char(12)) Quit
wnl() Do write($char(10)) Quit
wstr(s) Do write(s) Quit
wtab(s) Do write($justify("",s-$x)) Quit
write(s) public {
    Set tID=^||ISC.AsyncQueueNode
    Set lf=$find(s,$char(10))
    If lf {
        Do {
            Do write($Extract(s,1,lf-2))
            Set i=$increment(^ISC.AsyncQueue(tID,"cout","i")) ; Do wnl()
            Set s=$Extract(s,lf,*)
            Set lf=$find(s,$char(10))
        } While lf
        If s="" Quit
    }
    Set lno=$get(^ISC.AsyncQueue(tID,"cout","i")) Set:lno="" lno=1,^ISC.AsyncQueue(tID,"cout","i")=1
    Set curr=$get(^ISC.AsyncQueue(tID,"cout",lno))
    Set ^ISC.AsyncQueue(tID,"cout",lno)=curr_$translate(s,$char(13))
}
}

ClassMethod MonitorEndCapture(pID As %String) As %Status [ Internal ]
{
    #; Turn off redirection    
    Do $zutil(82,12,0)
    
    Quit $$$OK
}

}
