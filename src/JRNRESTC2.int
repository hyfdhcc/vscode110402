ROUTINE JRNRESTC2 [Type=INT]
JRNRESTC2 ;Cluster Restore Journal from a File, subrs ;HYY825, 10/27/03
 /*
 +--------------------------------------------------------+
 | Copyright 1986-2015 by InterSystems Corporation,       |
 | Cambridge, Massachusetts, U.S.A.                       |
 | All rights reserved.                                   |
 |                                                        |
 | Confidential, unpublished property of InterSystems.    |
 |                                                        |
 | This media contains an authorized copy or copies       |
 | of material copyrighted by InterSystems and is the     |
 | confidential, unpublished property of InterSystems.    |
 | This copyright notice and any other copyright notices  |
 | included in machine readable copies must be reproduced |
 | on all authorized copies.                              |
 +--------------------------------------------------------+
 */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/FILEINC.inc#1 $ ($Change: 4521965 $) */
 /* Revision: $Id: //adhocs/2016.2.3.904.11/DHC_SOFTWARE_CO_001/databases/sys/inc/_syJrninc.inc#1 $ ($Change: 4521965 $) */
 ; BITWISE.INC, DPB139 07/09/93
 ;
 ; This module contains subroutines for JRNRESTC. JRNRESTC got too
 ; big for the editor.
 ;
showdata ;
 ; This routine displays the clumember() information that will be
 ; used to restore the journal.
 ;
 n id,ref,i,ret
 w !,"Cluster journal restore file list"
 d showhead
 s ret=0
 f id=0:1:numclu d
 . w !,"Member #",id
 . s ref=$NAME(clumember(id,"files"))
 . s i=$$showone(ref)
 . s ret=($ZBOOLEAN(+(ret),+(i),7))
 d showfooter(ret)
 w !
 q
showhead ;
 ; Print the header for the data displayed by showone()
 ;
 w !,"                      "
 w "_______First Record________   ________Last Record________"
 w !,"   Filename        "
 f i=1:1:2 w " Sequence #    Date     Time  "
 w !,"   ----------------"
 f i=1:1:2 w " ---------- ---------- -------"
 q
showfooter(value) 
 ; takes the return of $$showone() and generates the correct
 ; footer. 
 ;       Bit #1 = we suspect one or more journal files are missing
 ;       Bit #2 = journal files span a cluster restart
 ;       Bit #4 = a journal file wasn't part of the cluster
 ;       Bit #8 = a journal file wasn't part of the cluster but a
 ;                prior and subsequent journal file are from the same
 ;                cluster (eg. the system was shutdown, restarted and
 ;                didn't immediatly join the cluster).
 ;
 w !,"st: indicates that journal file was generated by a jrnstart"
 w !,"          as opposed to a jrnswitch"
 ;
 i ($ZBOOLEAN(+(value),+(1),1)) d
 . w !,"<missing> indicates that the system thinks that at least "
 . w !,"          one journal file that should be present is missing"
 i ($ZBOOLEAN(+(value),+(2),1)) d
 . w !,"<cluster start: date time> indicates that this system joined"
 . w !,"          the cluster at some point during this journal file."
 . w !,"          The cluster sequence numbers are reset to 0 because"
 . w !,"          the cluster was restarted at some point."
 i ($ZBOOLEAN(+(value),+(4),1)) d
 . w !,"n/a for a sequence number indicates that the machine was never"
 . w !,"          part of the cluster for the 'life' of that journal"
 . w !,"          file."
 i ($ZBOOLEAN(+(value),+(8),1)) d
 . w !,"* for a sequence number means that this system was not part of"
 . w !,"          a cluster for the 'life' of the journal file but the"
 . w !,"          system was part of the same cluster before and after"
 . w !,"          this file. This file will be restored as if all its"
 . w !,"          records have the last sequence number from the prior"
 . w !,"          journal file from when the system was in the cluster."
 w !
 q
showone(ref) ;
 ; ref = a local array reference containing the "root" of the
 ; data for a system. This is typically either "dirlist" which
 ; is the output from findfiles or clumember(id,"files") which
 ; is where we accumulate the data for all of the cluster members.
 ;
 ; Returns the value to pass to showfooter(ret). The value we return
 ; is a bit field describing what elements of the key need to
 ; be explained. 
 ;    Bit #1 = we suspect one or more journal files are missing
 ;    Bit #2 = we detected a cluster restart across one or more
 ;                journal files
 ;    Bit #4 = we found a journal file from when the system wasn't
 ;                in the cluster so we displayed a sequence # of n/a
 ;    Bit #8 = a journal file wasn't part of the cluster but a
 ;                prior and subsequent journal file are from the same
 ;                cluster (eg. the system was shutdown, restarted and
 ;                didn't immediatly join the cluster).
 ; This is a bit field so that the results of multiple calls to
 ; showone can be ORed together to produce a single footer.
 ;
 n i,fname,line,seq,tstamp,missing,last,notinclu1,notinclu2
 n prevfile,retval,lastclumstart,clumstart,restartflag
 s missing=0,restartflag=1,notinclu1=0,notinclu2=0
 s index="",last=""
 s index=$O(@ref@(index))
 i index="" d  q 0
 . w !,?5,"<No journal files found for this cluster member>",!
 s line=@ref@(index),lastclumstart=$zdth($P(line,"^",9),-2)
 i lastclumstart d
 . w !,"   <cluster start: "
 . w $ZD(lastclumstart)," ",$ZT($P(lastclumstart,",",2),4)
 . w ">"
 f  d  s last=index,index=$O(@ref@(index)) q:index=""  
 . s line=@ref@(index)
 . w !
 . ; When clumstart from this file differs from the last value we've
 . ; seen it indicates the cluster restarted. A clumstart value of 0
 . ; indicates this system was not part of the cluster while it was
 . ; using that journal file. If we encounter a clumstart value of 0
 . ; we delay reporting that a cluster restart occurred until we see
 . ; a non-zero clumstart value (because a value of 0 doesn't mean
 . ; that the cluster restarted, it means that we didn't join the
 . ; cluster).
 . s clumstart=$zdth($P(line,"^",9),-2)
 . i clumstart,lastclumstart'=clumstart d
 . . w "   <cluster start: "
 . . w $ZD(clumstart)," ",$ZT($P(clumstart,",",2),4)
 . . w ">",!
 . . s lastclumstart=clumstart
 . . s restartflag=1
 . ;
 . s prevfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f($P(line,"^",2),";"),0:$e($P(line,"^",2),*-8-$l($p($P(line,"^",2),".",$l($P(line,"^",2),"."))),*),:$e($P(line,"^",2),*-8-$l($p($P(line,"^",2),".",$l($P(line,"^",2),"."))),$f($P(line,"^",2),";")-2)),:$P(line,"^",2))
 . i prevfile="" w "st:"  ; null prior file means jrnstart
 . e  i last=""  ;do nothing since this is the first file selected
 . e  i prevfile=$E(last,1,$L(last)-1) w "   "  ; the normal case
 . e  w "   ",prevfile,"   <missing>",!,"   " s missing=1 
 . ;
 . w $case($ZBITGET($ZVERSION(0),46),0:$case($f($P(line,"^"),";"),0:$e($P(line,"^"),*-8-$l($p($P(line,"^"),".",$l($P(line,"^"),"."))),*),:$e($P(line,"^"),*-8-$l($p($P(line,"^"),".",$l($P(line,"^"),"."))),$f($P(line,"^"),";")-2)),:$P(line,"^")),"    "
 . i '$P(line,"^",6) w "<empty>" q  ; lastoffset = 0
 . f i=4,7 d  ; sequence #'s are pieces 4 and 7
 . . i clumstart s seq=$P(line,"^",i)
 . . e  s seq="n/a",notinclu1=1
 . . i seq="*" s notinclu2=1 
 . . s tstamp=$P(line,"^",i+1)
 . . ; tstamp is in $H format
 . . w " ",$J(seq,10)
 . . w " ",$ZDATE(tstamp)," ",$ZTIME($P(tstamp,",",2),4)
 ; Form the retval bitmask. 
 ;    Bit #1 = we suspect one or more journal files are missing
 ;    Bit #2 = we detected a cluster restart across one or more
 ;                journal files
 s retval=0
 i missing s retval=($ZBOOLEAN(+(retval),+(1),7))
 i restartflag s retval=($ZBOOLEAN(+(retval),+(2),7))
 i notinclu1 s retval=($ZBOOLEAN(+(retval),+(4),7))
 i notinclu2 s retval=($ZBOOLEAN(+(retval),+(8),7))
 w !
 q retval
 ;
findfiles(id,jffirst,jflast,begloc) ;
 s begloc=$g(begloc) ;the location of the first record to dejournal
 ; This routine locates all the journal files for cluster system
 ; #id that span the range of time specified by the jffirst and jflast
 ; journal files. jffirst and jflast are either the journal files from
 ; the primary system or the user has specified a first and last for
 ; this system. These are in $$$JRNSHORTNAME form. If jflast is
 ; null we get all the jounal files from jffirst for this system.
 ;
 ; First build a list of all of the journal files from all of the
 ; source directories for this system
 ;
 ; Inputs:
 ;    clumember() structure
 ;    id = id # index into clumember() structure
 ;    jffirst = $$$JRNSHORTNAME of 1st journal file we want to find
 ;              for this system. If this is null we start with the
 ;              1st journal file we can find. If we can't find this
 ;              file exactly we find the file prior to it as our 
 ;              1st one.
 ;    jflast = $$$JRNSHORTNAME of the last journal file we want to
 ;              find for this system. If this is null we find all
 ;              journal files. If we can't find this journal file
 ;              exactly, we find the one which comes immediatly after
 ;              it.
 ; Output:
 ;    err indicates an error was encounterd and we should ask the
 ;        user if they want to abort or continue
 ;    For each journal file we think we need to restore we set:
 ;       dirlist(<shortname>_"J") =
 ;           <fullfilename>^
 ;           <prev jrnfile read from the journal file>^
 ;           <journal offset of the 1st journal record>^
 ;           <cluster sequence # of 1st journal offset>^
 ;           <timestamp on block containing 1st journal record>^
 ;           <journal offset of the last journal record>^
 ;           <cluster sequence # of last journal offset>^
 ;           <timestamp on block containing last journal record>^
 ;           <clumstarttime in integer format (time(0))>
 ;    
 n i,numpath,path,fspec,file,shortname,chan,n,index
 n firstcseq,lastcseq,firstadr,lastadr,firsttime,lasttime
 n prevjrn,str,d,next,header,d,next,clumstart,adr
 n tmpshort
 ;
 k dirlist  ; reset this
 s chan=-1  ; when chan is not negative, a journal file is open
 s $ZT="findfilesER"
 s numpath=clumember(id,"path")
 ;
 ; we find all the files in all of the directories. We then extract
 ; the portion that would be a "short journal file" name and if it
 ; matches the form nnnnnnnn.nnn we consider it a journal file
 ;
 ; This routine finds all of the journal files it can in
 ; clumember(id,"path",...) and for each journal file it finds it
 ; generates a dirlist(<shortname>) entry of the form described
 ; above.
 ;
 f i=1:1:numpath d
 . s path=clumember(id,"path",i)
 . s fspec=path_$P(clumember(id),"^",3)_"*.*"  ; 3rd piece = prefix
 . i '($zversion(1)=1) d
 . . w !,"This routine has not been ported to this o/s. Fix DIRLOOK"
 . . w !,"loop in findfiles^JRNRESTC2"
 . . s $ZE="<UNIMPLEMENTED>findfiles+<n>^JRNRESTC2" 
 . . g ^%ET
 . s fspec=fspec_";"  ; only get 1 version of each file
 . s file=$ZSE(fspec)
 . f  q:file=""  d  q:(jflast'="")&(shortname'<jflast)  s file=$ZSE("")
 . . ; set shortname to something that we know isn't greater than
 . . ; jflast until we know that "file" is a journal file. If file
 . . ; isn't a journal file but it has a numeric filename (for
 . . ; instance, 23E00931.LOG, we can get a <MAXNUMBER> error in
 . . ; the above loop (shortname'<jflast) or worse, we might terminate
 . . ; the loop prematurly.
 . . ;
 . . s shortname="00000000.000"
 . . s tmpshort=$case($ZBITGET($ZVERSION(0),46),0:$case($f(file,";"),0:$e(file,*-8-$l($p(file,".",$l(file,"."))),*),:$e(file,*-8-$l($p(file,".",$l(file,"."))),$f(file,";")-2)),:file)
 . . q:$L(tmpshort)<12  ; can't be a journal file name
 . . q:tmpshort'?8N1"."3.10N  ; isn't yyyymmdd.nnn
 . . ; Ok, shortname is 12 bytes, 8 numbers a dot and 3 numbers.
 . . ; See if the system thinks its a valid journal file
 . . ; $ZU(78,22,x,1) returns: code,prev journal file name
 . . ; where code:
 . . ;   0 = file doesn't exist or not a journal file
 . . ;   1 = file exists and is a journal file
 . . ; when code=1 the 2nd piece of the return string is the 
 . . ; journal file spec of the prior journal file from this journal
 . . ; file's header (if there is any).
 . . s prevjrn=$zu(78,22,file,1) 
 . . q:'+prevjrn
 . . ; ok, as best as we can tell, tmpshort is a journal file so
 . . ; go ahead and load it into shortname now.
 . . s shortname=tmpshort
 . . ; ok, the system says its a journal file, open it and extract
 . . ; some info about the 1st and last records
 . . s chan=$zu(78,5,file,0)
 . . i chan<0 w !,"open of journal file ",file," failed." s err=1 q
 . . s n=$zu(78,6,chan)
 . . i $p($p(file,";"),$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$l($p(file,";"),$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")))=$p($p($p(begloc,",",2),";"),$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$l($p($p(begloc,",",2),";"),$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))) d
 . . .  s firstadr=+begloc
 . . e  s firstadr=$zu(78,17,0)
 . . s lastadr=$zu(78,18,0)
 . . s:$zu(78,8,lastadr)=-1 lastadr=$zu(78,18,lastadr)
 . . s firstcseq=$zu(78,11,firstadr),lastcseq=$zu(78,11,lastadr)
 . . s firsttime=$zu(78,24,firstadr),lasttime=$zu(78,24,lastadr)
 . . s clumstart=$ZU(78,30,0)
 . . ; Not all journal records have cluster sequence #'s. If the first
 . . ; or last journal record has a seq # of 0 or -1 then search the
 . . ; journal till we find one that doesn't. Seq #'s of -1 are from
 . . ; records that don't have one. Seq #'s of 0 are from before the
 . . ; system joined the cluster. Even if a system has joined a 
 . . ; cluster, it might not have any records with a positive seq #.
 . . ; In this case we set the 1st and last sequence #'s to zero.
 . . i clumstart d
 . . . i firstcseq<1 s adr=firstadr f  d  q:'adr!(firstcseq>0)
 . . . . s adr=$zu(78,17,adr),firstcseq=$zu(78,11,adr)
 . . . i lastcseq<1 s adr=lastadr f  d  q:'adr!(lastcseq>0)
 . . . . s adr=$zu(78,18,adr),lastcseq=$zu(78,11,adr)
 . . . i lastcseq=-1 s firstcseq=0,lastcseq=0
 . . s n=$zu(78,7,chan),chan=-1
 . . s str=file_"^"_$P(prevjrn,",",2)
 . . s str=str_"^"_firstadr_"^"_firstcseq_"^"_firsttime
 . . s str=str_"^"_lastadr_"^"_lastcseq_"^"_lasttime
 . . s str=str_"^"_clumstart
 . . s dirlist(shortname_"J")=str
 ;
 ; Run through dirlist() looking for journal files that don't have
 ; a cluster timestamp (eg. the system wasn't in the cluster) but 
 ; where the prior and subsequent cluster timestamps are the same.
 ; This indicates a system restarted but didn't join the cluster 
 ; immediatly. These files are restored as if they were from the 
 ; cluster with the sequence number of the prior journal file. If
 ; all prior journal files from the cluster start are eliminated by
 ; elimfiles, these are changed back to "non-clustered" journals.
 ;
 s clumstart=""
 s index=$O(dirlist("")) q:index=""
 f  d  q:index=""
 . s n=$P(dirlist(index),"^",9) ;clumstart time
 . i n s clumstart=n,index=$O(dirlist(index)) q
 . ; This file doesn't have a cluster start time, find the next
 . ; cluster start time
 . s d=index ; remember where we started
 . f  s index=$O(dirlist(index)) q:index=""  q:$P(dirlist(index),"^",9)
 . q:index=""
 . s n=$P(dirlist(index),"^",9)
 . i n'=clumstart s clumstart=n,index=$O(dirlist(index)) q
 . ; Ok, we've found a range of journal files that don't have a cluster
 . ; timestamp but the prior and subsequent journal files that do
 . ; have cluster timestamps, have the same timestamp. Force these 
 . ; journal files to be considered part of the cluster. Set the
 . ; sequence number to '*' (interpreted as 0) so that we'll tell the
 . ; user what's happened.
 . f  d  s d=$O(dirlist(d)) q:d=index
 . . s $P(dirlist(d),"^",4)="*",$P(dirlist(d),"^",7)="*"
 . . s $P(dirlist(d),"^",9)=clumstart
 . s index=$O(dirlist(index))
 ;
 d elimfiles(jffirst,jflast)
 ;
 ; Finally, go through dirlist() and validate the journal file back
 ; pointers. The 2nd piece of each entry is the prior journal file
 ; we got from that journal file's header. This should match the
 ; prior subscript in the dirlist() array. 
 ; 
 s header=0
 s d=$O(dirlist("")),next=$O(dirlist(d))
 f  q:next=""  d  s d=next,next=$O(dirlist(d))
 . s prevjrn=$P(dirlist(next),"^",2)
 . q:prevjrn=""  ; there isn't a stored prior journal name, that's ok
 . s prevjrn=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevjrn,";"),0:$e(prevjrn,*-8-$l($p(prevjrn,".",$l(prevjrn,"."))),*),:$e(prevjrn,*-8-$l($p(prevjrn,".",$l(prevjrn,"."))),$f(prevjrn,";")-2)),:prevjrn)
 . q:$E(d,1,$L(d)-1)=prevjrn
 . s err=1
 . i 'header d
 . . w !,"Apparent missing journal file(s) for cluster system #",id
 . . w !,"We located journal files: "
 . . s header=1
 . e  w !,"additionally, we located journal files: "
 . w !,?5,$P(dirlist(d),"^")
 . w !,?5,$P(dirlist(next),"^")
 . w !,"but it appears that at least one intervening journal file"
 . w !,?5,$P(dirlist(next),"^",2)," is missing."
 ;
 Q
elimfiles(jffirst,jflast) 
 ;
 ; Impose the limits of jffirst and jflast on the contents
 ; of dirlist() discarding files outside of the limits. jffirst and
 ; jflast represent the 1st and last journal files we want to
 ; restore. If we remove any journal files then check for journal
 ; files that have a sequence # of '*' at the start or end of the
 ; list and if there are any, set the sequence #'s and the cluster
 ; mstart time to 0 because these are no longer "surrounded" by 
 ; journal files from the same cluster start.
 ;
 n d,next
 q:'$D(dirlist)  ; its empty, nothing to do
 ;
 i jffirst'="" d
 . s jffirst=jffirst_"J"
 . s d=$O(dirlist(jffirst),-1)
 . f  q:d=""  s next=$O(dirlist(d),-1) k dirlist(d) s d=next
 . s d=""
 . f  s d=$O(dirlist(d)) q:d=""  q:$P(dirlist(d),"^",4)'="*"  d
 . . s $P(dirlist(d),"^",4)=0,$P(dirlist(d),"^",7)=0
 . . s $P(dirlist(d),"^",9)=0
 ;
 ; If dirlist(jflast) exists then delete all subsequent entries
 ; if it doesn't exist then delete all entries AFTER
 ; $O(dirlist(jflast))
 ;
 i jflast'="" d
 . s jflast=jflast_"J"
 . s d=$O(dirlist(jflast))
 . f  q:d=""  s next=$O(dirlist(d)) k dirlist(d) s d=next
 . s d=""
 . f  s d=$O(dirlist(d),-1) q:d=""  q:$P(dirlist(d),"^",4)'="*"  d
 . . s $P(dirlist(d),"^",4)=0,$P(dirlist(d),"^",7)=0
 . . s $P(dirlist(d),"^",9)=0
 q
findfilesER ;
 s $ZT=""
 s err=1
 i chan>0,$zu(78,7,chan)
 w !,"Error ",$ZE," encountered locating files for system #",id
 q
storejrnpath(id) ;
 ; Input: prefix and lookpath
 ; Stores info in the clumember(id) array. id #0 is the 
 ; "primary" system which is driving the restore
 n i
 s $P(clumember(id),"^",3)=prefix
 s clumember(id,"path")=lookpath
 f i=1:1:lookpath s clumember(id,"path",i)=lookpath(i)
 q
 ;
SETCLULOOKPATH ;
 ; set look path in which journal files are searched for
 N x
 K lookpath 
 S lookpath=0
 F  r !,"     Directory to look for the files in? ",x Q:x=""  D
 . D FIXDIR^JRNRESTO(.x) 
 . S lookpath=lookpath+1,lookpath(lookpath)=x
 i 'lookpath d  g SETCLULOOKPATH
 . w !,"     You must enter at least one directory for each cluster"
 . w " member"
 Q
 ;
LOADCLUPARAM(config) ;
 ; Opens the file <config> and loads the journal file prefix and
 ; the list of directories they are located in. Returns 1 if
 ; we're succesful, 0 if there's an error.
 ;
 ; The file has the format:
 ;      journal prefix
 ;      journal file directory #1
 ;      journal file directory #2
 ;      journal file directory #3
 ;           .
 ;           .
 ;      journal file directory #n
 ;      journal file directory #1
 ;      *END*  <- the text "*END"
 n line
 s $ZT="CONFIGERR"
 k lookpath
 s lookpath=0
 s prefix=""
 o config::10 e  w !,"     failed to open ",config q 0
 u config 
 r line
 G:$ZEOF CONFIGEOF
 g:$E(line,1,4)="*END" CONFIGDONE
 s prefix=line
 f  r line g:$ZEOF CONFIGEOF q:line="*END"  d
 . D FIXDIR(.line) 
 . S lookpath=lookpath+1,lookpath(lookpath)=line
 ;
CONFIGDONE ;
 use 0
 c config
 i 'lookpath q 0  ; lookpath must be at least one
 q 1 ; success
CONFIGEOF ;
 s $ZE="<ENDOFFILE>" ;Come here when $ZEOF is set
CONFIGERR ;
 s $ZT=""
 u 0
 ; If we hit an end of file error and we've read the 
 ; prefix and at least one journal file destination, treat this
 ; as success
 i $ZE["<ENDOFFILE" g CONFIGDONE
 w !,"     Error ",$ZE," reading config file ",config 
 c config 
 q 0
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 i ($zversion(1)=1) d
 . n x
 . s x=$$ChkDirVALID(dir)
 . i x'="" s dir=x
 i '($zversion(1)=1) Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))
 i '($zversion(1)=1) s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 i ($zversion(1)=1) d  q dir
 . n x
 . s x=$$ChkDirVALID(dir)
 . i x'="" s dir=x
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 i ($zversion(1)=1) S $E(d1,$L(d1))="."_d2_"]"
 i '($zversion(1)=1) S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 i ($zversion(1)=1) q:$$ChkDirVALID(dir)="" 1  ; dir is invalid, return failure
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=1):"]",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""